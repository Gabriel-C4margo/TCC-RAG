"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(rsc)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoBatchQueue: () => (/* binding */ AutoBatchQueue),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   DEFAULT_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_BATCH_SIZE_LIMIT_BYTES),\n/* harmony export */   mergeRuntimeEnvIntoRun: () => (/* binding */ mergeRuntimeEnvIntoRun)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _experimental_otel_translator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./experimental/otel/translator.js */ \"(rsc)/./node_modules/langsmith/dist/experimental/otel/translator.js\");\n/* harmony import */ var _singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singletons/otel.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/otel.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/messages.js */ \"(rsc)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/prompts.js */ \"(rsc)/./node_modules/langsmith/dist/utils/prompts.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/error.js */ \"(rsc)/./node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/fast-safe-stringify/index.js */ \"(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction mergeRuntimeEnvIntoRun(run) {\n    const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getRuntimeEnvironment)();\n    const envVars = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangChainEnvVarsMetadata)();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime\n        },\n        metadata: {\n            ...envVars,\n            ...envVars.revision_id || \"revision_id\" in run && run.revision_id ? {\n                revision_id: (\"revision_id\" in run ? run.revision_id : undefined) ?? envVars.revision_id\n            } : {},\n            ...metadata\n        }\n    };\n    return run;\n}\nconst getTracingSamplingRate = (configRate)=>{\n    const samplingRateStr = configRate?.toString() ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url)=>{\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable){\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response)=>{\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nfunction _formatFeedbackScore(score) {\n    if (typeof score === \"number\") {\n        // Truncate at 4 decimal places\n        return Number(score.toFixed(4));\n    }\n    return score;\n}\nclass AutoBatchQueue {\n    constructor(){\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve)=>{\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(item.item, `Serializing run with id: ${item.item.id}`).length;\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            otelContext: item.otelContext,\n            apiKey: item.apiKey,\n            apiUrl: item.apiUrl,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop(upToSizeBytes) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while(poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0){\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it)=>({\n                    action: it.action,\n                    item: it.payload,\n                    otelContext: it.otelContext,\n                    apiKey: it.apiKey,\n                    apiUrl: it.apiUrl\n                })),\n            ()=>popped.forEach((it)=>it.itemPromiseResolve())\n        ];\n    }\n}\n// 20 MB\nconst DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;\nconst SERVER_INFO_REQUEST_TIMEOUT = 2500;\nconst DEFAULT_API_URL = \"https://api.smith.langchain.com\";\nclass Client {\n    constructor(config = {}){\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new AutoBatchQueue()\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGSMITH_TRACING_BACKGROUND\") === \"false\"\n        });\n        Object.defineProperty(this, \"traceBatchConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manualFlushMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"langSmithToOTELTranslator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"multipartStreamingDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGSMITH_DEBUG\") === \"true\"\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.timeout_ms = config.timeout_ms ?? 90000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__.AsyncCaller({\n            ...config.callerOptions ?? {},\n            debug: config.debug ?? this.debug\n        });\n        this.traceBatchConcurrency = config.traceBatchConcurrency ?? this.traceBatchConcurrency;\n        if (this.traceBatchConcurrency < 1) {\n            throw new Error(\"Trace batch concurrency must be positive.\");\n        }\n        this.debug = config.debug ?? this.debug;\n        this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__.AsyncCaller({\n            maxRetries: 2,\n            maxConcurrency: this.traceBatchConcurrency,\n            ...config.callerOptions ?? {},\n            onFailedResponseHook: handle429,\n            debug: config.debug ?? this.debug\n        });\n        this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.blockOnRootRunFinalization = config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.fetchOptions = config.fetchOptions || {};\n        this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;\n        if ((0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getOtelEnabled)()) {\n            this.langSmithToOTELTranslator = new _experimental_otel_translator_js__WEBPACK_IMPORTED_MODULE_0__.LangSmithToOTELTranslator();\n        }\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"ENDPOINT\") ?? DEFAULT_API_URL;\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        } else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        } else if (this.apiUrl.endsWith(\"/api/v1\")) {\n            this.webUrl = this.apiUrl.replace(\"/api/v1\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"beta\")) {\n            this.webUrl = \"https://beta.smith.langchain.com\";\n            return this.webUrl;\n        } else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_5__.__version__}`\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    _getPlatformEndpointPath(path) {\n        // Check if apiUrl already ends with /v1 or /v1/ to avoid double /v1/v1/ paths\n        const needsV1Prefix = this.apiUrl.slice(-3) !== \"/v1\" && this.apiUrl.slice(-4) !== \"/v1/\";\n        return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;\n    }\n    async processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    async processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    async prepareRunCreateOrUpdateInputs(run) {\n        const runParams = {\n            ...run\n        };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = await this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = await this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `Failed to fetch ${path}`);\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while(true){\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `Failed to fetch ${path}`);\n            const items = transform ? transform(await response.json()) : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? {\n            ...body\n        } : {};\n        while(true){\n            const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: JSON.stringify(bodyParams)\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    // Allows mocking for tests\n    _shouldSample() {\n        if (this.tracingSampleRate === undefined) {\n            return true;\n        }\n        return Math.random() < this.tracingSampleRate;\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs){\n                if (!this.filteredPostUuids.has(run.trace_id)) {\n                    sampled.push(run);\n                } else if (run.id === run.trace_id) {\n                    this.filteredPostUuids.delete(run.trace_id);\n                }\n            }\n            return sampled;\n        } else {\n            // For new runs, sample at trace level to maintain consistency\n            const sampled = [];\n            for (const run of runs){\n                const traceId = run.trace_id ?? run.id;\n                // If we've already made a decision about this trace, follow it\n                if (this.filteredPostUuids.has(traceId)) {\n                    continue;\n                }\n                // For new traces, apply sampling\n                if (run.id === traceId) {\n                    if (this._shouldSample()) {\n                        sampled.push(run);\n                    } else {\n                        this.filteredPostUuids.add(traceId);\n                    }\n                } else {\n                    // Child runs follow their trace's sampling decision\n                    sampled.push(run);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return this.batchSizeBytesLimit ?? serverInfo.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n    }\n    async _getMultiPartSupport() {\n        const serverInfo = await this._ensureServerInfo();\n        return serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false;\n    }\n    drainAutoBatchQueue(batchSizeLimit) {\n        const promises = [];\n        while(this.autoBatchQueue.items.length > 0){\n            const [batch, done] = this.autoBatchQueue.pop(batchSizeLimit);\n            if (!batch.length) {\n                done();\n                break;\n            }\n            const batchesByDestination = batch.reduce((acc, item)=>{\n                const apiUrl = item.apiUrl ?? this.apiUrl;\n                const apiKey = item.apiKey ?? this.apiKey;\n                const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;\n                const batchKey = isDefault ? \"default\" : `${apiUrl}|${apiKey}`;\n                if (!acc[batchKey]) {\n                    acc[batchKey] = [];\n                }\n                acc[batchKey].push(item);\n                return acc;\n            }, {});\n            const batchPromises = [];\n            for (const [batchKey, batch] of Object.entries(batchesByDestination)){\n                const batchPromise = this._processBatch(batch, {\n                    apiUrl: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[0],\n                    apiKey: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[1]\n                });\n                batchPromises.push(batchPromise);\n            }\n            // Wait for all batches to complete, then call the overall done callback\n            const allBatchesPromise = Promise.all(batchPromises).finally(done);\n            promises.push(allBatchesPromise);\n        }\n        return Promise.all(promises);\n    }\n    async _processBatch(batch, options) {\n        if (!batch.length) {\n            return;\n        }\n        try {\n            if (this.langSmithToOTELTranslator !== undefined) {\n                this._sendBatchToOTELTranslator(batch);\n            } else {\n                const ingestParams = {\n                    runCreates: batch.filter((item)=>item.action === \"create\").map((item)=>item.item),\n                    runUpdates: batch.filter((item)=>item.action === \"update\").map((item)=>item.item)\n                };\n                const serverInfo = await this._ensureServerInfo();\n                if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {\n                    await this.multipartIngestRuns(ingestParams, options);\n                } else {\n                    await this.batchIngestRuns(ingestParams, options);\n                }\n            }\n        } catch (e) {\n            console.error(\"Error exporting batch:\", e);\n        }\n    }\n    _sendBatchToOTELTranslator(batch) {\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const otelContextMap = new Map();\n            const operations = [];\n            for (const item of batch){\n                if (item.item.id && item.otelContext) {\n                    otelContextMap.set(item.item.id, item.otelContext);\n                    if (item.action === \"create\") {\n                        operations.push({\n                            operation: \"post\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item\n                        });\n                    } else {\n                        operations.push({\n                            operation: \"patch\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item\n                        });\n                    }\n                }\n            }\n            this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);\n        }\n    }\n    async processRunOperation(item) {\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        item.item = mergeRuntimeEnvIntoRun(item.item);\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (this.manualFlushMode) {\n            // Rely on manual flushing in serverless environments\n            return itemPromise;\n        }\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes) {\n            void this.drainAutoBatchQueue(sizeLimitBytes);\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(()=>{\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue(sizeLimitBytes);\n            }, this.autoBatchAggregationDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"get server info\");\n        const json = await response.json();\n        if (this.debug) {\n            console.log(\"\\n=== LangSmith Server Configuration ===\\n\" + JSON.stringify(json, null, 2) + \"\\n\");\n        }\n        return json;\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async ()=>{\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    } catch (e) {\n                        console.warn(`[WARNING]: LangSmith failed to fetch info on supported operations with status code ${e.status}. Falling back to batch operations and default limits.`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo)=>{\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    /**\n     * Flushes current queued traces.\n     */ async flush() {\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        await this.drainAutoBatchQueue(sizeLimitBytes);\n    }\n    _cloneCurrentOTELContext() {\n        const otel_trace = (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELTrace)();\n        const otel_context = (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELContext)();\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const currentSpan = otel_trace.getActiveSpan();\n            if (currentSpan) {\n                return otel_trace.setSpan(otel_context.active(), currentSpan);\n            }\n        }\n        return undefined;\n    }\n    async createRun(run, options) {\n        if (!this._filterForSampling([\n            run\n        ]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = await this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now()\n        });\n        if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n                otelContext,\n                apiKey: options?.apiKey,\n                apiUrl: options?.apiUrl\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate);\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async batchIngestRuns({ runCreates, runUpdates }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = await Promise.all(runCreates?.map((create)=>this.prepareRunCreateOrUpdateInputs(create)) ?? []);\n        let preparedUpdateParams = await Promise.all(runUpdates?.map((update)=>this.prepareRunCreateOrUpdateInputs(update)) ?? []);\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: preparedCreateParams,\n            patch: preparedUpdateParams\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: []\n        };\n        for (const k of [\n            \"post\",\n            \"patch\"\n        ]){\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while(batchItem !== undefined){\n                // Type is wrong but this is a deprecated code path anyway\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            const runIds = batchChunks.post.map((item)=>item.id).concat(batchChunks.patch.map((item)=>item.id)).join(\",\");\n            await this._postBatchIngestRuns((0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(batchChunks, `Ingesting runs with ids: ${runIds}`), options);\n        }\n    }\n    async _postBatchIngestRuns(body, options) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\"\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        const response = await this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: body,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"batch create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async multipartIngestRuns({ runCreates, runUpdates }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []){\n            const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined && preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []){\n            preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate)=>{\n            return runCreate.trace_id === undefined || runCreate.dotted_order === undefined;\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate)=>{\n            return runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined;\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\n                \"post\",\n                preparedCreateParams\n            ],\n            [\n                \"patch\",\n                preparedUpdateParams\n            ]\n        ]){\n            for (const originalPayload of payloads){\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;\n                const fields = {\n                    inputs,\n                    outputs,\n                    events,\n                    extra,\n                    error,\n                    serialized\n                };\n                // encode the main run payload\n                const stringifiedPayload = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([\n                        stringifiedPayload\n                    ], {\n                        type: `application/json; length=${stringifiedPayload.length}`\n                    })\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)){\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([\n                            stringifiedValue\n                        ], {\n                            type: `application/json; length=${stringifiedValue.length}`\n                        })\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, attachment] of Object.entries(attachments)){\n                            let contentType;\n                            let content;\n                            if (Array.isArray(attachment)) {\n                                [contentType, content] = attachment;\n                            } else {\n                                contentType = attachment.mimeType;\n                                content = attachment.data;\n                            }\n                            // Validate that the attachment name doesn't contain a '.'\n                            if (name.includes(\".\")) {\n                                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` + `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);\n                                continue;\n                            }\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([\n                                    content\n                                ], {\n                                    type: `${contentType}; length=${content.byteLength}`\n                                })\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"), options);\n    }\n    async _createNodeFetchBody(parts, boundary) {\n        // Create multipart form data manually using Blobs\n        const chunks = [];\n        for (const part of parts){\n            // Add field boundary\n            chunks.push(new Blob([\n                `--${boundary}\\r\\n`\n            ]));\n            chunks.push(new Blob([\n                `Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`,\n                `Content-Type: ${part.payload.type}\\r\\n\\r\\n`\n            ]));\n            chunks.push(part.payload);\n            chunks.push(new Blob([\n                \"\\r\\n\"\n            ]));\n        }\n        // Add final boundary\n        chunks.push(new Blob([\n            `--${boundary}--\\r\\n`\n        ]));\n        // Combine all chunks into a single Blob\n        const body = new Blob(chunks);\n        // Convert Blob to ArrayBuffer for compatibility\n        const arrayBuffer = await body.arrayBuffer();\n        return arrayBuffer;\n    }\n    async _createMultipartStream(parts, boundary) {\n        const encoder = new TextEncoder();\n        // Create a ReadableStream for streaming the multipart data\n        // Only do special handling if we're using node-fetch\n        const stream = new ReadableStream({\n            async start (controller) {\n                // Helper function to write a chunk to the stream\n                const writeChunk = async (chunk)=>{\n                    if (typeof chunk === \"string\") {\n                        controller.enqueue(encoder.encode(chunk));\n                    } else {\n                        controller.enqueue(chunk);\n                    }\n                };\n                // Write each part to the stream\n                for (const part of parts){\n                    // Write boundary and headers\n                    await writeChunk(`--${boundary}\\r\\n`);\n                    await writeChunk(`Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`);\n                    await writeChunk(`Content-Type: ${part.payload.type}\\r\\n\\r\\n`);\n                    // Write the payload\n                    const payloadStream = part.payload.stream();\n                    const reader = payloadStream.getReader();\n                    try {\n                        let result;\n                        while(!(result = await reader.read()).done){\n                            controller.enqueue(result.value);\n                        }\n                    } finally{\n                        reader.releaseLock();\n                    }\n                    await writeChunk(\"\\r\\n\");\n                }\n                // Write final boundary\n                await writeChunk(`--${boundary}--\\r\\n`);\n                controller.close();\n            }\n        });\n        return stream;\n    }\n    async _sendMultipartRequest(parts, context, options) {\n        // Create multipart form data boundary\n        const boundary = \"----LangSmithFormBoundary\" + Math.random().toString(36).slice(2);\n        const isNodeFetch = (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._globalFetchImplementationIsNodeFetch)();\n        const buildBuffered = ()=>this._createNodeFetchBody(parts, boundary);\n        const buildStream = ()=>this._createMultipartStream(parts, boundary);\n        const send = async (body)=>{\n            const headers = {\n                ...this.headers,\n                \"Content-Type\": `multipart/form-data; boundary=${boundary}`\n            };\n            if (options?.apiKey !== undefined) {\n                headers[\"x-api-key\"] = options.apiKey;\n            }\n            return this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {\n                method: \"POST\",\n                headers,\n                body,\n                duplex: \"half\",\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n        };\n        try {\n            let res;\n            let streamedAttempt = false;\n            // attempt stream only if not disabled and not using node-fetch\n            if (!isNodeFetch && !this.multipartStreamingDisabled) {\n                streamedAttempt = true;\n                res = await send(await buildStream());\n            } else {\n                res = await send(await buildBuffered());\n            }\n            // if stream fails, fallback to buffered body\n            if ((!this.multipartStreamingDisabled || streamedAttempt) && res.status === 422 && (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {\n                console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. ` + `This usually means the host does not support chunked uploads. ` + `Retrying with a buffered upload for operation \"${context}\".`);\n                // Disable streaming for future requests\n                this.multipartStreamingDisabled = true;\n                // retry with fully-buffered body\n                res = await send(await buildBuffered());\n            }\n            // raise if still failing\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"ingest multipart runs\", true);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e) {\n            console.warn(`${e.message.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run, options) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        if (run.inputs) {\n            run.inputs = await this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = await this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = {\n            ...run,\n            id: runId\n        };\n        if (!this._filterForSampling([\n            data\n        ], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            if (run.end_time !== undefined && data.parent_run_id === undefined && this.blockOnRootRunFinalization && !this.manualFlushMode) {\n                // Trigger batches as soon as a root trace ends and wait to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl\n                }).catch(console.error);\n                return;\n            } else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(run, `Serializing payload to update run with id: ${runId}`),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"update run\", true);\n    }\n    async readRun(runId, { loadChildRuns } = {\n        loadChildRuns: false\n    }) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            } else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({\n                    projectName: projectOpts?.projectName\n                })).id;\n            } else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            } else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"PROJECT\") || \"default\"\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        } else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        } else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            isRoot: false,\n            projectId: run.session_id,\n            traceId: run.trace_id\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b)=>(a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns){\n            if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (childRun.dotted_order?.startsWith(run.dotted_order ?? \"\") && childRun.id !== run.id) {\n                if (!(childRun.parent_run_id in treemap)) {\n                    treemap[childRun.parent_run_id] = [];\n                }\n                treemap[childRun.parent_run_id].push(childRun);\n                runs[childRun.id] = childRun;\n            }\n        }\n        run.child_runs = treemap[run.id] || [];\n        for(const runId in treemap){\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param treeFilter - The filter string to apply on other runs in the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */ async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [\n                projectId\n            ];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName) ? projectName : [\n                projectName\n            ];\n            const projectIds_ = await Promise.all(projectNames.map((name)=>this.readProject({\n                    projectName: name\n                }).then((project)=>project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\"\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot,\n            order\n        };\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)){\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            } else {\n                yield* runs;\n            }\n        }\n    }\n    async *listGroupRuns(props) {\n        const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset } = props;\n        const sessionId = projectId || (await this.readProject({\n            projectName\n        })).id;\n        const baseBody = {\n            session_id: sessionId,\n            group_by: groupBy,\n            filter,\n            start_time: startTime ? startTime.toISOString() : null,\n            end_time: endTime ? endTime.toISOString() : null,\n            limit: Number(limit) || 100\n        };\n        let currentOffset = Number(offset) || 0;\n        const path = \"/runs/group\";\n        const url = `${this.apiUrl}${path}`;\n        while(true){\n            const currentBody = {\n                ...baseBody,\n                offset: currentOffset\n            };\n            // Remove undefined values from the payload\n            const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value])=>value !== undefined));\n            const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(), url, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(filteredPayload),\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `Failed to fetch ${path}`);\n            const items = await response.json();\n            const { groups, total } = items;\n            if (groups.length === 0) {\n                break;\n            }\n            for (const thread of groups){\n                yield thread;\n            }\n            currentOffset += groups.length;\n            if (currentOffset >= total) {\n                break;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...projectIds || [],\n                ...await Promise.all(projectNames.map((name)=>this.readProject({\n                        projectName: name\n                    }).then((project)=>project.id)))\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value])=>value !== undefined));\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/runs/stats`, {\n            method: \"POST\",\n            headers: this.headers,\n            body: JSON.stringify(filteredPayload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"]()\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"unshare run\", true);\n    }\n    async readRunSharedLink(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds){\n                queryParams.append(\"id\", runId);\n            }\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(shareToken);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"unshare dataset\", true);\n    }\n    async readSharedDataset(shareToken) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(shareToken);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */ async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value])=>{\n            if (Array.isArray(value)) {\n                value.forEach((v)=>urlParams.append(key, v));\n            } else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${Array.isArray(result.detail) ? result.detail.join(\"\\n\") : \"Unspecified error\"}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example)=>({\n                ...example,\n                _hostUrl: this.getHostUrl()\n            }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), endpoint, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"create project\");\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = {\n                ...extra || {},\n                metadata\n            };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), endpoint, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"update project\");\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({\n            projectId,\n            projectName\n        });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({\n            datasetId,\n            datasetName\n        });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({\n            limit: \"1\"\n        });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)){\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds){\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)){\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        } else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId === undefined) {\n            projectId_ = (await this.readProject({\n                projectName\n            })).id;\n        } else {\n            projectId_ = projectId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId_);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `delete session ${projectId_} (${projectName})`, true);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key)=>{\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key)=>{\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"upload CSV\");\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? {\n                metadata\n            } : undefined\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"create dataset\");\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({\n            limit: \"1\"\n        });\n        if (datasetId && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n            path += `/${datasetId}`;\n        } else if (datasetName) {\n            params.append(\"name\", datasetName);\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName }) {\n        try {\n            await this.readDataset({\n                datasetId,\n                datasetName\n            });\n            return true;\n        } catch (e) {\n            if (// eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error && e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\" ? fromVersion : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString()\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n        // do nothing\n        } else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({\n                datasetName\n            })).id;\n        } else {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText.trim().split(\"\\n\").map((line)=>JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)){\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */ async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({\n            datasetName\n        })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(_datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/${_datasetId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"update dataset\");\n        return await response.json();\n    }\n    /**\n     * Updates a tag on a dataset.\n     *\n     * If the tag is already assigned to a different version of this dataset,\n     * the tag will be moved to the new version. The as_of parameter is used to\n     * determine which version of the dataset to apply the new tags to.\n     *\n     * It must be an exact version of the dataset to succeed. You can\n     * use the \"readDatasetVersion\" method to find the exact version\n     * to apply the tags to.\n     * @param params.datasetId The ID of the dataset to update. Must be provided if \"datasetName\" is not provided.\n     * @param params.datasetName The name of the dataset to update. Must be provided if \"datasetId\" is not provided.\n     * @param params.asOf The timestamp of the dataset to apply the new tags to.\n     * @param params.tag The new tag to apply to the dataset.\n     */ async updateDatasetTag(props) {\n        const { datasetId, datasetName, asOf, tag } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({\n            datasetName\n        })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(_datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/${_datasetId}/tags`, {\n            method: \"PUT\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                as_of: typeof asOf === \"string\" ? asOf : asOf.toISOString(),\n                tag\n            }),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"update dataset tags\");\n    }\n    async deleteDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n            path += `/${datasetId_}`;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async indexDataset({ datasetId, datasetName, tag }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (!datasetId_) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const data = {\n            tag: tag\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/${datasetId_}/index`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"index dataset\");\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */ async similarExamples(inputs, datasetId, limit, { filter } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/${datasetId}/search`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"fetch similar examples\");\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputsOrUpdate, outputs, options) {\n        if (isExampleCreate(inputsOrUpdate)) {\n            if (outputs !== undefined || options !== undefined) {\n                throw new Error(\"Cannot provide outputs or options when using ExampleCreate object\");\n            }\n        }\n        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;\n        const datasetName_ = outputs ? options?.datasetName : inputsOrUpdate.dataset_name;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName: datasetName_\n            });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();\n        let data;\n        if (!isExampleCreate(inputsOrUpdate)) {\n            data = {\n                inputs: inputsOrUpdate,\n                outputs,\n                created_at: createdAt_?.toISOString(),\n                id: options?.exampleId,\n                metadata: options?.metadata,\n                split: options?.split,\n                source_run_id: options?.sourceRunId,\n                use_source_run_io: options?.useSourceRunIO,\n                use_source_run_attachments: options?.useSourceRunAttachments,\n                attachments: options?.attachments\n            };\n        } else {\n            data = inputsOrUpdate;\n        }\n        const response = await this._uploadExamplesMultipart(datasetId_, [\n            data\n        ]);\n        const example = await this.readExample(response.example_ids?.[0] ?? uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"]());\n        return example;\n    }\n    async createExamples(propsOrUploads) {\n        if (Array.isArray(propsOrUploads)) {\n            if (propsOrUploads.length === 0) {\n                return [];\n            }\n            const uploads = propsOrUploads;\n            let datasetId_ = uploads[0].dataset_id;\n            const datasetName_ = uploads[0].dataset_name;\n            if (datasetId_ === undefined && datasetName_ === undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId\");\n            } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId, not both\");\n            } else if (datasetId_ === undefined) {\n                const dataset = await this.readDataset({\n                    datasetName: datasetName_\n                });\n                datasetId_ = dataset.id;\n            }\n            const response = await this._uploadExamplesMultipart(datasetId_, uploads);\n            const examples = await Promise.all(response.example_ids.map((id)=>this.readExample(id)));\n            return examples;\n        }\n        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;\n        if (inputs === undefined) {\n            throw new Error(\"Must provide inputs when using legacy parameters\");\n        }\n        let datasetId_ = datasetId;\n        const datasetName_ = datasetName;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName: datasetName_\n            });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx)=>{\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs?.[idx],\n                metadata: metadata?.[idx],\n                split: splits?.[idx],\n                id: exampleIds?.[idx],\n                attachments: attachments?.[idx],\n                source_run_id: sourceRunIds?.[idx],\n                use_source_run_io: useSourceRunIOs?.[idx],\n                use_source_run_attachments: useSourceRunAttachments?.[idx]\n            };\n        });\n        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);\n        const examples = await Promise.all(response.example_ids.map((id)=>this.readExample(id)));\n        return examples;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({\n            input\n        }, {\n            output: generation\n        }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message)=>{\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.isLangChainMessage)(generations) ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.convertLangChainMessageToExample)(generations) : generations;\n        return this.createExample({\n            input: finalInput\n        }, {\n            output: finalOutput\n        }, options);\n    }\n    async readExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        const rawExample = await this._get(path);\n        const { attachment_urls, ...rest } = rawExample;\n        const example = rest;\n        if (attachment_urls) {\n            example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value])=>{\n                acc[key.slice(\"attachment.\".length)] = {\n                    presigned_url: value.presigned_url,\n                    mime_type: value.mime_type\n                };\n                return acc;\n            }, {});\n        }\n        return example;\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n            dataset: datasetId_\n        });\n        const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits){\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        if (includeAttachments === true) {\n            [\n                \"attachment_urls\",\n                \"outputs\",\n                \"metadata\"\n            ].forEach((field)=>params.append(\"select\", field));\n        }\n        let i = 0;\n        for await (const rawExamples of this._getPaginated(\"/examples\", params)){\n            for (const rawExample of rawExamples){\n                const { attachment_urls, ...rest } = rawExample;\n                const example = rest;\n                if (attachment_urls) {\n                    example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value])=>{\n                        acc[key.slice(\"attachment.\".length)] = {\n                            presigned_url: value.presigned_url,\n                            mime_type: value.mime_type || undefined\n                        };\n                        return acc;\n                    }, {});\n                }\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async updateExample(exampleIdOrUpdate, update) {\n        let exampleId;\n        if (update) {\n            exampleId = exampleIdOrUpdate;\n        } else {\n            exampleId = exampleIdOrUpdate.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        let updateToUse;\n        if (update) {\n            updateToUse = {\n                id: exampleId,\n                ...update\n            };\n        } else {\n            updateToUse = exampleIdOrUpdate;\n        }\n        let datasetId;\n        if (updateToUse.dataset_id !== undefined) {\n            datasetId = updateToUse.dataset_id;\n        } else {\n            const example = await this.readExample(exampleId);\n            datasetId = example.dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, [\n            updateToUse\n        ]);\n    }\n    async updateExamples(update) {\n        // We will naively get dataset id from first example and assume it works for all\n        let datasetId;\n        if (update[0].dataset_id === undefined) {\n            const example = await this.readExample(update[0].id);\n            datasetId = example.dataset_id;\n        } else {\n            datasetId = update[0].dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, update);\n    }\n    /**\n     * Get dataset version by closest date or exact tag.\n     *\n     * Use this to resolve the nearest version to a given timestamp or for a given tag.\n     *\n     * @param options The options for getting the dataset version\n     * @param options.datasetId The ID of the dataset\n     * @param options.datasetName The name of the dataset\n     * @param options.asOf The timestamp of the dataset to retrieve\n     * @param options.tag The tag of the dataset to retrieve\n     * @returns The dataset version\n     */ async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {\n        let resolvedDatasetId;\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            resolvedDatasetId = dataset.id;\n        } else {\n            resolvedDatasetId = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(resolvedDatasetId);\n        if (asOf && tag || !asOf && !tag) {\n            throw new Error(\"Exactly one of asOf and tag must be specified.\");\n        }\n        const params = new URLSearchParams();\n        if (asOf !== undefined) {\n            params.append(\"as_of\", typeof asOf === \"string\" ? asOf : asOf.toISOString());\n        }\n        if (tag !== undefined) {\n            params.append(\"tag\", tag);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {\n            method: \"GET\",\n            headers: {\n                ...this.headers\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"read dataset version\");\n        return await response.json();\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        } else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        } else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id)=>{\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id);\n                return id;\n            }),\n            remove\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/${datasetId_}/splits`, {\n            method: \"PUT\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"update dataset splits\", true);\n    }\n    /**\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\n     */ async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = {\n        loadChildRuns: false\n    }) {\n        (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_7__.warnOnce)(\"This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\");\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, {\n                loadChildRuns\n            });\n        } else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        } else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);\n        return feedbacks[0];\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {}\n        };\n        if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = {\n                run_id: sourceRunId\n            };\n        }\n        if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"](),\n            run_id: runId,\n            key,\n            score: _formatFeedbackScore(score),\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId\n        };\n        const url = `${this.apiUrl}/feedback`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), url, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"create feedback\", true);\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = _formatFeedbackScore(score);\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"update feedback\", true);\n    }\n    async readFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys){\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes){\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)){\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId The ID of the run.\n     * @param feedbackKey The feedback key.\n     * @param options Additional options for the token.\n     * @param options.expiration The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */ async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            } else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        } else {\n            body[\"expires_in\"] = {\n                hours: 3\n            };\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/feedback/tokens`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0]\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {}\n        };\n        if (metadata) body.extra[\"metadata\"] = metadata;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/datasets/comparative`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        return await response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */ async *listPresignedFeedbackTokens(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const params = new URLSearchParams({\n            run_id: runId\n        });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)){\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        } else if (Array.isArray(results)) {\n            results_ = results;\n        } else {\n            results_ = [\n                results\n            ];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults){\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = {\n                    ...res.evaluatorInfo,\n                    ...sourceInfo_\n                };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            } else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\"\n            }));\n        }\n        return [\n            evalResults,\n            feedbacks\n        ];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */ /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */ async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i)=>{\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name) params.append(\"name\", name);\n        if (nameContains) params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)){\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit) break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */ async createAnnotationQueue(options) {\n        const { name, description, queueId, rubricInstructions } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"](),\n            rubric_instructions: rubricInstructions\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/annotation-queues`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v])=>v !== undefined))),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"create annotation queue\");\n        const data = await response.json();\n        return data;\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueueWithDetails object\n     */ async readAnnotationQueue(queueId) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"read annotation queue\");\n        const data = await response.json();\n        return data;\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */ async updateAnnotationQueue(queueId, options) {\n        const { name, description, rubricInstructions } = options;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                name,\n                description,\n                rubric_instructions: rubricInstructions\n            }),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"update annotation queue\");\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */ async deleteAnnotationQueue(queueId) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n            method: \"DELETE\",\n            headers: {\n                ...this.headers,\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"delete annotation queue\");\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */ async addRunsToAnnotationQueue(queueId, runIds) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/runs`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(runIds.map((id, i)=>(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id, `runIds[${i}]`).toString())),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"add runs to annotation queue\");\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */ async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}${baseUrl}/${index}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"get run from annotation queue\");\n        return await response.json();\n    }\n    /**\n     * Delete a run from an an annotation queue.\n     * @param queueId - The ID of the annotation queue to delete the run from\n     * @param queueRunId - The ID of the run to delete from the annotation queue\n     */ async deleteRunFromAnnotationQueue(queueId, queueRunId) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/runs/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueRunId, \"queueRunId\")}`, {\n            method: \"DELETE\",\n            headers: {\n                ...this.headers,\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"delete run from annotation queue\");\n    }\n    /**\n     * Get the size of an annotation queue.\n     * @param queueId - The ID of the annotation queue\n     */ async getSizeFromAnnotationQueue(queueId) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/size`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"get size from annotation queue\");\n        return await response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const res = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const json = await res.json();\n        if (!res.ok) {\n            const detail = typeof json.detail === \"string\" ? json.detail : JSON.stringify(json.detail);\n            const error = new Error(`Error ${res.status}: ${res.statusText}\\n${detail}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            error.statusCode = res.status;\n            throw error;\n        }\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/likes/${owner}/${promptName}`, {\n            method: \"POST\",\n            body: JSON.stringify({\n                like: like\n            }),\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `${like ? \"like\" : \"unlike\"} prompt`);\n        return await response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            } else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        } else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            } else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res)=>res.commits)){\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res)=>res.repos)){\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        if (response.status === 404) {\n            return null;\n        }\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"get prompt\");\n        const result = await response.json();\n        if (result.repo) {\n            return result.repo;\n        } else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle.\n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...options?.description && {\n                description: options.description\n            },\n            ...options?.readme && {\n                readme: options.readme\n            },\n            ...options?.tags && {\n                tags: options.tags\n            },\n            is_public: !!options?.isPublic\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/repos/`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"create prompt\");\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"create commit\");\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    /**\n     * Update examples with attachments using multipart form data.\n     * @param updates List of ExampleUpdateWithAttachments objects to upsert\n     * @returns Promise with the update response\n     */ async updateExamplesMultipart(datasetId, updates = []) {\n        return this._updateExamplesMultipart(datasetId, updates);\n    }\n    async _updateExamplesMultipart(datasetId, updates = []) {\n        if (!await this._getMultiPartSupport()) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of updates){\n            const exampleId = example.id;\n            // Prepare the main example body\n            const exampleBody = {\n                ...example.metadata && {\n                    metadata: example.metadata\n                },\n                ...example.split && {\n                    split: example.split\n                }\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(exampleBody, `Serializing body for example with id: ${exampleId}`);\n            const exampleBlob = new Blob([\n                stringifiedExample\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.inputs, `Serializing inputs for example with id: ${exampleId}`);\n                const inputsBlob = new Blob([\n                    stringifiedInputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);\n                const outputsBlob = new Blob([\n                    stringifiedOutputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)){\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    } else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([\n                        data\n                    ], {\n                        type: `${mimeType}; length=${data.byteLength}`\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n            if (example.attachments_operations) {\n                const stringifiedAttachmentsOperations = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);\n                const attachmentsOperationsBlob = new Blob([\n                    stringifiedAttachmentsOperations\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);\n            }\n        }\n        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {\n            method: \"PATCH\",\n            headers: this.headers,\n            body: formData\n        });\n        const result = await response.json();\n        return result;\n    }\n    /**\n     * Upload examples with attachments using multipart form data.\n     * @param uploads List of ExampleUploadWithAttachments objects to upload\n     * @returns Promise with the upload response\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead\n     */ async uploadExamplesMultipart(datasetId, uploads = []) {\n        return this._uploadExamplesMultipart(datasetId, uploads);\n    }\n    async _uploadExamplesMultipart(datasetId, uploads = []) {\n        if (!await this._getMultiPartSupport()) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of uploads){\n            const exampleId = (example.id ?? uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"]()).toString();\n            // Prepare the main example body\n            const exampleBody = {\n                created_at: example.created_at,\n                ...example.metadata && {\n                    metadata: example.metadata\n                },\n                ...example.split && {\n                    split: example.split\n                },\n                ...example.source_run_id && {\n                    source_run_id: example.source_run_id\n                },\n                ...example.use_source_run_io && {\n                    use_source_run_io: example.use_source_run_io\n                },\n                ...example.use_source_run_attachments && {\n                    use_source_run_attachments: example.use_source_run_attachments\n                }\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);\n            const exampleBlob = new Blob([\n                stringifiedExample\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);\n                const inputsBlob = new Blob([\n                    stringifiedInputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);\n                const outputsBlob = new Blob([\n                    stringifiedOutputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)){\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    } else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([\n                        data\n                    ], {\n                        type: `${mimeType}; length=${data.byteLength}`\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"upload examples\");\n        const result = await response.json();\n        return result;\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined) payload.description = options.description;\n        if (options?.readme !== undefined) payload.readme = options.readme;\n        if (options?.tags !== undefined) payload.tags = options.tags;\n        if (options?.isPublic !== undefined) payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined) payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"PATCH\",\n            body: JSON.stringify(payload),\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"update prompt\");\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        return await response.json();\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, \"pull prompt commit\");\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples\n        };\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */ async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key)=>key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic\n                });\n            }\n        } else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */ async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\"\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({\n                datasetId: finalDatasetName\n            })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        } catch (_) {\n        // `.hasDataset` will throw an error if the dataset does not exist.\n        // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e)=>e.inputs),\n                outputs: examples.flatMap((e)=>e.outputs ? [\n                        e.outputs\n                    ] : []),\n                datasetId: dataset.id\n            });\n        } catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` + \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(urlOrToken); // Will throw if it's not a UUID.\n            return [\n                apiUrl,\n                urlOrToken\n            ];\n        } catch (_) {\n        // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname.split(\"/\").filter((part)=>part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [\n                    apiUrl,\n                    tokenUuid\n                ];\n            } else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        } catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */ async awaitPendingTraceBatches() {\n        if (this.manualFlushMode) {\n            console.warn(\"[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.\");\n            return Promise.resolve();\n        }\n        await Promise.all([\n            ...this.autoBatchQueue.items.map(({ itemPromise })=>itemPromise),\n            this.batchIngestCaller.queue.onIdle()\n        ]);\n        if (this.langSmithToOTELTranslator !== undefined) {\n            await (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOTLPTracerComponents)()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();\n        }\n    }\n}\nfunction isExampleCreate(input) {\n    return \"dataset_id\" in input || \"dataset_name\" in input;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ2tEO0FBQ3NCO0FBQy9DO0FBQ3NDO0FBQ2tFO0FBQ3JIO0FBQ0s7QUFDSDtBQUNnQjtBQUNUO0FBQ3NEO0FBQ1Q7QUFDeEYsU0FBU3NCLHVCQUF1QkMsR0FBRztJQUN0QyxNQUFNQyxhQUFhYixvRUFBcUJBO0lBQ3hDLE1BQU1jLFVBQVVoQiwwRUFBMkJBO0lBQzNDLE1BQU1pQixRQUFRSCxJQUFJRyxLQUFLLElBQUksQ0FBQztJQUM1QixNQUFNQyxXQUFXRCxNQUFNQyxRQUFRO0lBQy9CSixJQUFJRyxLQUFLLEdBQUc7UUFDUixHQUFHQSxLQUFLO1FBQ1JFLFNBQVM7WUFDTCxHQUFHSixVQUFVO1lBQ2IsR0FBR0UsT0FBT0UsT0FBTztRQUNyQjtRQUNBRCxVQUFVO1lBQ04sR0FBR0YsT0FBTztZQUNWLEdBQUlBLFFBQVFJLFdBQVcsSUFBSyxpQkFBaUJOLE9BQU9BLElBQUlNLFdBQVcsR0FDN0Q7Z0JBQ0VBLGFBQWEsQ0FBQyxpQkFBaUJOLE1BQU1BLElBQUlNLFdBQVcsR0FBR0MsU0FBUSxLQUMzREwsUUFBUUksV0FBVztZQUMzQixJQUNFLENBQUMsQ0FBQztZQUNSLEdBQUdGLFFBQVE7UUFDZjtJQUNKO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLE1BQU1RLHlCQUF5QixDQUFDQztJQUM1QixNQUFNQyxrQkFBa0JELFlBQVlFLGNBQ2hDeEIsOEVBQStCQSxDQUFDO0lBQ3BDLElBQUl1QixvQkFBb0JILFdBQVc7UUFDL0IsT0FBT0E7SUFDWDtJQUNBLE1BQU1LLGVBQWVDLFdBQVdIO0lBQ2hDLElBQUlFLGVBQWUsS0FBS0EsZUFBZSxHQUFHO1FBQ3RDLE1BQU0sSUFBSUUsTUFBTSxDQUFDLHFFQUFxRSxFQUFFRixhQUFhLENBQUM7SUFDMUc7SUFDQSxPQUFPQTtBQUNYO0FBQ0Esb0JBQW9CO0FBQ3BCLE1BQU1H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SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDRCxNQUFNTywyQkFBMkI7UUFDN0IsSUFBSSxJQUFJLENBQUM3a0IsZUFBZSxFQUFFO1lBQ3RCMEYsUUFBUWlCLElBQUksQ0FBQztZQUNiLE9BQU81SyxRQUFRQyxPQUFPO1FBQzFCO1FBQ0EsTUFBTUQsUUFBUStJLEdBQUcsQ0FBQztlQUNYLElBQUksQ0FBQ2IsY0FBYyxDQUFDbEgsS0FBSyxDQUFDaUIsR0FBRyxDQUFDLENBQUMsRUFBRWYsV0FBVyxFQUFFLEdBQUtBO1lBQ3RELElBQUksQ0FBQ29DLGlCQUFpQixDQUFDeWxCLEtBQUssQ0FBQ0MsTUFBTTtTQUN0QztRQUNELElBQUksSUFBSSxDQUFDOWtCLHlCQUF5QixLQUFLL0YsV0FBVztZQUM5QyxNQUFNNUIsbUZBQThCQSxJQUFJMHNCLGtDQUFrQ0M7UUFDOUU7SUFDSjtBQUNKO0FBQ0EsU0FBU3JOLGdCQUFnQndCLEtBQUs7SUFDMUIsT0FBTyxnQkFBZ0JBLFNBQVMsa0JBQWtCQTtBQUN0RCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9jbGllbnQuanM/ZWQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBMYW5nU21pdGhUb09URUxUcmFuc2xhdG9yLCB9IGZyb20gXCIuL2V4cGVyaW1lbnRhbC9vdGVsL3RyYW5zbGF0b3IuanNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cywgZ2V0T1RFTFRyYWNlLCBnZXRPVEVMQ29udGV4dCwgfSBmcm9tIFwiLi9zaW5nbGV0b25zL290ZWwuanNcIjtcbmltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSwgaXNMYW5nQ2hhaW5NZXNzYWdlLCB9IGZyb20gXCIuL3V0aWxzL21lc3NhZ2VzLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEsIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCwgZ2V0T3RlbEVuYWJsZWQsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRVdWlkIH0gZnJvbSBcIi4vdXRpbHMvX3V1aWQuanNcIjtcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSBcIi4vdXRpbHMvd2Fybi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VQcm9tcHRJZGVudGlmaWVyIH0gZnJvbSBcIi4vdXRpbHMvcHJvbXB0cy5qc1wiO1xuaW1wb3J0IHsgcmFpc2VGb3JTdGF0dXMgfSBmcm9tIFwiLi91dGlscy9lcnJvci5qc1wiO1xuaW1wb3J0IHsgX2dsb2JhbEZldGNoSW1wbGVtZW50YXRpb25Jc05vZGVGZXRjaCwgX2dldEZldGNoSW1wbGVtZW50YXRpb24sIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplIGFzIHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nIH0gZnJvbSBcIi4vdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUnVudGltZUVudkludG9SdW4ocnVuKSB7XG4gICAgY29uc3QgcnVudGltZUVudiA9IGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpO1xuICAgIGNvbnN0IGVudlZhcnMgPSBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEoKTtcbiAgICBjb25zdCBleHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGV4dHJhLm1ldGFkYXRhO1xuICAgIHJ1bi5leHRyYSA9IHtcbiAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICAgIC4uLnJ1bnRpbWVFbnYsXG4gICAgICAgICAgICAuLi5leHRyYT8ucnVudGltZSxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIC4uLmVudlZhcnMsXG4gICAgICAgICAgICAuLi4oZW52VmFycy5yZXZpc2lvbl9pZCB8fCAoXCJyZXZpc2lvbl9pZFwiIGluIHJ1biAmJiBydW4ucmV2aXNpb25faWQpXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJldmlzaW9uX2lkOiAoXCJyZXZpc2lvbl9pZFwiIGluIHJ1biA/IHJ1bi5yZXZpc2lvbl9pZCA6IHVuZGVmaW5lZCkgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGVudlZhcnMucmV2aXNpb25faWQsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gcnVuO1xufVxuY29uc3QgZ2V0VHJhY2luZ1NhbXBsaW5nUmF0ZSA9IChjb25maWdSYXRlKSA9PiB7XG4gICAgY29uc3Qgc2FtcGxpbmdSYXRlU3RyID0gY29uZmlnUmF0ZT8udG9TdHJpbmcoKSA/P1xuICAgICAgICBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiVFJBQ0lOR19TQU1QTElOR19SQVRFXCIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGVTdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzYW1wbGluZ1JhdGUgPSBwYXJzZUZsb2F0KHNhbXBsaW5nUmF0ZVN0cik7XG4gICAgaWYgKHNhbXBsaW5nUmF0ZSA8IDAgfHwgc2FtcGxpbmdSYXRlID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExBTkdTTUlUSF9UUkFDSU5HX1NBTVBMSU5HX1JBVEUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEgaWYgc2V0LiBHb3Q6ICR7c2FtcGxpbmdSYXRlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxpbmdSYXRlO1xufTtcbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBpc0xvY2FsaG9zdCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBzdHJpcHBlZFVybCA9IHVybC5yZXBsYWNlKFwiaHR0cDovL1wiLCBcIlwiKS5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgXCJcIik7XG4gICAgY29uc3QgaG9zdG5hbWUgPSBzdHJpcHBlZFVybC5zcGxpdChcIi9cIilbMF0uc3BsaXQoXCI6XCIpWzBdO1xuICAgIHJldHVybiAoaG9zdG5hbWUgPT09IFwibG9jYWxob3N0XCIgfHwgaG9zdG5hbWUgPT09IFwiMTI3LjAuMC4xXCIgfHwgaG9zdG5hbWUgPT09IFwiOjoxXCIpO1xufTtcbmFzeW5jIGZ1bmN0aW9uIHRvQXJyYXkoaXRlcmFibGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cmltUXVvdGVzKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL15cIiguKilcIiQvLCBcIiQxXCIpXG4gICAgICAgIC5yZXBsYWNlKC9eJyguKiknJC8sIFwiJDFcIik7XG59XG5jb25zdCBoYW5kbGU0MjkgPSBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICBpZiAocmVzcG9uc2U/LnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzLmdldChcInJldHJ5LWFmdGVyXCIpID8/IFwiMzBcIiwgMTApICogMTAwMDtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXIgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeUFmdGVyKSk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gZGlyZWN0bHkgYWZ0ZXIgY2FsbGluZyB0aGlzIGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWxsIGJhY2sgdG8gZXhpc3Rpbmcgc3RhdHVzIGNoZWNrc1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5mdW5jdGlvbiBfZm9ybWF0RmVlZGJhY2tTY29yZShzY29yZSkge1xuICAgIGlmICh0eXBlb2Ygc2NvcmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLy8gVHJ1bmNhdGUgYXQgNCBkZWNpbWFsIHBsYWNlc1xuICAgICAgICByZXR1cm4gTnVtYmVyKHNjb3JlLnRvRml4ZWQoNCkpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcmU7XG59XG5leHBvcnQgY2xhc3MgQXV0b0JhdGNoUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpdGVtc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpemVCeXRlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbMF07XG4gICAgfVxuICAgIHB1c2goaXRlbSkge1xuICAgICAgICBsZXQgaXRlbVByb21pc2VSZXNvbHZlO1xuICAgICAgICBjb25zdCBpdGVtUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIGl0ZW1Qcm9taXNlUmVzb2x2ZSBpcyBzeW5jaHJvbm91cyB3aXRoIHByb21pc2UgY3JlYXRpb246XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL1Byb21pc2VcbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaXplID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoaXRlbS5pdGVtLCBgU2VyaWFsaXppbmcgcnVuIHdpdGggaWQ6ICR7aXRlbS5pdGVtLmlkfWApLmxlbmd0aDtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIGFjdGlvbjogaXRlbS5hY3Rpb24sXG4gICAgICAgICAgICBwYXlsb2FkOiBpdGVtLml0ZW0sXG4gICAgICAgICAgICBvdGVsQ29udGV4dDogaXRlbS5vdGVsQ29udGV4dCxcbiAgICAgICAgICAgIGFwaUtleTogaXRlbS5hcGlLZXksXG4gICAgICAgICAgICBhcGlVcmw6IGl0ZW0uYXBpVXJsLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlUmVzb2x2ZTogaXRlbVByb21pc2VSZXNvbHZlLFxuICAgICAgICAgICAgaXRlbVByb21pc2UsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaXplQnl0ZXMgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIGl0ZW1Qcm9taXNlO1xuICAgIH1cbiAgICBwb3AodXBUb1NpemVCeXRlcykge1xuICAgICAgICBpZiAodXBUb1NpemVCeXRlcyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBvZiBieXRlcyB0byBwb3Agb2ZmIG1heSBub3QgYmUgbGVzcyB0aGFuIDEuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcHBlZCA9IFtdO1xuICAgICAgICBsZXQgcG9wcGVkU2l6ZUJ5dGVzID0gMDtcbiAgICAgICAgLy8gUG9wIGl0ZW1zIHVudGlsIHdlIHJlYWNoIG9yIGV4Y2VlZCB0aGUgc2l6ZSBsaW1pdFxuICAgICAgICB3aGlsZSAocG9wcGVkU2l6ZUJ5dGVzICsgKHRoaXMucGVlaygpPy5zaXplID8/IDApIDwgdXBUb1NpemVCeXRlcyAmJlxuICAgICAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBwb3BwZWRTaXplQnl0ZXMgKz0gaXRlbS5zaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZUJ5dGVzIC09IGl0ZW0uc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIG9uIHRoZSBxdWV1ZSB3ZSB3ZXJlIHVuYWJsZSB0byBwb3AsXG4gICAgICAgIC8vIGp1c3QgcmV0dXJuIGl0IGFzIGEgc2luZ2xlIGJhdGNoLlxuICAgICAgICBpZiAocG9wcGVkLmxlbmd0aCA9PT0gMCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHBvcHBlZFNpemVCeXRlcyArPSBpdGVtLnNpemU7XG4gICAgICAgICAgICB0aGlzLnNpemVCeXRlcyAtPSBpdGVtLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBvcHBlZC5tYXAoKGl0KSA9PiAoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogaXQuYWN0aW9uLFxuICAgICAgICAgICAgICAgIGl0ZW06IGl0LnBheWxvYWQsXG4gICAgICAgICAgICAgICAgb3RlbENvbnRleHQ6IGl0Lm90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgIGFwaUtleTogaXQuYXBpS2V5LFxuICAgICAgICAgICAgICAgIGFwaVVybDogaXQuYXBpVXJsLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgKCkgPT4gcG9wcGVkLmZvckVhY2goKGl0KSA9PiBpdC5pdGVtUHJvbWlzZVJlc29sdmUoKSksXG4gICAgICAgIF07XG4gICAgfVxufVxuLy8gMjAgTUJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVMgPSAyMF85NzFfNTIwO1xuY29uc3QgU0VSVkVSX0lORk9fUkVRVUVTVF9USU1FT1VUID0gMjUwMDtcbmNvbnN0IERFRkFVTFRfQVBJX1VSTCA9IFwiaHR0cHM6Ly9hcGkuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuZXhwb3J0IGNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpS2V5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaVVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3ZWJVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhdGNoSW5nZXN0Q2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpbWVvdXRfbXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RlbmFudElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaWRlSW5wdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhpZGVPdXRwdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNpbmdTYW1wbGVSYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbHRlcmVkUG9zdFV1aWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRyYWNpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgQXV0b0JhdGNoUXVldWUoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoVGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDI1MFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hTaXplQnl0ZXNMaW1pdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZXRjaE9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0dGluZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HU01JVEhfVFJBQ0lOR19CQUNLR1JPVU5EXCIpID09PSBcImZhbHNlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNlQmF0Y2hDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NlcnZlckluZm9cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2dldFNlcnZlckluZm9Qcm9taXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hbnVhbEZsdXNoTW9kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdTTUlUSF9ERUJVR1wiKSA9PT0gXCJ0cnVlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBDbGllbnQuZ2V0RGVmYXVsdENsaWVudENvbmZpZygpO1xuICAgICAgICB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlID0gZ2V0VHJhY2luZ1NhbXBsaW5nUmF0ZShjb25maWcudHJhY2luZ1NhbXBsaW5nUmF0ZSk7XG4gICAgICAgIHRoaXMuYXBpVXJsID0gdHJpbVF1b3Rlcyhjb25maWcuYXBpVXJsID8/IGRlZmF1bHRDb25maWcuYXBpVXJsKSA/PyBcIlwiO1xuICAgICAgICBpZiAodGhpcy5hcGlVcmwuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmFwaVVybCA9IHRoaXMuYXBpVXJsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaUtleSA/PyBkZWZhdWx0Q29uZmlnLmFwaUtleSk7XG4gICAgICAgIHRoaXMud2ViVXJsID0gdHJpbVF1b3Rlcyhjb25maWcud2ViVXJsID8/IGRlZmF1bHRDb25maWcud2ViVXJsKTtcbiAgICAgICAgaWYgKHRoaXMud2ViVXJsPy5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gdGhpcy53ZWJVcmwuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZW91dF9tcyA9IGNvbmZpZy50aW1lb3V0X21zID8/IDkwXzAwMDtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgLi4uKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIGRlYnVnOiBjb25maWcuZGVidWcgPz8gdGhpcy5kZWJ1ZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhY2VCYXRjaENvbmN1cnJlbmN5ID1cbiAgICAgICAgICAgIGNvbmZpZy50cmFjZUJhdGNoQ29uY3VycmVuY3kgPz8gdGhpcy50cmFjZUJhdGNoQ29uY3VycmVuY3k7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlQmF0Y2hDb25jdXJyZW5jeSA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYWNlIGJhdGNoIGNvbmN1cnJlbmN5IG11c3QgYmUgcG9zaXRpdmUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcgPSBjb25maWcuZGVidWcgPz8gdGhpcy5kZWJ1ZztcbiAgICAgICAgdGhpcy5iYXRjaEluZ2VzdENhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICBtYXhSZXRyaWVzOiAyLFxuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3k6IHRoaXMudHJhY2VCYXRjaENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgLi4uKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIG9uRmFpbGVkUmVzcG9uc2VIb29rOiBoYW5kbGU0MjksXG4gICAgICAgICAgICBkZWJ1ZzogY29uZmlnLmRlYnVnID8/IHRoaXMuZGVidWcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhpZGVJbnB1dHMgPVxuICAgICAgICAgICAgY29uZmlnLmhpZGVJbnB1dHMgPz8gY29uZmlnLmFub255bWl6ZXIgPz8gZGVmYXVsdENvbmZpZy5oaWRlSW5wdXRzO1xuICAgICAgICB0aGlzLmhpZGVPdXRwdXRzID1cbiAgICAgICAgICAgIGNvbmZpZy5oaWRlT3V0cHV0cyA/PyBjb25maWcuYW5vbnltaXplciA/PyBkZWZhdWx0Q29uZmlnLmhpZGVPdXRwdXRzO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRyYWNpbmcgPSBjb25maWcuYXV0b0JhdGNoVHJhY2luZyA/PyB0aGlzLmF1dG9CYXRjaFRyYWNpbmc7XG4gICAgICAgIHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24gPVxuICAgICAgICAgICAgY29uZmlnLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uID8/IHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb247XG4gICAgICAgIHRoaXMuYmF0Y2hTaXplQnl0ZXNMaW1pdCA9IGNvbmZpZy5iYXRjaFNpemVCeXRlc0xpbWl0O1xuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IGNvbmZpZy5mZXRjaE9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMubWFudWFsRmx1c2hNb2RlID0gY29uZmlnLm1hbnVhbEZsdXNoTW9kZSA/PyB0aGlzLm1hbnVhbEZsdXNoTW9kZTtcbiAgICAgICAgaWYgKGdldE90ZWxFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciA9IG5ldyBMYW5nU21pdGhUb09URUxUcmFuc2xhdG9yKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRDbGllbnRDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJBUElfS0VZXCIpO1xuICAgICAgICBjb25zdCBhcGlVcmwgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiRU5EUE9JTlRcIikgPz8gREVGQVVMVF9BUElfVVJMO1xuICAgICAgICBjb25zdCBoaWRlSW5wdXRzID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkhJREVfSU5QVVRTXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgY29uc3QgaGlkZU91dHB1dHMgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiSElERV9PVVRQVVRTXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwaVVybDogYXBpVXJsLFxuICAgICAgICAgICAgYXBpS2V5OiBhcGlLZXksXG4gICAgICAgICAgICB3ZWJVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhpZGVJbnB1dHM6IGhpZGVJbnB1dHMsXG4gICAgICAgICAgICBoaWRlT3V0cHV0czogaGlkZU91dHB1dHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEhvc3RVcmwoKSB7XG4gICAgICAgIGlmICh0aGlzLndlYlVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTG9jYWxob3N0KHRoaXMuYXBpVXJsKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLmVuZHNXaXRoKFwiL2FwaS92MVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSB0aGlzLmFwaVVybC5yZXBsYWNlKFwiL2FwaS92MVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5pbmNsdWRlcyhcIi9hcGlcIikgJiZcbiAgICAgICAgICAgICF0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uZW5kc1dpdGgoXCJhcGlcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gdGhpcy5hcGlVcmwucmVwbGFjZShcIi9hcGlcIiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmluY2x1ZGVzKFwiZGV2XCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9kZXYuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImV1XCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9ldS5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmluY2x1ZGVzKFwiYmV0YVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vYmV0YS5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIlVzZXItQWdlbnRcIjogYGxhbmdzbWl0aC1qcy8ke19fdmVyc2lvbl9ffWAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IGAke3RoaXMuYXBpS2V5fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIF9nZXRQbGF0Zm9ybUVuZHBvaW50UGF0aChwYXRoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGFwaVVybCBhbHJlYWR5IGVuZHMgd2l0aCAvdjEgb3IgL3YxLyB0byBhdm9pZCBkb3VibGUgL3YxL3YxLyBwYXRoc1xuICAgICAgICBjb25zdCBuZWVkc1YxUHJlZml4ID0gdGhpcy5hcGlVcmwuc2xpY2UoLTMpICE9PSBcIi92MVwiICYmIHRoaXMuYXBpVXJsLnNsaWNlKC00KSAhPT0gXCIvdjEvXCI7XG4gICAgICAgIHJldHVybiBuZWVkc1YxUHJlZml4ID8gYC92MS9wbGF0Zm9ybS8ke3BhdGh9YCA6IGAvcGxhdGZvcm0vJHtwYXRofWA7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NJbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVJbnB1dHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZGVJbnB1dHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaGlkZUlucHV0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlSW5wdXRzKGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc091dHB1dHMob3V0cHV0cykge1xuICAgICAgICBpZiAodGhpcy5oaWRlT3V0cHV0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZGVPdXRwdXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhpZGVPdXRwdXRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVPdXRwdXRzKG91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blBhcmFtcyA9IHsgLi4ucnVuIH07XG4gICAgICAgIGlmIChydW5QYXJhbXMuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1blBhcmFtcy5pbnB1dHMgPSBhd2FpdCB0aGlzLnByb2Nlc3NJbnB1dHMocnVuUGFyYW1zLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1blBhcmFtcy5vdXRwdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1blBhcmFtcy5vdXRwdXRzID0gYXdhaXQgdGhpcy5wcm9jZXNzT3V0cHV0cyhydW5QYXJhbXMub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1blBhcmFtcztcbiAgICB9XG4gICAgYXN5bmMgX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc1N0cmluZyA9IHF1ZXJ5UGFyYW1zPy50b1N0cmluZygpID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfSR7cGF0aH0/JHtwYXJhbXNTdHJpbmd9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYEZhaWxlZCB0byBmZXRjaCAke3BhdGh9YCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldChwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgKl9nZXRQYWdpbmF0ZWQocGF0aCwgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCksIHRyYW5zZm9ybSkge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gTnVtYmVyKHF1ZXJ5UGFyYW1zLmdldChcIm9mZnNldFwiKSkgfHwgMDtcbiAgICAgICAgY29uc3QgbGltaXQgPSBOdW1iZXIocXVlcnlQYXJhbXMuZ2V0KFwibGltaXRcIikpIHx8IDEwMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcIm9mZnNldFwiLCBTdHJpbmcob2Zmc2V0KSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoXCJsaW1pdFwiLCBTdHJpbmcobGltaXQpKTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfSR7cGF0aH0/JHtxdWVyeVBhcmFtc31gO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCB1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYEZhaWxlZCB0byBmZXRjaCAke3BhdGh9YCk7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtKGF3YWl0IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGl0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdChwYXRoLCBib2R5ID0gbnVsbCwgcmVxdWVzdE1ldGhvZCA9IFwiUE9TVFwiLCBkYXRhS2V5ID0gXCJydW5zXCIpIHtcbiAgICAgICAgY29uc3QgYm9keVBhcmFtcyA9IGJvZHkgPyB7IC4uLmJvZHkgfSA6IHt9O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5UGFyYW1zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5W2RhdGFLZXldKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCByZXNwb25zZUJvZHlbZGF0YUtleV07XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JzID0gcmVzcG9uc2VCb2R5LmN1cnNvcnM7XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3Vyc29ycy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5UGFyYW1zLmN1cnNvciA9IGN1cnNvcnMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBbGxvd3MgbW9ja2luZyBmb3IgdGVzdHNcbiAgICBfc2hvdWxkU2FtcGxlKCkge1xuICAgICAgICBpZiAodGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSA8IHRoaXMudHJhY2luZ1NhbXBsZVJhdGU7XG4gICAgfVxuICAgIF9maWx0ZXJGb3JTYW1wbGluZyhydW5zLCBwYXRjaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNpbmdTYW1wbGVSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBydW5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5oYXMocnVuLnRyYWNlX2lkKSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVkLnB1c2gocnVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVuLmlkID09PSBydW4udHJhY2VfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5kZWxldGUocnVuLnRyYWNlX2lkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBuZXcgcnVucywgc2FtcGxlIGF0IHRyYWNlIGxldmVsIHRvIG1haW50YWluIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1biBvZiBydW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2VJZCA9IHJ1bi50cmFjZV9pZCA/PyBydW4uaWQ7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBtYWRlIGEgZGVjaXNpb24gYWJvdXQgdGhpcyB0cmFjZSwgZm9sbG93IGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuaGFzKHRyYWNlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGb3IgbmV3IHRyYWNlcywgYXBwbHkgc2FtcGxpbmdcbiAgICAgICAgICAgICAgICBpZiAocnVuLmlkID09PSB0cmFjZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG91bGRTYW1wbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkUG9zdFV1aWRzLmFkZCh0cmFjZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hpbGQgcnVucyBmb2xsb3cgdGhlaXIgdHJhY2UncyBzYW1wbGluZyBkZWNpc2lvblxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVkLnB1c2gocnVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZ2V0QmF0Y2hTaXplTGltaXRCeXRlcygpIHtcbiAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVNlcnZlckluZm8oKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhdGNoU2l6ZUJ5dGVzTGltaXQgPz9cbiAgICAgICAgICAgIHNlcnZlckluZm8uYmF0Y2hfaW5nZXN0X2NvbmZpZz8uc2l6ZV9saW1pdF9ieXRlcyA/P1xuICAgICAgICAgICAgREVGQVVMVF9CQVRDSF9TSVpFX0xJTUlUX0JZVEVTKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldE11bHRpUGFydFN1cHBvcnQoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9lbnN1cmVTZXJ2ZXJJbmZvKCk7XG4gICAgICAgIHJldHVybiAoc2VydmVySW5mby5pbnN0YW5jZV9mbGFncz8uZGF0YXNldF9leGFtcGxlc19tdWx0aXBhcnRfZW5hYmxlZCA/PyBmYWxzZSk7XG4gICAgfVxuICAgIGRyYWluQXV0b0JhdGNoUXVldWUoYmF0Y2hTaXplTGltaXQpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgW2JhdGNoLCBkb25lXSA9IHRoaXMuYXV0b0JhdGNoUXVldWUucG9wKGJhdGNoU2l6ZUxpbWl0KTtcbiAgICAgICAgICAgIGlmICghYmF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmF0Y2hlc0J5RGVzdGluYXRpb24gPSBiYXRjaC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwaVVybCA9IGl0ZW0uYXBpVXJsID8/IHRoaXMuYXBpVXJsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwaUtleSA9IGl0ZW0uYXBpS2V5ID8/IHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRGVmYXVsdCA9IGl0ZW0uYXBpS2V5ID09PSB0aGlzLmFwaUtleSAmJiBpdGVtLmFwaVVybCA9PT0gdGhpcy5hcGlVcmw7XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2hLZXkgPSBpc0RlZmF1bHQgPyBcImRlZmF1bHRcIiA6IGAke2FwaVVybH18JHthcGlLZXl9YDtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY1tiYXRjaEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2JhdGNoS2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2NbYmF0Y2hLZXldLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2JhdGNoS2V5LCBiYXRjaF0gb2YgT2JqZWN0LmVudHJpZXMoYmF0Y2hlc0J5RGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2hQcm9taXNlID0gdGhpcy5fcHJvY2Vzc0JhdGNoKGJhdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgIGFwaVVybDogYmF0Y2hLZXkgPT09IFwiZGVmYXVsdFwiID8gdW5kZWZpbmVkIDogYmF0Y2hLZXkuc3BsaXQoXCJ8XCIpWzBdLFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IGJhdGNoS2V5ID09PSBcImRlZmF1bHRcIiA/IHVuZGVmaW5lZCA6IGJhdGNoS2V5LnNwbGl0KFwifFwiKVsxXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBiYXRjaFByb21pc2VzLnB1c2goYmF0Y2hQcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIGFsbCBiYXRjaGVzIHRvIGNvbXBsZXRlLCB0aGVuIGNhbGwgdGhlIG92ZXJhbGwgZG9uZSBjYWxsYmFja1xuICAgICAgICAgICAgY29uc3QgYWxsQmF0Y2hlc1Byb21pc2UgPSBQcm9taXNlLmFsbChiYXRjaFByb21pc2VzKS5maW5hbGx5KGRvbmUpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChhbGxCYXRjaGVzUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgYXN5bmMgX3Byb2Nlc3NCYXRjaChiYXRjaCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYW5nU21pdGhUb09URUxUcmFuc2xhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kQmF0Y2hUb09URUxUcmFuc2xhdG9yKGJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZ2VzdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuQ3JlYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuVXBkYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcInVwZGF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9lbnN1cmVTZXJ2ZXJJbmZvKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlckluZm8/LmJhdGNoX2luZ2VzdF9jb25maWc/LnVzZV9tdWx0aXBhcnRfZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tdWx0aXBhcnRJbmdlc3RSdW5zKGluZ2VzdFBhcmFtcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0UnVucyhpbmdlc3RQYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGV4cG9ydGluZyBiYXRjaDpcIiwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NlbmRCYXRjaFRvT1RFTFRyYW5zbGF0b3IoYmF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGVsQ29udGV4dE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW0uaWQgJiYgaXRlbS5vdGVsQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvdGVsQ29udGV4dE1hcC5zZXQoaXRlbS5pdGVtLmlkLCBpdGVtLm90ZWxDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3N0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogaXRlbS5pdGVtLnRyYWNlX2lkID8/IGl0ZW0uaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW46IGl0ZW0uaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicGF0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiBpdGVtLml0ZW0udHJhY2VfaWQgPz8gaXRlbS5pdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjogaXRlbS5pdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IuZXhwb3J0QmF0Y2gob3BlcmF0aW9ucywgb3RlbENvbnRleHRNYXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NSdW5PcGVyYXRpb24oaXRlbSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvQmF0Y2hUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpdGVtLml0ZW0gPSBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuKGl0ZW0uaXRlbSk7XG4gICAgICAgIGNvbnN0IGl0ZW1Qcm9taXNlID0gdGhpcy5hdXRvQmF0Y2hRdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5tYW51YWxGbHVzaE1vZGUpIHtcbiAgICAgICAgICAgIC8vIFJlbHkgb24gbWFudWFsIGZsdXNoaW5nIGluIHNlcnZlcmxlc3MgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICByZXR1cm4gaXRlbVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZUxpbWl0Qnl0ZXMgPSBhd2FpdCB0aGlzLl9nZXRCYXRjaFNpemVMaW1pdEJ5dGVzKCk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFF1ZXVlLnNpemVCeXRlcyA+IHNpemVMaW1pdEJ5dGVzKSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZShzaXplTGltaXRCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5kcmFpbkF1dG9CYXRjaFF1ZXVlKHNpemVMaW1pdEJ5dGVzKTtcbiAgICAgICAgICAgIH0sIHRoaXMuYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbVByb21pc2U7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRTZXJ2ZXJJbmZvKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9pbmZvYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoU0VSVkVSX0lORk9fUkVRVUVTVF9USU1FT1VUKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZ2V0IHNlcnZlciBpbmZvXCIpO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJcXG49PT0gTGFuZ1NtaXRoIFNlcnZlciBDb25maWd1cmF0aW9uID09PVxcblwiICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAyKSArXG4gICAgICAgICAgICAgICAgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGFzeW5jIF9lbnN1cmVTZXJ2ZXJJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZXJ2ZXJJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1dBUk5JTkddOiBMYW5nU21pdGggZmFpbGVkIHRvIGZldGNoIGluZm8gb24gc3VwcG9ydGVkIG9wZXJhdGlvbnMgd2l0aCBzdGF0dXMgY29kZSAke2Uuc3RhdHVzfS4gRmFsbGluZyBiYWNrIHRvIGJhdGNoIG9wZXJhdGlvbnMgYW5kIGRlZmF1bHQgbGltaXRzLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJJbmZvID8/IHt9O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UudGhlbigoc2VydmVySW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlcnZlckluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlckluZm87XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHRoaXMuX2dldChcIi9zZXR0aW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBjdXJyZW50IHF1ZXVlZCB0cmFjZXMuXG4gICAgICovXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGNvbnN0IHNpemVMaW1pdEJ5dGVzID0gYXdhaXQgdGhpcy5fZ2V0QmF0Y2hTaXplTGltaXRCeXRlcygpO1xuICAgICAgICBhd2FpdCB0aGlzLmRyYWluQXV0b0JhdGNoUXVldWUoc2l6ZUxpbWl0Qnl0ZXMpO1xuICAgIH1cbiAgICBfY2xvbmVDdXJyZW50T1RFTENvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IG90ZWxfdHJhY2UgPSBnZXRPVEVMVHJhY2UoKTtcbiAgICAgICAgY29uc3Qgb3RlbF9jb250ZXh0ID0gZ2V0T1RFTENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3BhbiA9IG90ZWxfdHJhY2UuZ2V0QWN0aXZlU3BhbigpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTcGFuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90ZWxfdHJhY2Uuc2V0U3BhbihvdGVsX2NvbnRleHQuYWN0aXZlKCksIGN1cnJlbnRTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVSdW4ocnVuLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcoW3J1bl0pLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbl9uYW1lID0gcnVuLnByb2plY3RfbmFtZTtcbiAgICAgICAgZGVsZXRlIHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IGF3YWl0IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHtcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZSxcbiAgICAgICAgICAgIC4uLnJ1bixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5zdGFydF90aW1lID8/IERhdGUubm93KCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hUcmFjaW5nICYmXG4gICAgICAgICAgICBydW5DcmVhdGUudHJhY2VfaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGVsQ29udGV4dCA9IHRoaXMuX2Nsb25lQ3VycmVudE9URUxDb250ZXh0KCk7XG4gICAgICAgICAgICB2b2lkIHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgICAgIGl0ZW06IHJ1bkNyZWF0ZSxcbiAgICAgICAgICAgICAgICBvdGVsQ29udGV4dCxcbiAgICAgICAgICAgICAgICBhcGlLZXk6IG9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgICAgICAgICBhcGlVcmw6IG9wdGlvbnM/LmFwaVVybCxcbiAgICAgICAgICAgIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lcmdlZFJ1bkNyZWF0ZVBhcmFtID0gbWVyZ2VSdW50aW1lRW52SW50b1J1bihydW5DcmVhdGUpO1xuICAgICAgICBpZiAob3B0aW9ucz8uYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBvcHRpb25zLmFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke29wdGlvbnM/LmFwaVVybCA/PyB0aGlzLmFwaVVybH0vcnVuc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcobWVyZ2VkUnVuQ3JlYXRlUGFyYW0sIGBDcmVhdGluZyBydW4gd2l0aCBpZDogJHttZXJnZWRSdW5DcmVhdGVQYXJhbS5pZH1gKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgcnVuXCIsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBiYXRjaEluZ2VzdFJ1bnMoeyBydW5DcmVhdGVzLCBydW5VcGRhdGVzLCB9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChydW5DcmVhdGVzID09PSB1bmRlZmluZWQgJiYgcnVuVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gYXdhaXQgUHJvbWlzZS5hbGwocnVuQ3JlYXRlcz8ubWFwKChjcmVhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKGNyZWF0ZSkpID8/IFtdKTtcbiAgICAgICAgbGV0IHByZXBhcmVkVXBkYXRlUGFyYW1zID0gYXdhaXQgUHJvbWlzZS5hbGwocnVuVXBkYXRlcz8ubWFwKCh1cGRhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHVwZGF0ZSkpID8/IFtdKTtcbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA+IDAgJiYgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlQnlJZCA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLnJlZHVjZSgocGFyYW1zLCBydW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbcnVuLmlkXSA9IHJ1bjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhbG9uZVVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlUGFyYW0gb2YgcHJlcGFyZWRVcGRhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGFyYW0uaWQgIT09IHVuZGVmaW5lZCAmJiBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlUGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lVXBkYXRlcy5wdXNoKHVwZGF0ZVBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IE9iamVjdC52YWx1ZXMoY3JlYXRlQnlJZCk7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHN0YW5kYWxvbmVVcGRhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0JhdGNoID0ge1xuICAgICAgICAgICAgcG9zdDogcHJlcGFyZWRDcmVhdGVQYXJhbXMsXG4gICAgICAgICAgICBwYXRjaDogcHJlcGFyZWRVcGRhdGVQYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmF3QmF0Y2gucG9zdC5sZW5ndGggJiYgIXJhd0JhdGNoLnBhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoQ2h1bmtzID0ge1xuICAgICAgICAgICAgcG9zdDogW10sXG4gICAgICAgICAgICBwYXRjaDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBbXCJwb3N0XCIsIFwicGF0Y2hcIl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGs7XG4gICAgICAgICAgICBjb25zdCBiYXRjaEl0ZW1zID0gcmF3QmF0Y2hba2V5XS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsZXQgYmF0Y2hJdGVtID0gYmF0Y2hJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIHdoaWxlIChiYXRjaEl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFR5cGUgaXMgd3JvbmcgYnV0IHRoaXMgaXMgYSBkZXByZWNhdGVkIGNvZGUgcGF0aCBhbnl3YXlcbiAgICAgICAgICAgICAgICBiYXRjaENodW5rc1trZXldLnB1c2goYmF0Y2hJdGVtKTtcbiAgICAgICAgICAgICAgICBiYXRjaEl0ZW0gPSBiYXRjaEl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaENodW5rcy5wb3N0Lmxlbmd0aCA+IDAgfHwgYmF0Y2hDaHVua3MucGF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcnVuSWRzID0gYmF0Y2hDaHVua3MucG9zdFxuICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaWQpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChiYXRjaENodW5rcy5wYXRjaC5tYXAoKGl0ZW0pID0+IGl0ZW0uaWQpKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoYmF0Y2hDaHVua3MsIGBJbmdlc3RpbmcgcnVucyB3aXRoIGlkczogJHtydW5JZHN9YCksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9wb3N0QmF0Y2hJbmdlc3RSdW5zKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gb3B0aW9ucy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke29wdGlvbnM/LmFwaVVybCA/PyB0aGlzLmFwaVVybH0vcnVucy9iYXRjaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJiYXRjaCBjcmVhdGUgcnVuXCIsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBtdWx0aXBhcnRJbmdlc3RSdW5zKHsgcnVuQ3JlYXRlcywgcnVuVXBkYXRlcywgfSwgb3B0aW9ucykge1xuICAgICAgICBpZiAocnVuQ3JlYXRlcyA9PT0gdW5kZWZpbmVkICYmIHJ1blVwZGF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYW5zZm9ybSBhbmQgY29udmVydCB0byBkaWN0c1xuICAgICAgICBjb25zdCBhbGxBdHRhY2htZW50cyA9IHt9O1xuICAgICAgICBsZXQgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjcmVhdGUgb2YgcnVuQ3JlYXRlcyA/PyBbXSkge1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRDcmVhdGUgPSBhd2FpdCB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhjcmVhdGUpO1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlLmlkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBwcmVwYXJlZENyZWF0ZS5hdHRhY2htZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWxsQXR0YWNobWVudHNbcHJlcGFyZWRDcmVhdGUuaWRdID0gcHJlcGFyZWRDcmVhdGUuYXR0YWNobWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgcHJlcGFyZWRDcmVhdGUuYXR0YWNobWVudHM7XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcy5wdXNoKHByZXBhcmVkQ3JlYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB1cGRhdGUgb2YgcnVuVXBkYXRlcyA/PyBbXSkge1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMucHVzaChhd2FpdCB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh1cGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXF1aXJlIHRyYWNlX2lkIGFuZCBkb3R0ZWRfb3JkZXJcbiAgICAgICAgY29uc3QgaW52YWxpZFJ1bkNyZWF0ZSA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLmZpbmQoKHJ1bkNyZWF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChydW5DcmVhdGUudHJhY2VfaWQgPT09IHVuZGVmaW5lZCB8fCBydW5DcmVhdGUuZG90dGVkX29yZGVyID09PSB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludmFsaWRSdW5DcmVhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBhcnQgaW5nZXN0IHJlcXVpcmVzIFwidHJhY2VfaWRcIiBhbmQgXCJkb3R0ZWRfb3JkZXJcIiB0byBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIHJ1bmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludmFsaWRSdW5VcGRhdGUgPSBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5maW5kKChydW5VcGRhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocnVuVXBkYXRlLnRyYWNlX2lkID09PSB1bmRlZmluZWQgfHwgcnVuVXBkYXRlLmRvdHRlZF9vcmRlciA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnZhbGlkUnVuVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwYXJ0IGluZ2VzdCByZXF1aXJlcyBcInRyYWNlX2lkXCIgYW5kIFwiZG90dGVkX29yZGVyXCIgdG8gYmUgc2V0IHdoZW4gdXBkYXRpbmcgYSBydW5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21iaW5lIHBvc3QgYW5kIHBhdGNoIGRpY3RzIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPiAwICYmIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJ5SWQgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5yZWR1Y2UoKHBhcmFtcywgcnVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zW3J1bi5pZF0gPSBydW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYWxvbmVVcGRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZVBhcmFtIG9mIHByZXBhcmVkVXBkYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQgJiYgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhbG9uZVVwZGF0ZXMucHVzaCh1cGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBPYmplY3QudmFsdWVzKGNyZWF0ZUJ5SWQpO1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBzdGFuZGFsb25lVXBkYXRlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGVQYXJhbXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZW5kIHRoZSBydW5zIGluIG11bHRpcGFydCByZXF1ZXN0c1xuICAgICAgICBjb25zdCBhY2N1bXVsYXRlZENvbnRleHQgPSBbXTtcbiAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFttZXRob2QsIHBheWxvYWRzXSBvZiBbXG4gICAgICAgICAgICBbXCJwb3N0XCIsIHByZXBhcmVkQ3JlYXRlUGFyYW1zXSxcbiAgICAgICAgICAgIFtcInBhdGNoXCIsIHByZXBhcmVkVXBkYXRlUGFyYW1zXSxcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcmlnaW5hbFBheWxvYWQgb2YgcGF5bG9hZHMpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IGZpZWxkcyB0byBiZSBzZW50IGFzIHNlcGFyYXRlIHBhcnRzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbnB1dHMsIG91dHB1dHMsIGV2ZW50cywgZXh0cmEsIGVycm9yLCBzZXJpYWxpemVkLCBhdHRhY2htZW50cywgLi4ucGF5bG9hZCB9ID0gb3JpZ2luYWxQYXlsb2FkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHsgaW5wdXRzLCBvdXRwdXRzLCBldmVudHMsIGV4dHJhLCBlcnJvciwgc2VyaWFsaXplZCB9O1xuICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgbWFpbiBydW4gcGF5bG9hZFxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkUGF5bG9hZCA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKHBheWxvYWQsIGBTZXJpYWxpemluZyBmb3IgbXVsdGlwYXJ0IGluZ2VzdGlvbiBvZiBydW4gd2l0aCBpZDogJHtwYXlsb2FkLmlkfWApO1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke21ldGhvZH0uJHtwYXlsb2FkLmlkfWAsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtzdHJpbmdpZmllZFBheWxvYWRdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgYXBwbGljYXRpb24vanNvbjsgbGVuZ3RoPSR7c3RyaW5naWZpZWRQYXlsb2FkLmxlbmd0aH1gLCAvLyBlbmNvZGluZz1nemlwXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgZmllbGRzIHdlIGNvbGxlY3RlZFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkVmFsdWUgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyh2YWx1ZSwgYFNlcmlhbGl6aW5nICR7a2V5fSBmb3IgbXVsdGlwYXJ0IGluZ2VzdGlvbiBvZiBydW4gd2l0aCBpZDogJHtwYXlsb2FkLmlkfWApO1xuICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYCR7bWV0aG9kfS4ke3BheWxvYWQuaWR9LiR7a2V5fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBuZXcgQmxvYihbc3RyaW5naWZpZWRWYWx1ZV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgYXBwbGljYXRpb24vanNvbjsgbGVuZ3RoPSR7c3RyaW5naWZpZWRWYWx1ZS5sZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIHRoZSBhdHRhY2htZW50c1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudHMgPSBhbGxBdHRhY2htZW50c1twYXlsb2FkLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWxsQXR0YWNobWVudHNbcGF5bG9hZC5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBhdHRhY2htZW50XSBvZiBPYmplY3QuZW50cmllcyhhdHRhY2htZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0YWNobWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbnRlbnRUeXBlLCBjb250ZW50XSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGF0dGFjaG1lbnQubWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBhdHRhY2htZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIGF0dGFjaG1lbnQgbmFtZSBkb2Vzbid0IGNvbnRhaW4gYSAnLidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmNsdWRlcyhcIi5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyBhdHRhY2htZW50ICcke25hbWV9JyBmb3IgcnVuICR7cGF5bG9hZC5pZH06IEludmFsaWQgYXR0YWNobWVudCBuYW1lLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBBdHRhY2htZW50IG5hbWVzIG11c3Qgbm90IGNvbnRhaW4gcGVyaW9kcyAoJy4nKS4gUGxlYXNlIHJlbmFtZSB0aGUgYXR0YWNobWVudCBhbmQgdHJ5IGFnYWluLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYGF0dGFjaG1lbnQuJHtwYXlsb2FkLmlkfS4ke25hbWV9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbmV3IEJsb2IoW2NvbnRlbnRdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgJHtjb250ZW50VHlwZX07IGxlbmd0aD0ke2NvbnRlbnQuYnl0ZUxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGNvbnRleHRcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZENvbnRleHQucHVzaChgdHJhY2U9JHtwYXlsb2FkLnRyYWNlX2lkfSxpZD0ke3BheWxvYWQuaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fc2VuZE11bHRpcGFydFJlcXVlc3QoYWNjdW11bGF0ZWRQYXJ0cywgYWNjdW11bGF0ZWRDb250ZXh0LmpvaW4oXCI7IFwiKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVOb2RlRmV0Y2hCb2R5KHBhcnRzLCBib3VuZGFyeSkge1xuICAgICAgICAvLyBDcmVhdGUgbXVsdGlwYXJ0IGZvcm0gZGF0YSBtYW51YWxseSB1c2luZyBCbG9ic1xuICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICAvLyBBZGQgZmllbGQgYm91bmRhcnlcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtgLS0ke2JvdW5kYXJ5fVxcclxcbmBdKSk7XG4gICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQmxvYihbXG4gICAgICAgICAgICAgICAgYENvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIiR7cGFydC5uYW1lfVwiXFxyXFxuYCxcbiAgICAgICAgICAgICAgICBgQ29udGVudC1UeXBlOiAke3BhcnQucGF5bG9hZC50eXBlfVxcclxcblxcclxcbmAsXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICBjaHVua3MucHVzaChwYXJ0LnBheWxvYWQpO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW1wiXFxyXFxuXCJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGZpbmFsIGJvdW5kYXJ5XG4gICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtgLS0ke2JvdW5kYXJ5fS0tXFxyXFxuYF0pKTtcbiAgICAgICAgLy8gQ29tYmluZSBhbGwgY2h1bmtzIGludG8gYSBzaW5nbGUgQmxvYlxuICAgICAgICBjb25zdCBib2R5ID0gbmV3IEJsb2IoY2h1bmtzKTtcbiAgICAgICAgLy8gQ29udmVydCBCbG9iIHRvIEFycmF5QnVmZmVyIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYm9keS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVNdWx0aXBhcnRTdHJlYW0ocGFydHMsIGJvdW5kYXJ5KSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgUmVhZGFibGVTdHJlYW0gZm9yIHN0cmVhbWluZyB0aGUgbXVsdGlwYXJ0IGRhdGFcbiAgICAgICAgLy8gT25seSBkbyBzcGVjaWFsIGhhbmRsaW5nIGlmIHdlJ3JlIHVzaW5nIG5vZGUtZmV0Y2hcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gd3JpdGUgYSBjaHVuayB0byB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVDaHVuayA9IGFzeW5jIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoY2h1bmspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIGVhY2ggcGFydCB0byB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIGJvdW5kYXJ5IGFuZCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlQ2h1bmsoYC0tJHtib3VuZGFyeX1cXHJcXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVDaHVuayhgQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiJHtwYXJ0Lm5hbWV9XCJcXHJcXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVDaHVuayhgQ29udGVudC1UeXBlOiAke3BhcnQucGF5bG9hZC50eXBlfVxcclxcblxcclxcbmApO1xuICAgICAgICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkU3RyZWFtID0gcGFydC5wYXlsb2FkLnN0cmVhbSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBwYXlsb2FkU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghKHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlQ2h1bmsoXCJcXHJcXG5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdyaXRlIGZpbmFsIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVDaHVuayhgLS0ke2JvdW5kYXJ5fS0tXFxyXFxuYCk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kTXVsdGlwYXJ0UmVxdWVzdChwYXJ0cywgY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBDcmVhdGUgbXVsdGlwYXJ0IGZvcm0gZGF0YSBib3VuZGFyeVxuICAgICAgICBjb25zdCBib3VuZGFyeSA9IFwiLS0tLUxhbmdTbWl0aEZvcm1Cb3VuZGFyeVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gICAgICAgIGNvbnN0IGlzTm9kZUZldGNoID0gX2dsb2JhbEZldGNoSW1wbGVtZW50YXRpb25Jc05vZGVGZXRjaCgpO1xuICAgICAgICBjb25zdCBidWlsZEJ1ZmZlcmVkID0gKCkgPT4gdGhpcy5fY3JlYXRlTm9kZUZldGNoQm9keShwYXJ0cywgYm91bmRhcnkpO1xuICAgICAgICBjb25zdCBidWlsZFN0cmVhbSA9ICgpID0+IHRoaXMuX2NyZWF0ZU11bHRpcGFydFN0cmVhbShwYXJ0cywgYm91bmRhcnkpO1xuICAgICAgICBjb25zdCBzZW5kID0gYXN5bmMgKGJvZHkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnM/LmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IG9wdGlvbnMuYXBpS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7b3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsfS9ydW5zL211bHRpcGFydGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgbGV0IHN0cmVhbWVkQXR0ZW1wdCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gYXR0ZW1wdCBzdHJlYW0gb25seSBpZiBub3QgZGlzYWJsZWQgYW5kIG5vdCB1c2luZyBub2RlLWZldGNoXG4gICAgICAgICAgICBpZiAoIWlzTm9kZUZldGNoICYmICF0aGlzLm11bHRpcGFydFN0cmVhbWluZ0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZWRBdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBzZW5kKGF3YWl0IGJ1aWxkU3RyZWFtKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgc2VuZChhd2FpdCBidWlsZEJ1ZmZlcmVkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgc3RyZWFtIGZhaWxzLCBmYWxsYmFjayB0byBidWZmZXJlZCBib2R5XG4gICAgICAgICAgICBpZiAoKCF0aGlzLm11bHRpcGFydFN0cmVhbWluZ0Rpc2FibGVkIHx8IHN0cmVhbWVkQXR0ZW1wdCkgJiZcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzID09PSA0MjIgJiZcbiAgICAgICAgICAgICAgICAob3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsKSAhPT0gREVGQVVMVF9BUElfVVJMKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTdHJlYW1pbmcgbXVsdGlwYXJ0IHVwbG9hZCB0byAke29wdGlvbnM/LmFwaVVybCA/PyB0aGlzLmFwaVVybH0vcnVucy9tdWx0aXBhcnQgZmFpbGVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFRoaXMgdXN1YWxseSBtZWFucyB0aGUgaG9zdCBkb2VzIG5vdCBzdXBwb3J0IGNodW5rZWQgdXBsb2Fkcy4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBSZXRyeWluZyB3aXRoIGEgYnVmZmVyZWQgdXBsb2FkIGZvciBvcGVyYXRpb24gXCIke2NvbnRleHR9XCIuYCk7XG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBzdHJlYW1pbmcgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdpdGggZnVsbHktYnVmZmVyZWQgYm9keVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IHNlbmQoYXdhaXQgYnVpbGRCdWZmZXJlZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJhaXNlIGlmIHN0aWxsIGZhaWxpbmdcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJpbmdlc3QgbXVsdGlwYXJ0IHJ1bnNcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7ZS5tZXNzYWdlLnRyaW0oKX1cXG5cXG5Db250ZXh0OiAke2NvbnRleHR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUnVuKHJ1bklkLCBydW4sIG9wdGlvbnMpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGlmIChydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gYXdhaXQgdGhpcy5wcm9jZXNzSW5wdXRzKHJ1bi5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW4ub3V0cHV0cykge1xuICAgICAgICAgICAgcnVuLm91dHB1dHMgPSBhd2FpdCB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1bi5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBVbnRhbmdsZSB0eXBlc1xuICAgICAgICBjb25zdCBkYXRhID0geyAuLi5ydW4sIGlkOiBydW5JZCB9O1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtkYXRhXSwgdHJ1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgZGF0YS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkYXRhLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGVsQ29udGV4dCA9IHRoaXMuX2Nsb25lQ3VycmVudE9URUxDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBkYXRhLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24gJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5tYW51YWxGbHVzaE1vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGJhdGNoZXMgYXMgc29vbiBhcyBhIHJvb3QgdHJhY2UgZW5kcyBhbmQgd2FpdCB0byBlbnN1cmUgdHJhY2UgZmluaXNoZXNcbiAgICAgICAgICAgICAgICAvLyBpbiBzZXJ2ZXJsZXNzIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IG9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBvcHRpb25zPy5hcGlVcmwsXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IG9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBvcHRpb25zPy5hcGlVcmwsXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucz8uYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBvcHRpb25zLmFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke29wdGlvbnM/LmFwaVVybCA/PyB0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKHJ1biwgYFNlcmlhbGl6aW5nIHBheWxvYWQgdG8gdXBkYXRlIHJ1biB3aXRoIGlkOiAke3J1bklkfWApLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBydW5cIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW4ocnVuSWQsIHsgbG9hZENoaWxkUnVucyB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBsZXQgcnVuID0gYXdhaXQgdGhpcy5fZ2V0KGAvcnVucy8ke3J1bklkfWApO1xuICAgICAgICBpZiAobG9hZENoaWxkUnVucykge1xuICAgICAgICAgICAgcnVuID0gYXdhaXQgdGhpcy5fbG9hZENoaWxkUnVucyhydW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blVybCh7IHJ1bklkLCBydW4sIHByb2plY3RPcHRzLCB9KSB7XG4gICAgICAgIGlmIChydW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgICAgICAgIGlmIChydW4uc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHJ1bi5zZXNzaW9uX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogcHJvamVjdE9wdHM/LnByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0T3B0cz8ucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlBST0pFQ1RcIikgfHwgXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gcHJvamVjdC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRlbmFudElkID0gYXdhaXQgdGhpcy5fZ2V0VGVuYW50SWQoKTtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vby8ke3RlbmFudElkfS9wcm9qZWN0cy9wLyR7c2Vzc2lvbklkfS9yLyR7cnVuLmlkfT9wb2xsPXRydWVgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bl8gPSBhd2FpdCB0aGlzLnJlYWRSdW4ocnVuSWQpO1xuICAgICAgICAgICAgaWYgKCFydW5fLmFwcF9wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSdW4gJHtydW5JZH0gaGFzIG5vIGFwcF9wYXRoYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gdGhpcy5nZXRIb3N0VXJsKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7YmFzZVVybH0ke3J1bl8uYXBwX3BhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcnVuSWQgb3IgcnVuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9sb2FkQ2hpbGRSdW5zKHJ1bikge1xuICAgICAgICBjb25zdCBjaGlsZFJ1bnMgPSBhd2FpdCB0b0FycmF5KHRoaXMubGlzdFJ1bnMoe1xuICAgICAgICAgICAgaXNSb290OiBmYWxzZSxcbiAgICAgICAgICAgIHByb2plY3RJZDogcnVuLnNlc3Npb25faWQsXG4gICAgICAgICAgICB0cmFjZUlkOiBydW4udHJhY2VfaWQsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgdHJlZW1hcCA9IHt9O1xuICAgICAgICBjb25zdCBydW5zID0ge307XG4gICAgICAgIC8vIFRPRE86IG1ha2UgZG90dGVkIG9yZGVyIHJlcXVpcmVkIHdoZW4gdGhlIG1pZ3JhdGlvbiBmaW5pc2hlc1xuICAgICAgICBjaGlsZFJ1bnMuc29ydCgoYSwgYikgPT4gKGE/LmRvdHRlZF9vcmRlciA/PyBcIlwiKS5sb2NhbGVDb21wYXJlKGI/LmRvdHRlZF9vcmRlciA/PyBcIlwiKSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRSdW4gb2YgY2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgcnVuICR7Y2hpbGRSdW4uaWR9IGhhcyBubyBwYXJlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZFJ1bi5kb3R0ZWRfb3JkZXI/LnN0YXJ0c1dpdGgocnVuLmRvdHRlZF9vcmRlciA/PyBcIlwiKSAmJlxuICAgICAgICAgICAgICAgIGNoaWxkUnVuLmlkICE9PSBydW4uaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkIGluIHRyZWVtYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyZWVtYXBbY2hpbGRSdW4ucGFyZW50X3J1bl9pZF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJlZW1hcFtjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkXS5wdXNoKGNoaWxkUnVuKTtcbiAgICAgICAgICAgICAgICBydW5zW2NoaWxkUnVuLmlkXSA9IGNoaWxkUnVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJ1bi5jaGlsZF9ydW5zID0gdHJlZW1hcFtydW4uaWRdIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bklkIGluIHRyZWVtYXApIHtcbiAgICAgICAgICAgIGlmIChydW5JZCAhPT0gcnVuLmlkKSB7XG4gICAgICAgICAgICAgICAgcnVuc1tydW5JZF0uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgcnVucyBmcm9tIHRoZSBMYW5nU21pdGggc2VydmVyLlxuICAgICAqIEBwYXJhbSBwcm9qZWN0SWQgLSBUaGUgSUQgb2YgdGhlIHByb2plY3QgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBwcm9qZWN0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0IHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcGFyZW50UnVuSWQgLSBUaGUgSUQgb2YgdGhlIHBhcmVudCBydW4gdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSB0cmFjZUlkIC0gVGhlIElEIG9mIHRoZSB0cmFjZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHJlZmVyZW5jZUV4YW1wbGVJZCAtIFRoZSBJRCBvZiB0aGUgcmVmZXJlbmNlIGV4YW1wbGUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGlzUm9vdCAtIEluZGljYXRlcyB3aGV0aGVyIHRvIG9ubHkgcmV0dXJuIHJvb3QgcnVucy5cbiAgICAgKiBAcGFyYW0gcnVuVHlwZSAtIFRoZSBydW4gdHlwZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGVycm9yIC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gZmlsdGVyIGJ5IGVycm9yIHJ1bnMuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBydW4gdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSBzdHJpbmcgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBUaGUgZmlsdGVyIHN0cmluZyB0byBhcHBseSB0byB0aGUgcnVuIHNwYW5zLlxuICAgICAqIEBwYXJhbSB0cmFjZUZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IG9uIHRoZSByb290IHJ1biBvZiB0aGUgdHJhY2UuXG4gICAgICogQHBhcmFtIHRyZWVGaWx0ZXIgLSBUaGUgZmlsdGVyIHN0cmluZyB0byBhcHBseSBvbiBvdGhlciBydW5zIGluIHRoZSB0cmFjZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcnVucyB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxSdW4+fSAtIFRoZSBydW5zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIGluIGEgcHJvamVjdFxuICAgICAqIGNvbnN0IHByb2plY3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHsgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBMTE0gYW5kIENoYXQgcnVucyBpbiB0aGUgbGFzdCAyNCBob3Vyc1xuICAgICAqIGNvbnN0IHRvZGF5c0xMTVJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIHN0YXJ0X3RpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgLSAyNCAqIDYwICogNjAgKiAxMDAwKSxcbiAgICAgKiAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHRyYWNlcyBpbiBhIHByb2plY3RcbiAgICAgKiBjb25zdCByb290UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXhlY3V0aW9uX29yZGVyOiAxLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgd2l0aG91dCBlcnJvcnNcbiAgICAgKiBjb25zdCBjb3JyZWN0UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXJyb3I6IGZhbHNlLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgYnkgcnVuIElEXG4gICAgICogY29uc3QgcnVuSWRzID0gW1xuICAgICAqICAgXCJhMzYwOTJkMi00YWQ1LTRmYjQtOWMwZC0wZGJhOWEyZWQ4MzZcIixcbiAgICAgKiAgIFwiOTM5OGU2YmUtOTY0Zi00YWE0LThhZTktYWQ3OGNkNGI3MDc0XCIsXG4gICAgICogXTtcbiAgICAgKiBjb25zdCBzZWxlY3RlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoeyBydW5faWRzOiBydW5JZHMgfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIFwiY2hhaW5cIiB0eXBlIHJ1bnMgdGhhdCB0b29rIG1vcmUgdGhhbiAxMCBzZWNvbmRzIGFuZCBoYWQgYHRvdGFsX3Rva2Vuc2AgZ3JlYXRlciB0aGFuIDUwMDBcbiAgICAgKiBjb25zdCBjaGFpblJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChlcShydW5fdHlwZSwgXCJjaGFpblwiKSwgZ3QobGF0ZW5jeSwgMTApLCBndCh0b3RhbF90b2tlbnMsIDUwMDApKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgY2FsbGVkIFwiZXh0cmFjdG9yXCIgd2hvc2Ugcm9vdCBvZiB0aGUgdHJhY2Ugd2FzIGFzc2lnbmVkIGZlZWRiYWNrIFwidXNlcl9zY29yZVwiIHNjb3JlIG9mIDFcbiAgICAgKiBjb25zdCBnb29kRXh0cmFjdG9yUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnZXEobmFtZSwgXCJleHRyYWN0b3JcIiknLFxuICAgICAqICAgdHJhY2VGaWx0ZXI6ICdhbmQoZXEoZmVlZGJhY2tfa2V5LCBcInVzZXJfc2NvcmVcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAxKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIHRoYXQgc3RhcnRlZCBhZnRlciBhIHNwZWNpZmljIHRpbWVzdGFtcCBhbmQgZWl0aGVyIGhhdmUgXCJlcnJvclwiIG5vdCBlcXVhbCB0byBudWxsIG9yIGEgXCJDb3JyZWN0bmVzc1wiIGZlZWRiYWNrIHNjb3JlIGVxdWFsIHRvIDBcbiAgICAgKiBjb25zdCBjb21wbGV4UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKGd0KHN0YXJ0X3RpbWUsIFwiMjAyMy0wNy0xNVQxMjozNDo1NlpcIiksIG9yKG5lcShlcnJvciwgbnVsbCksIGFuZChlcShmZWVkYmFja19rZXksIFwiQ29ycmVjdG5lc3NcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAwLjApKSkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyB3aGVyZSBgdGFnc2AgaW5jbHVkZSBcImV4cGVyaW1lbnRhbFwiIG9yIFwiYmV0YVwiIGFuZCBgbGF0ZW5jeWAgaXMgZ3JlYXRlciB0aGFuIDIgc2Vjb25kc1xuICAgICAqIGNvbnN0IHRhZ2dlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChvcihoYXModGFncywgXCJleHBlcmltZW50YWxcIiksIGhhcyh0YWdzLCBcImJldGFcIikpLCBndChsYXRlbmN5LCAyKSknLFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFzeW5jICpsaXN0UnVucyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIHBhcmVudFJ1bklkLCB0cmFjZUlkLCByZWZlcmVuY2VFeGFtcGxlSWQsIHN0YXJ0VGltZSwgZXhlY3V0aW9uT3JkZXIsIGlzUm9vdCwgcnVuVHlwZSwgZXJyb3IsIGlkLCBxdWVyeSwgZmlsdGVyLCB0cmFjZUZpbHRlciwgdHJlZUZpbHRlciwgbGltaXQsIHNlbGVjdCwgb3JkZXIsIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHByb2plY3RJZHMgPSBbXTtcbiAgICAgICAgaWYgKHByb2plY3RJZCkge1xuICAgICAgICAgICAgcHJvamVjdElkcyA9IEFycmF5LmlzQXJyYXkocHJvamVjdElkKSA/IHByb2plY3RJZCA6IFtwcm9qZWN0SWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdE5hbWVzID0gQXJyYXkuaXNBcnJheShwcm9qZWN0TmFtZSlcbiAgICAgICAgICAgICAgICA/IHByb2plY3ROYW1lXG4gICAgICAgICAgICAgICAgOiBbcHJvamVjdE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdElkc18gPSBhd2FpdCBQcm9taXNlLmFsbChwcm9qZWN0TmFtZXMubWFwKChuYW1lKSA9PiB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IG5hbWUgfSkudGhlbigocHJvamVjdCkgPT4gcHJvamVjdC5pZCkpKTtcbiAgICAgICAgICAgIHByb2plY3RJZHMucHVzaCguLi5wcm9qZWN0SWRzXyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdF9zZWxlY3QgPSBbXG4gICAgICAgICAgICBcImFwcF9wYXRoXCIsXG4gICAgICAgICAgICBcImNvbXBsZXRpb25fY29zdFwiLFxuICAgICAgICAgICAgXCJjb21wbGV0aW9uX3Rva2Vuc1wiLFxuICAgICAgICAgICAgXCJkb3R0ZWRfb3JkZXJcIixcbiAgICAgICAgICAgIFwiZW5kX3RpbWVcIixcbiAgICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgIFwiZXZlbnRzXCIsXG4gICAgICAgICAgICBcImV4dHJhXCIsXG4gICAgICAgICAgICBcImZlZWRiYWNrX3N0YXRzXCIsXG4gICAgICAgICAgICBcImZpcnN0X3Rva2VuX3RpbWVcIixcbiAgICAgICAgICAgIFwiaWRcIixcbiAgICAgICAgICAgIFwiaW5wdXRzXCIsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIFwib3V0cHV0c1wiLFxuICAgICAgICAgICAgXCJwYXJlbnRfcnVuX2lkXCIsXG4gICAgICAgICAgICBcInBhcmVudF9ydW5faWRzXCIsXG4gICAgICAgICAgICBcInByb21wdF9jb3N0XCIsXG4gICAgICAgICAgICBcInByb21wdF90b2tlbnNcIixcbiAgICAgICAgICAgIFwicmVmZXJlbmNlX2V4YW1wbGVfaWRcIixcbiAgICAgICAgICAgIFwicnVuX3R5cGVcIixcbiAgICAgICAgICAgIFwic2Vzc2lvbl9pZFwiLFxuICAgICAgICAgICAgXCJzdGFydF90aW1lXCIsXG4gICAgICAgICAgICBcInN0YXR1c1wiLFxuICAgICAgICAgICAgXCJ0YWdzXCIsXG4gICAgICAgICAgICBcInRvdGFsX2Nvc3RcIixcbiAgICAgICAgICAgIFwidG90YWxfdG9rZW5zXCIsXG4gICAgICAgICAgICBcInRyYWNlX2lkXCIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzLmxlbmd0aCA/IHByb2plY3RJZHMgOiBudWxsLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZTogcmVmZXJlbmNlRXhhbXBsZUlkLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICB0cmFjZV9maWx0ZXI6IHRyYWNlRmlsdGVyLFxuICAgICAgICAgICAgdHJlZV9maWx0ZXI6IHRyZWVGaWx0ZXIsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbk9yZGVyLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB0cmFjZTogdHJhY2VJZCxcbiAgICAgICAgICAgIHNlbGVjdDogc2VsZWN0ID8gc2VsZWN0IDogZGVmYXVsdF9zZWxlY3QsXG4gICAgICAgICAgICBpc19yb290OiBpc1Jvb3QsXG4gICAgICAgICAgICBvcmRlcixcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJ1bnNZaWVsZGVkID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBydW5zIG9mIHRoaXMuX2dldEN1cnNvclBhZ2luYXRlZExpc3QoXCIvcnVucy9xdWVyeVwiLCBib2R5KSkge1xuICAgICAgICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bnNZaWVsZGVkID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVucy5sZW5ndGggKyBydW5zWWllbGRlZCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1J1bnMgPSBydW5zLnNsaWNlKDAsIGxpbWl0IC0gcnVuc1lpZWxkZWQpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogbmV3UnVucztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bnNZaWVsZGVkICs9IHJ1bnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBydW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKmxpc3RHcm91cFJ1bnMocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBncm91cEJ5LCBmaWx0ZXIsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIG9mZnNldCwgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBwcm9qZWN0SWQgfHwgKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZSB9KSkuaWQ7XG4gICAgICAgIGNvbnN0IGJhc2VCb2R5ID0ge1xuICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbklkLFxuICAgICAgICAgICAgZ3JvdXBfYnk6IGdyb3VwQnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlbmRfdGltZTogZW5kVGltZSA/IGVuZFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBsaW1pdDogTnVtYmVyKGxpbWl0KSB8fCAxMDAsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL3J1bnMvZ3JvdXBcIjtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofWA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Qm9keSA9IHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlQm9keSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGN1cnJlbnRPZmZzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRQYXlsb2FkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGN1cnJlbnRCb2R5KS5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCB1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZpbHRlcmVkUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgRmFpbGVkIHRvIGZldGNoICR7cGF0aH1gKTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgeyBncm91cHMsIHRvdGFsIH0gPSBpdGVtcztcbiAgICAgICAgICAgIGlmIChncm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRocmVhZCBvZiBncm91cHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aHJlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGdyb3Vwcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY3VycmVudE9mZnNldCA+PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blN0YXRzKHsgaWQsIHRyYWNlLCBwYXJlbnRSdW4sIHJ1blR5cGUsIHByb2plY3ROYW1lcywgcHJvamVjdElkcywgcmVmZXJlbmNlRXhhbXBsZUlkcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBlcnJvciwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIHRyZWVGaWx0ZXIsIGlzUm9vdCwgZGF0YVNvdXJjZVR5cGUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZHNfID0gcHJvamVjdElkcyB8fCBbXTtcbiAgICAgICAgaWYgKHByb2plY3ROYW1lcykge1xuICAgICAgICAgICAgcHJvamVjdElkc18gPSBbXG4gICAgICAgICAgICAgICAgLi4uKHByb2plY3RJZHMgfHwgW10pLFxuICAgICAgICAgICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChwcm9qZWN0TmFtZXMubWFwKChuYW1lKSA9PiB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IG5hbWUgfSkudGhlbigocHJvamVjdCkgPT4gcHJvamVjdC5pZCkpKSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRyYWNlLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzXyxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlOiByZWZlcmVuY2VFeGFtcGxlSWRzLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgdHJhY2VfZmlsdGVyOiB0cmFjZUZpbHRlcixcbiAgICAgICAgICAgIHRyZWVfZmlsdGVyOiB0cmVlRmlsdGVyLFxuICAgICAgICAgICAgaXNfcm9vdDogaXNSb290LFxuICAgICAgICAgICAgZGF0YV9zb3VyY2VfdHlwZTogZGF0YVNvdXJjZVR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbW92ZSB1bmRlZmluZWQgdmFsdWVzIGZyb20gdGhlIHBheWxvYWRcbiAgICAgICAgY29uc3QgZmlsdGVyZWRQYXlsb2FkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHBheWxvYWQpLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9ydW5zL3N0YXRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZpbHRlcmVkUGF5bG9hZCksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBzaGFyZVJ1bihydW5JZCwgeyBzaGFyZUlkIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIHNoYXJlX3Rva2VuOiBzaGFyZUlkIHx8IHV1aWQudjQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgIShcInNoYXJlX3Rva2VuXCIgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIHNlcnZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3Jlc3VsdFtcInNoYXJlX3Rva2VuXCJdfS9yYDtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGFyZVJ1bihydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIHJ1blwiLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8ICEoXCJzaGFyZV90b2tlblwiIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtyZXN1bHRbXCJzaGFyZV90b2tlblwiXX0vcmA7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RTaGFyZWRSdW5zKHNoYXJlVG9rZW4sIHsgcnVuSWRzLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIHNoYXJlX3Rva2VuOiBzaGFyZVRva2VuLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJ1bklkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bklkIG9mIHJ1bklkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImlkXCIsIHJ1bklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHNoYXJlVG9rZW4pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9ydW5zJHtxdWVyeVBhcmFtc31gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcnVucyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJ1bnM7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0U2hhcmVkU2NoZW1hKGRhdGFzZXRJZCwgZGF0YXNldE5hbWUpIHtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgZGF0YXNldElkIG9yIGRhdGFzZXROYW1lIG11c3QgYmUgZ2l2ZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlRGF0YXNldChkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHVuc2hhcmVEYXRhc2V0KGRhdGFzZXRJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIGRhdGFzZXRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRTaGFyZWREYXRhc2V0KHNoYXJlVG9rZW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vZGF0YXNldHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzaGFyZWQgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhcmVUb2tlbiBUaGUgc2hhcmUgdG9rZW4gdG8gZ2V0IGV4YW1wbGVzIGZvci4gQSBzaGFyZSB0b2tlbiBpcyB0aGUgVVVJRCAob3IgTGFuZ1NtaXRoIFVSTCwgaW5jbHVkaW5nIFVVSUQpIGdlbmVyYXRlZCB3aGVuIGV4cGxpY2l0bHkgbWFya2luZyBhbiBleGFtcGxlIGFzIHB1YmxpYy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbGlzdGluZyB0aGUgZXhhbXBsZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXSB8IHVuZGVmaW5lZH0gW29wdGlvbnMuZXhhbXBsZUlkc10gQSBsaXN0IG9mIGV4YW1wbGUgSURzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFeGFtcGxlW10+fSBUaGUgc2hhcmVkIGV4YW1wbGVzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RTaGFyZWRFeGFtcGxlcyhzaGFyZVRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucz8uZXhhbXBsZUlkcykge1xuICAgICAgICAgICAgcGFyYW1zLmlkID0gb3B0aW9ucy5leGFtcGxlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHVybFBhcmFtcy5hcHBlbmQoa2V5LCB2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vZXhhbXBsZXM/JHt1cmxQYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBpZiAoXCJkZXRhaWxcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaXN0IHNoYXJlZCBleGFtcGxlcy5cXG5TdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfVxcbk1lc3NhZ2U6ICR7QXJyYXkuaXNBcnJheShyZXN1bHQuZGV0YWlsKVxuICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC5kZXRhaWwuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgICAgICAgICA6IFwiVW5zcGVjaWZpZWQgZXJyb3JcIn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3Qgc2hhcmVkIGV4YW1wbGVzOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQubWFwKChleGFtcGxlKSA9PiAoe1xuICAgICAgICAgICAgLi4uZXhhbXBsZSxcbiAgICAgICAgICAgIF9ob3N0VXJsOiB0aGlzLmdldEhvc3RVcmwoKSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVQcm9qZWN0KHsgcHJvamVjdE5hbWUsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCB1cHNlcnQgPSBmYWxzZSwgcHJvamVjdEV4dHJhID0gbnVsbCwgcmVmZXJlbmNlRGF0YXNldElkID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCB1cHNlcnRfID0gdXBzZXJ0ID8gYD91cHNlcnQ9dHJ1ZWAgOiBcIlwiO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucyR7dXBzZXJ0X31gO1xuICAgICAgICBjb25zdCBleHRyYSA9IHByb2plY3RFeHRyYSB8fCB7fTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBleHRyYVtcIm1ldGFkYXRhXCJdID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYm9keVtcInJlZmVyZW5jZV9kYXRhc2V0X2lkXCJdID0gcmVmZXJlbmNlRGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBwcm9qZWN0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVByb2plY3QocHJvamVjdElkLCB7IG5hbWUgPSBudWxsLCBkZXNjcmlwdGlvbiA9IG51bGwsIG1ldGFkYXRhID0gbnVsbCwgcHJvamVjdEV4dHJhID0gbnVsbCwgZW5kVGltZSA9IG51bGwsIH0pIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWR9YDtcbiAgICAgICAgbGV0IGV4dHJhID0gcHJvamVjdEV4dHJhO1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhID0geyAuLi4oZXh0cmEgfHwge30pLCBtZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGVuZF90aW1lOiBlbmRUaW1lID8gbmV3IERhdGUoZW5kVGltZSkudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgcHJvamVjdFwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBoYXNQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICAvLyBUT0RPOiBBZGQgYSBoZWFkIHJlcXVlc3RcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gaHR0cHM6Ly91bmRpY2kubm9kZWpzLm9yZy8jLz9pZD1nYXJiYWdlLWNvbGxlY3Rpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBpdCdzIE9LIGFuZCB3ZSdyZSBxdWVyeWluZyBieSBuYW1lLCBuZWVkIHRvIGNoZWNrIHRoZSBsaXN0IGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb2plY3RJZCBxdWVyeWluZ1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIGluY2x1ZGVTdGF0cywgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL3Nlc3Npb25zXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7cHJvamVjdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgcHJvamVjdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZVN0YXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpbmNsdWRlX3N0YXRzXCIsIGluY2x1ZGVTdGF0cy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2plY3RbaWQ9JHtwcm9qZWN0SWR9LCBuYW1lPSR7cHJvamVjdE5hbWV9XSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvamVjdFVybCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgaWYgKHByb2plY3RJZCA9PT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2plY3QgPSBhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSB9KTtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Byb2plY3QuaWR9YDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGF0YXNldFVybCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vZGF0YXNldHMvJHtkYXRhc2V0LmlkfWA7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRUZW5hbnRJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbmFudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IFwiMVwiIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudElkID0gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9qZWN0cyBmb3VuZCB0byByZXNvbHZlIHRlbmFudC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0UHJvamVjdHMoeyBwcm9qZWN0SWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIHJlZmVyZW5jZURhdGFzZXRJZCwgcmVmZXJlbmNlRGF0YXNldE5hbWUsIHJlZmVyZW5jZUZyZWUsIG1ldGFkYXRhLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocHJvamVjdElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2plY3RJZCBvZiBwcm9qZWN0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIHByb2plY3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBuYW1lQ29udGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VEYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9kYXRhc2V0XCIsIHJlZmVyZW5jZURhdGFzZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVmZXJlbmNlRGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoe1xuICAgICAgICAgICAgICAgIGRhdGFzZXROYW1lOiByZWZlcmVuY2VEYXRhc2V0TmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9kYXRhc2V0XCIsIGRhdGFzZXQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VGcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZnJlZVwiLCByZWZlcmVuY2VGcmVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogcHJvamVjdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZF87XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IHByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZF8pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZF99YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgZGVsZXRlIHNlc3Npb24gJHtwcm9qZWN0SWRffSAoJHtwcm9qZWN0TmFtZX0pYCwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZENzdih7IGNzdkZpbGUsIGZpbGVOYW1lLCBpbnB1dEtleXMsIG91dHB1dEtleXMsIGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgbmFtZSwgfSkge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvdXBsb2FkYDtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBjc3ZGaWxlLCBmaWxlTmFtZSk7XG4gICAgICAgIGlucHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImlucHV0X2tleXNcIiwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJvdXRwdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkYXRhX3R5cGVcIiwgZGF0YVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBsb2FkIENTVlwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVEYXRhc2V0KG5hbWUsIHsgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBpbnB1dHNTY2hlbWEsIG91dHB1dHNTY2hlbWEsIG1ldGFkYXRhLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBib2R5LmRhdGFfdHlwZSA9IGRhdGFUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dHNTY2hlbWEpIHtcbiAgICAgICAgICAgIGJvZHkuaW5wdXRzX3NjaGVtYV9kZWZpbml0aW9uID0gaW5wdXRzU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXRzU2NoZW1hKSB7XG4gICAgICAgICAgICBib2R5Lm91dHB1dHNfc2NoZW1hX2RlZmluaXRpb24gPSBvdXRwdXRzU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGRhdGFzZXRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgLy8gbGltaXQgdG8gMSByZXN1bHRcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGxpbWl0OiBcIjFcIiB9KTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAmJiBkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0W2lkPSR7ZGF0YXNldElkfSwgbmFtZT0ke2RhdGFzZXROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGhhc0RhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmNsdWRlcyhcIm5vdCBmb3VuZFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGlmZkRhdGFzZXRWZXJzaW9ucyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGZyb21WZXJzaW9uLCB0b1ZlcnNpb24sIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGZyb21fdmVyc2lvbjogdHlwZW9mIGZyb21WZXJzaW9uID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBmcm9tVmVyc2lvblxuICAgICAgICAgICAgICAgIDogZnJvbVZlcnNpb24udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHRvX3ZlcnNpb246IHR5cGVvZiB0b1ZlcnNpb24gPT09IFwic3RyaW5nXCIgPyB0b1ZlcnNpb24gOiB0b1ZlcnNpb24udG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KGAvZGF0YXNldHMvJHtkYXRhc2V0SWRffS92ZXJzaW9ucy9kaWZmYCwgdXJsUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YXNldE9wZW5haUZpbmV0dW5pbmcoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSAoYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UoYCR7cGF0aH0vJHtkYXRhc2V0SWR9L29wZW5haV9mdGApO1xuICAgICAgICBjb25zdCBkYXRhc2V0VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRUZXh0XG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgIC5tYXAoKGxpbmUpID0+IEpTT04ucGFyc2UobGluZSkpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3REYXRhc2V0cyh7IGxpbWl0ID0gMTAwLCBvZmZzZXQgPSAwLCBkYXRhc2V0SWRzLCBkYXRhc2V0TmFtZSwgZGF0YXNldE5hbWVDb250YWlucywgbWV0YWRhdGEsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YXNldElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBkYXRhc2V0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBkYXRhc2V0TmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm1ldGFkYXRhXCIsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBkYXRhc2V0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQocGF0aCwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGRhdGFzZXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGRhdGFzZXRcbiAgICAgKiBAcGFyYW0gcHJvcHMgVGhlIGRhdGFzZXQgZGV0YWlscyB0byB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBkYXRhc2V0XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRGF0YXNldChwcm9wcykge1xuICAgICAgICBjb25zdCB7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIC4uLnVwZGF0ZSB9ID0gcHJvcHM7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2RhdGFzZXRJZCA9IGRhdGFzZXRJZCA/PyAoYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pKS5pZDtcbiAgICAgICAgYXNzZXJ0VXVpZChfZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtfZGF0YXNldElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBkYXRhc2V0XCIpO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSB0YWcgb24gYSBkYXRhc2V0LlxuICAgICAqXG4gICAgICogSWYgdGhlIHRhZyBpcyBhbHJlYWR5IGFzc2lnbmVkIHRvIGEgZGlmZmVyZW50IHZlcnNpb24gb2YgdGhpcyBkYXRhc2V0LFxuICAgICAqIHRoZSB0YWcgd2lsbCBiZSBtb3ZlZCB0byB0aGUgbmV3IHZlcnNpb24uIFRoZSBhc19vZiBwYXJhbWV0ZXIgaXMgdXNlZCB0b1xuICAgICAqIGRldGVybWluZSB3aGljaCB2ZXJzaW9uIG9mIHRoZSBkYXRhc2V0IHRvIGFwcGx5IHRoZSBuZXcgdGFncyB0by5cbiAgICAgKlxuICAgICAqIEl0IG11c3QgYmUgYW4gZXhhY3QgdmVyc2lvbiBvZiB0aGUgZGF0YXNldCB0byBzdWNjZWVkLiBZb3UgY2FuXG4gICAgICogdXNlIHRoZSBcInJlYWREYXRhc2V0VmVyc2lvblwiIG1ldGhvZCB0byBmaW5kIHRoZSBleGFjdCB2ZXJzaW9uXG4gICAgICogdG8gYXBwbHkgdGhlIHRhZ3MgdG8uXG4gICAgICogQHBhcmFtIHBhcmFtcy5kYXRhc2V0SWQgVGhlIElEIG9mIHRoZSBkYXRhc2V0IHRvIHVwZGF0ZS4gTXVzdCBiZSBwcm92aWRlZCBpZiBcImRhdGFzZXROYW1lXCIgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBwYXJhbXMuZGF0YXNldE5hbWUgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gdXBkYXRlLiBNdXN0IGJlIHByb3ZpZGVkIGlmIFwiZGF0YXNldElkXCIgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBwYXJhbXMuYXNPZiBUaGUgdGltZXN0YW1wIG9mIHRoZSBkYXRhc2V0IHRvIGFwcGx5IHRoZSBuZXcgdGFncyB0by5cbiAgICAgKiBAcGFyYW0gcGFyYW1zLnRhZyBUaGUgbmV3IHRhZyB0byBhcHBseSB0byB0aGUgZGF0YXNldC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVEYXRhc2V0VGFnKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgYXNPZiwgdGFnIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfZGF0YXNldElkID0gZGF0YXNldElkID8/IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICBhc3NlcnRVdWlkKF9kYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke19kYXRhc2V0SWR9L3RhZ3NgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBhc19vZjogdHlwZW9mIGFzT2YgPT09IFwic3RyaW5nXCIgPyBhc09mIDogYXNPZi50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBkYXRhc2V0IHRhZ3NcIik7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZURhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkXyk7XG4gICAgICAgICAgICBwYXRoICs9IGAvJHtkYXRhc2V0SWRffWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgdGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgJHtwYXRofWApO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGluZGV4RGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIHRhZywgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWRfICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAmJiBkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkYXRhc2V0SWRfKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L2luZGV4YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiaW5kZXggZGF0YXNldFwiKTtcbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXRzIHlvdSBydW4gYSBzaW1pbGFyaXR5IHNlYXJjaCBxdWVyeSBvbiBhIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBSZXF1aXJlcyB0aGUgZGF0YXNldCB0byBiZSBpbmRleGVkLiBQbGVhc2Ugc2VlIHRoZSBgaW5kZXhEYXRhc2V0YCBtZXRob2QgdG8gc2V0IHVwIGluZGV4aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0cyAgICAgIFRoZSBpbnB1dCBvbiB3aGljaCB0byBydW4gdGhlIHNpbWlsYXJpdHkgc2VhcmNoLiBNdXN0IGhhdmUgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgIHNhbWUgc2NoZW1hIGFzIHRoZSBkYXRhc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFzZXRJZCAgIFRoZSBkYXRhc2V0IHRvIHNlYXJjaCBmb3Igc2ltaWxhciBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaW1pdCAgICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgZXhhbXBsZXMgdG8gcmV0dXJuLiBXaWxsIHJldHVybiB0aGUgdG9wIGBsaW1pdGAgbW9zdFxuICAgICAqICAgICAgICAgICAgICAgICAgICBzaW1pbGFyIGV4YW1wbGVzIGluIG9yZGVyIG9mIG1vc3Qgc2ltaWxhciB0byBsZWFzdCBzaW1pbGFyLiBJZiBubyBzaW1pbGFyXG4gICAgICogICAgICAgICAgICAgICAgICAgIGV4YW1wbGVzIGFyZSBmb3VuZCwgcmFuZG9tIGV4YW1wbGVzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyICAgICAgQSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBzZWFyY2guIE9ubHkgZXhhbXBsZXMgd2lsbCBiZSByZXR1cm5lZCB0aGF0XG4gICAgICogICAgICAgICAgICAgICAgICAgIG1hdGNoIHRoZSBmaWx0ZXIgc3RyaW5nLiBTb21lIGV4YW1wbGVzIG9mIGZpbHRlcnNcbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIGVxKG1ldGFkYXRhLm15a2V5LCBcInZhbHVlXCIpXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gYW5kKG5lcShtZXRhZGF0YS5teS5uZXN0ZWQua2V5LCBcInZhbHVlXCIpLCBuZXEobWV0YWRhdGEubXlrZXksIFwidmFsdWVcIikpXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gb3IoZXEobWV0YWRhdGEubXlrZXksIFwidmFsdWVcIiksIGVxKG1ldGFkYXRhLm15a2V5LCBcIm90aGVydmFsdWVcIikpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAgICAgICAgICAgQSBsaXN0IG9mIHNpbWlsYXIgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGF0YXNldF9pZCA9IFwiMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwXCJcbiAgICAgKiBpbnB1dHMgPSB7XCJ0ZXh0XCI6IFwiSG93IG1hbnkgcGVvcGxlIGxpdmUgaW4gQmVybGluP1wifVxuICAgICAqIGxpbWl0ID0gNVxuICAgICAqIGV4YW1wbGVzID0gYXdhaXQgY2xpZW50LnNpbWlsYXJFeGFtcGxlcyhpbnB1dHMsIGRhdGFzZXRfaWQsIGxpbWl0KVxuICAgICAqL1xuICAgIGFzeW5jIHNpbWlsYXJFeGFtcGxlcyhpbnB1dHMsIGRhdGFzZXRJZCwgbGltaXQsIHsgZmlsdGVyLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgIGlucHV0czogaW5wdXRzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFbXCJmaWx0ZXJcIl0gPSBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2VhcmNoYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZmV0Y2ggc2ltaWxhciBleGFtcGxlc1wiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0W1wiZXhhbXBsZXNcIl07XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4YW1wbGUoaW5wdXRzT3JVcGRhdGUsIG91dHB1dHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzRXhhbXBsZUNyZWF0ZShpbnB1dHNPclVwZGF0ZSkpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXRzICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHByb3ZpZGUgb3V0cHV0cyBvciBvcHRpb25zIHdoZW4gdXNpbmcgRXhhbXBsZUNyZWF0ZSBvYmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBvdXRwdXRzID8gb3B0aW9ucz8uZGF0YXNldElkIDogaW5wdXRzT3JVcGRhdGUuZGF0YXNldF9pZDtcbiAgICAgICAgY29uc3QgZGF0YXNldE5hbWVfID0gb3V0cHV0c1xuICAgICAgICAgICAgPyBvcHRpb25zPy5kYXRhc2V0TmFtZVxuICAgICAgICAgICAgOiBpbnB1dHNPclVwZGF0ZS5kYXRhc2V0X25hbWU7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZTogZGF0YXNldE5hbWVfIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZEF0XyA9IChvdXRwdXRzID8gb3B0aW9ucz8uY3JlYXRlZEF0IDogaW5wdXRzT3JVcGRhdGUuY3JlYXRlZF9hdCkgfHwgbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmICghaXNFeGFtcGxlQ3JlYXRlKGlucHV0c09yVXBkYXRlKSkge1xuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGlucHV0c09yVXBkYXRlLFxuICAgICAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogY3JlYXRlZEF0Xz8udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpZDogb3B0aW9ucz8uZXhhbXBsZUlkLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzcGxpdDogb3B0aW9ucz8uc3BsaXQsXG4gICAgICAgICAgICAgICAgc291cmNlX3J1bl9pZDogb3B0aW9ucz8uc291cmNlUnVuSWQsXG4gICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5faW86IG9wdGlvbnM/LnVzZVNvdXJjZVJ1bklPLFxuICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzOiBvcHRpb25zPy51c2VTb3VyY2VSdW5BdHRhY2htZW50cyxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogb3B0aW9ucz8uYXR0YWNobWVudHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IGlucHV0c09yVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkXywgW2RhdGFdKTtcbiAgICAgICAgY29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUocmVzcG9uc2UuZXhhbXBsZV9pZHM/LlswXSA/PyB1dWlkLnY0KCkpO1xuICAgICAgICByZXR1cm4gZXhhbXBsZTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRXhhbXBsZXMocHJvcHNPclVwbG9hZHMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHNPclVwbG9hZHMpKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNPclVwbG9hZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXBsb2FkcyA9IHByb3BzT3JVcGxvYWRzO1xuICAgICAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSB1cGxvYWRzWzBdLmRhdGFzZXRfaWQ7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0TmFtZV8gPSB1cGxvYWRzWzBdLmRhdGFzZXRfbmFtZTtcbiAgICAgICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWU6IGRhdGFzZXROYW1lXyB9KTtcbiAgICAgICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkXywgdXBsb2Fkcyk7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlc3BvbnNlLmV4YW1wbGVfaWRzLm1hcCgoaWQpID0+IHRoaXMucmVhZEV4YW1wbGUoaWQpKSk7XG4gICAgICAgICAgICByZXR1cm4gZXhhbXBsZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnB1dHMsIG91dHB1dHMsIG1ldGFkYXRhLCBzcGxpdHMsIHNvdXJjZVJ1bklkcywgdXNlU291cmNlUnVuSU9zLCB1c2VTb3VyY2VSdW5BdHRhY2htZW50cywgYXR0YWNobWVudHMsIGV4YW1wbGVJZHMsIGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0gPSBwcm9wc09yVXBsb2FkcztcbiAgICAgICAgaWYgKGlucHV0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgaW5wdXRzIHdoZW4gdXNpbmcgbGVnYWN5IHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGNvbnN0IGRhdGFzZXROYW1lXyA9IGRhdGFzZXROYW1lO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWU6IGRhdGFzZXROYW1lXyB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZEV4YW1wbGVzID0gaW5wdXRzLm1hcCgoaW5wdXQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0X2lkOiBkYXRhc2V0SWRfLFxuICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogb3V0cHV0cz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhPy5baWR4XSxcbiAgICAgICAgICAgICAgICBzcGxpdDogc3BsaXRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICBpZDogZXhhbXBsZUlkcz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICBzb3VyY2VfcnVuX2lkOiBzb3VyY2VSdW5JZHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2lvOiB1c2VTb3VyY2VSdW5JT3M/LltpZHhdLFxuICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzOiB1c2VTb3VyY2VSdW5BdHRhY2htZW50cz8uW2lkeF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWRfLCBmb3JtYXR0ZWRFeGFtcGxlcyk7XG4gICAgICAgIGNvbnN0IGV4YW1wbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzcG9uc2UuZXhhbXBsZV9pZHMubWFwKChpZCkgPT4gdGhpcy5yZWFkRXhhbXBsZShpZCkpKTtcbiAgICAgICAgcmV0dXJuIGV4YW1wbGVzO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVMTE1FeGFtcGxlKGlucHV0LCBnZW5lcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUV4YW1wbGUoeyBpbnB1dCB9LCB7IG91dHB1dDogZ2VuZXJhdGlvbiB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ2hhdEV4YW1wbGUoaW5wdXQsIGdlbmVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsSW5wdXQgPSBpbnB1dC5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0xhbmdDaGFpbk1lc3NhZ2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpbmFsT3V0cHV0ID0gaXNMYW5nQ2hhaW5NZXNzYWdlKGdlbmVyYXRpb25zKVxuICAgICAgICAgICAgPyBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShnZW5lcmF0aW9ucylcbiAgICAgICAgICAgIDogZ2VuZXJhdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUV4YW1wbGUoeyBpbnB1dDogZmluYWxJbnB1dCB9LCB7IG91dHB1dDogZmluYWxPdXRwdXQgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRFeGFtcGxlKGV4YW1wbGVJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWA7XG4gICAgICAgIGNvbnN0IHJhd0V4YW1wbGUgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCk7XG4gICAgICAgIGNvbnN0IHsgYXR0YWNobWVudF91cmxzLCAuLi5yZXN0IH0gPSByYXdFeGFtcGxlO1xuICAgICAgICBjb25zdCBleGFtcGxlID0gcmVzdDtcbiAgICAgICAgaWYgKGF0dGFjaG1lbnRfdXJscykge1xuICAgICAgICAgICAgZXhhbXBsZS5hdHRhY2htZW50cyA9IE9iamVjdC5lbnRyaWVzKGF0dGFjaG1lbnRfdXJscykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1trZXkuc2xpY2UoXCJhdHRhY2htZW50LlwiLmxlbmd0aCldID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmVzaWduZWRfdXJsOiB2YWx1ZS5wcmVzaWduZWRfdXJsLFxuICAgICAgICAgICAgICAgICAgICBtaW1lX3R5cGU6IHZhbHVlLm1pbWVfdHlwZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4YW1wbGU7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RXhhbXBsZXMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBleGFtcGxlSWRzLCBhc09mLCBzcGxpdHMsIGlubGluZVMzVXJscywgbWV0YWRhdGEsIGxpbWl0LCBvZmZzZXQsIGZpbHRlciwgaW5jbHVkZUF0dGFjaG1lbnRzLCB9ID0ge30pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGEgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBkYXRhc2V0OiBkYXRhc2V0SWRfIH0pO1xuICAgICAgICBjb25zdCBkYXRhc2V0X3ZlcnNpb24gPSBhc09mXG4gICAgICAgICAgICA/IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBhc09mXG4gICAgICAgICAgICAgICAgOiBhc09mPy50b0lTT1N0cmluZygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRhdGFzZXRfdmVyc2lvbikge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIGRhdGFzZXRfdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5saW5lUzNVcmxzXyA9IGlubGluZVMzVXJscyA/PyB0cnVlO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5saW5lX3MzX3VybHNcIiwgaW5saW5lUzNVcmxzXy50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGV4YW1wbGVJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZF8gb2YgZXhhbXBsZUlkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBpZF8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzcGxpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcGxpdCBvZiBzcGxpdHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwic3BsaXRzXCIsIHNwbGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE1ldGFkYXRhID0gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpO1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm1ldGFkYXRhXCIsIHNlcmlhbGl6ZWRNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJsaW1pdFwiLCBsaW1pdC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJvZmZzZXRcIiwgb2Zmc2V0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImZpbHRlclwiLCBmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlQXR0YWNobWVudHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIFtcImF0dGFjaG1lbnRfdXJsc1wiLCBcIm91dHB1dHNcIiwgXCJtZXRhZGF0YVwiXS5mb3JFYWNoKChmaWVsZCkgPT4gcGFyYW1zLmFwcGVuZChcInNlbGVjdFwiLCBmaWVsZCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCByYXdFeGFtcGxlcyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvZXhhbXBsZXNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByYXdFeGFtcGxlIG9mIHJhd0V4YW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhdHRhY2htZW50X3VybHMsIC4uLnJlc3QgfSA9IHJhd0V4YW1wbGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IHJlc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnRfdXJscykge1xuICAgICAgICAgICAgICAgICAgICBleGFtcGxlLmF0dGFjaG1lbnRzID0gT2JqZWN0LmVudHJpZXMoYXR0YWNobWVudF91cmxzKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nba2V5LnNsaWNlKFwiYXR0YWNobWVudC5cIi5sZW5ndGgpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzaWduZWRfdXJsOiB2YWx1ZS5wcmVzaWduZWRfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVfdHlwZTogdmFsdWUubWltZV90eXBlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIGV4YW1wbGU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgaSA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUV4YW1wbGUoZXhhbXBsZUlkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZXhhbXBsZXMvJHtleGFtcGxlSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYGRlbGV0ZSAke3BhdGh9YCk7XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZShleGFtcGxlSWRPclVwZGF0ZSwgdXBkYXRlKSB7XG4gICAgICAgIGxldCBleGFtcGxlSWQ7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIGV4YW1wbGVJZCA9IGV4YW1wbGVJZE9yVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhhbXBsZUlkID0gZXhhbXBsZUlkT3JVcGRhdGUuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBsZXQgdXBkYXRlVG9Vc2U7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZVRvVXNlID0geyBpZDogZXhhbXBsZUlkLCAuLi51cGRhdGUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVRvVXNlID0gZXhhbXBsZUlkT3JVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKHVwZGF0ZVRvVXNlLmRhdGFzZXRfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkID0gdXBkYXRlVG9Vc2UuZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUgPSBhd2FpdCB0aGlzLnJlYWRFeGFtcGxlKGV4YW1wbGVJZCk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBleGFtcGxlLmRhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgW3VwZGF0ZVRvVXNlXSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGVzKHVwZGF0ZSkge1xuICAgICAgICAvLyBXZSB3aWxsIG5haXZlbHkgZ2V0IGRhdGFzZXQgaWQgZnJvbSBmaXJzdCBleGFtcGxlIGFuZCBhc3N1bWUgaXQgd29ya3MgZm9yIGFsbFxuICAgICAgICBsZXQgZGF0YXNldElkO1xuICAgICAgICBpZiAodXBkYXRlWzBdLmRhdGFzZXRfaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUodXBkYXRlWzBdLmlkKTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGV4YW1wbGUuZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IHVwZGF0ZVswXS5kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkYXRhc2V0IHZlcnNpb24gYnkgY2xvc2VzdCBkYXRlIG9yIGV4YWN0IHRhZy5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHRvIHJlc29sdmUgdGhlIG5lYXJlc3QgdmVyc2lvbiB0byBhIGdpdmVuIHRpbWVzdGFtcCBvciBmb3IgYSBnaXZlbiB0YWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgZ2V0dGluZyB0aGUgZGF0YXNldCB2ZXJzaW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGF0YXNldElkIFRoZSBJRCBvZiB0aGUgZGF0YXNldFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGFzZXROYW1lIFRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXNPZiBUaGUgdGltZXN0YW1wIG9mIHRoZSBkYXRhc2V0IHRvIHJldHJpZXZlXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGFnIFRoZSB0YWcgb2YgdGhlIGRhdGFzZXQgdG8gcmV0cmlldmVcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YXNldCB2ZXJzaW9uXG4gICAgICovXG4gICAgYXN5bmMgcmVhZERhdGFzZXRWZXJzaW9uKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgYXNPZiwgdGFnLCB9KSB7XG4gICAgICAgIGxldCByZXNvbHZlZERhdGFzZXRJZDtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICByZXNvbHZlZERhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlZERhdGFzZXRJZCA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHJlc29sdmVkRGF0YXNldElkKTtcbiAgICAgICAgaWYgKChhc09mICYmIHRhZykgfHwgKCFhc09mICYmICF0YWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGFjdGx5IG9uZSBvZiBhc09mIGFuZCB0YWcgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKGFzT2YgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiID8gYXNPZiA6IGFzT2YudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwidGFnXCIsIHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtyZXNvbHZlZERhdGFzZXRJZH0vdmVyc2lvbj8ke3BhcmFtcy50b1N0cmluZygpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwicmVhZCBkYXRhc2V0IHZlcnNpb25cIik7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3REYXRhc2V0U3BsaXRzKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgYXNPZiwgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0IG5hbWUgb3IgSURcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkXyk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgY29uc3QgZGF0YXNldF92ZXJzaW9uID0gYXNPZlxuICAgICAgICAgICAgPyB0eXBlb2YgYXNPZiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gYXNPZlxuICAgICAgICAgICAgICAgIDogYXNPZj8udG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChkYXRhc2V0X3ZlcnNpb24pIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJhc19vZlwiLCBkYXRhc2V0X3ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KGAvZGF0YXNldHMvJHtkYXRhc2V0SWRffS9zcGxpdHNgLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZURhdGFzZXRTcGxpdHMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBzcGxpdE5hbWUsIGV4YW1wbGVJZHMsIHJlbW92ZSA9IGZhbHNlLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfO1xuICAgICAgICBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXQgbmFtZSBvciBJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHNwbGl0X25hbWU6IHNwbGl0TmFtZSxcbiAgICAgICAgICAgIGV4YW1wbGVzOiBleGFtcGxlSWRzLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRVdWlkKGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJlbW92ZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWRffS9zcGxpdHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBkYXRhc2V0IHNwbGl0c1wiLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSBMYW5nU21pdGggdmVyc2lvbnMsIHVzZSBgZXZhbHVhdGVgIGZyb20gYGxhbmdzbWl0aC9ldmFsdWF0aW9uYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGV2YWx1YXRlUnVuKHJ1biwgZXZhbHVhdG9yLCB7IHNvdXJjZUluZm8sIGxvYWRDaGlsZFJ1bnMsIHJlZmVyZW5jZUV4YW1wbGUsIH0gPSB7IGxvYWRDaGlsZFJ1bnM6IGZhbHNlIH0pIHtcbiAgICAgICAgd2Fybk9uY2UoXCJUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIExhbmdTbWl0aCB2ZXJzaW9ucywgdXNlIGBldmFsdWF0ZWAgZnJvbSBgbGFuZ3NtaXRoL2V2YWx1YXRpb25gIGluc3RlYWQuXCIpO1xuICAgICAgICBsZXQgcnVuXztcbiAgICAgICAgaWYgKHR5cGVvZiBydW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJ1bl8gPSBhd2FpdCB0aGlzLnJlYWRSdW4ocnVuLCB7IGxvYWRDaGlsZFJ1bnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1biA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcnVuKSB7XG4gICAgICAgICAgICBydW5fID0gcnVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJ1biB0eXBlOiAke3R5cGVvZiBydW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUocnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2tSZXN1bHQgPSBhd2FpdCBldmFsdWF0b3IuZXZhbHVhdGVSdW4ocnVuXywgcmVmZXJlbmNlRXhhbXBsZSk7XG4gICAgICAgIGNvbnN0IFtfLCBmZWVkYmFja3NdID0gYXdhaXQgdGhpcy5fbG9nRXZhbHVhdGlvbkZlZWRiYWNrKGZlZWRiYWNrUmVzdWx0LCBydW5fLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgcmV0dXJuIGZlZWRiYWNrc1swXTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRmVlZGJhY2socnVuSWQsIGtleSwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIHNvdXJjZUluZm8sIGZlZWRiYWNrU291cmNlVHlwZSA9IFwiYXBpXCIsIHNvdXJjZVJ1bklkLCBmZWVkYmFja0lkLCBmZWVkYmFja0NvbmZpZywgcHJvamVjdElkLCBjb21wYXJhdGl2ZUV4cGVyaW1lbnRJZCwgfSkge1xuICAgICAgICBpZiAoIXJ1bklkICYmICFwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9uZSBvZiBydW5JZCBvciBwcm9qZWN0SWQgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuSWQgJiYgcHJvamVjdElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBydW5JZCBvciBwcm9qZWN0SWQgY2FuIGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrX3NvdXJjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGZlZWRiYWNrU291cmNlVHlwZSA/PyBcImFwaVwiLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHNvdXJjZUluZm8gPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzb3VyY2VSdW5JZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U/Lm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXSkge1xuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0gPSB7IHJ1bl9pZDogc291cmNlUnVuSWQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXT8ucnVuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0ucnVuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgIGlkOiBmZWVkYmFja0lkID8/IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzY29yZTogX2Zvcm1hdEZlZWRiYWNrU2NvcmUoc2NvcmUpLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjb3JyZWN0aW9uLFxuICAgICAgICAgICAgY29tbWVudCxcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZTogZmVlZGJhY2tfc291cmNlLFxuICAgICAgICAgICAgY29tcGFyYXRpdmVfZXhwZXJpbWVudF9pZDogY29tcGFyYXRpdmVFeHBlcmltZW50SWQsXG4gICAgICAgICAgICBmZWVkYmFja0NvbmZpZyxcbiAgICAgICAgICAgIHNlc3Npb25faWQ6IHByb2plY3RJZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrYDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgZmVlZGJhY2tcIiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBmZWVkYmFjaztcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRmVlZGJhY2soZmVlZGJhY2tJZCwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIH0pIHtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tVcGRhdGUgPSB7fTtcbiAgICAgICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQgJiYgc2NvcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wic2NvcmVcIl0gPSBfZm9ybWF0RmVlZGJhY2tTY29yZShzY29yZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1widmFsdWVcIl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ycmVjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvcnJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29ycmVjdGlvblwiXSA9IGNvcnJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCAmJiBjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvbW1lbnRcIl0gPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZmVlZGJhY2tVcGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBmZWVkYmFja1wiLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEZlZWRiYWNrKGZlZWRiYWNrSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZmVlZGJhY2svJHtmZWVkYmFja0lkfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KHBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUZlZWRiYWNrKGZlZWRiYWNrSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZmVlZGJhY2svJHtmZWVkYmFja0lkfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgdGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgJHtwYXRofWApO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RmVlZGJhY2soeyBydW5JZHMsIGZlZWRiYWNrS2V5cywgZmVlZGJhY2tTb3VyY2VUeXBlcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocnVuSWRzKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJydW5cIiwgcnVuSWRzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzb3VyY2VcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBmZWVkYmFja3Mgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGZlZWRiYWNrcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJlc2lnbmVkIGZlZWRiYWNrIHRva2VuIGFuZCBVUkwuXG4gICAgICpcbiAgICAgKiBUaGUgdG9rZW4gY2FuIGJlIHVzZWQgdG8gYXV0aG9yaXplIGZlZWRiYWNrIG1ldHJpY3Mgd2l0aG91dFxuICAgICAqIG5lZWRpbmcgYW4gQVBJIGtleS4gVGhpcyBpcyB1c2VmdWwgZm9yIGdpdmluZyBicm93c2VyLWJhc2VkXG4gICAgICogYXBwbGljYXRpb25zIHRoZSBhYmlsaXR5IHRvIHN1Ym1pdCBmZWVkYmFjayB3aXRob3V0IG5lZWRpbmdcbiAgICAgKiB0byBleHBvc2UgYW4gQVBJIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcGFyYW0gZmVlZGJhY2tLZXkgVGhlIGZlZWRiYWNrIGtleS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5leHBpcmF0aW9uIFRoZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0b2tlbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgRmVlZGJhY2tJbmdlc3RUb2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQcmVzaWduZWRGZWVkYmFja1Rva2VuKHJ1bklkLCBmZWVkYmFja0tleSwgeyBleHBpcmF0aW9uLCBmZWVkYmFja0NvbmZpZywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgZmVlZGJhY2tfa2V5OiBmZWVkYmFja0tleSxcbiAgICAgICAgICAgIGZlZWRiYWNrX2NvbmZpZzogZmVlZGJhY2tDb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChleHBpcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGlyYXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBib2R5W1wiZXhwaXJlc19hdFwiXSA9IGV4cGlyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHBpcmF0aW9uPy5ob3VycyB8fCBleHBpcmF0aW9uPy5taW51dGVzIHx8IGV4cGlyYXRpb24/LmRheXMpIHtcbiAgICAgICAgICAgICAgICBib2R5W1wiZXhwaXJlc19pblwiXSA9IGV4cGlyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5W1wiZXhwaXJlc19pblwiXSA9IHtcbiAgICAgICAgICAgICAgICBob3VyczogMyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2svdG9rZW5zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDb21wYXJhdGl2ZUV4cGVyaW1lbnQoeyBuYW1lLCBleHBlcmltZW50SWRzLCByZWZlcmVuY2VEYXRhc2V0SWQsIGNyZWF0ZWRBdCwgZGVzY3JpcHRpb24sIG1ldGFkYXRhLCBpZCwgfSkge1xuICAgICAgICBpZiAoZXhwZXJpbWVudElkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBleHBlcmltZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVmZXJlbmNlRGF0YXNldElkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VEYXRhc2V0SWQgPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7XG4gICAgICAgICAgICAgICAgcHJvamVjdElkOiBleHBlcmltZW50SWRzWzBdLFxuICAgICAgICAgICAgfSkpLnJlZmVyZW5jZV9kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVmZXJlbmNlRGF0YXNldElkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcmVmZXJlbmNlIGRhdGFzZXQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRfaWRzOiBleHBlcmltZW50SWRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2RhdGFzZXRfaWQ6IHJlZmVyZW5jZURhdGFzZXRJZCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogKGNyZWF0ZWRBdCA/PyBuZXcgRGF0ZSgpKT8udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGV4dHJhOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKVxuICAgICAgICAgICAgYm9keS5leHRyYVtcIm1ldGFkYXRhXCJdID0gbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzL2NvbXBhcmF0aXZlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBwcmVzaWduZWQgZmVlZGJhY2sgdG9rZW5zIGZvciBhIGdpdmVuIHJ1biBJRC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnMgQW4gYXN5bmMgaXRlcmFibGUgb2YgRmVlZGJhY2tJbmdlc3RUb2tlbiBvYmplY3RzLlxuICAgICAqL1xuICAgIGFzeW5jICpsaXN0UHJlc2lnbmVkRmVlZGJhY2tUb2tlbnMocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBydW5faWQ6IHJ1bklkIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHRva2VucyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvZmVlZGJhY2svdG9rZW5zXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0b2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NlbGVjdEV2YWxSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdHNfO1xuICAgICAgICBpZiAoXCJyZXN1bHRzXCIgaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgcmVzdWx0c18gPSByZXN1bHRzLnJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgICAgcmVzdWx0c18gPSByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0c18gPSBbcmVzdWx0c107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHNfO1xuICAgIH1cbiAgICBhc3luYyBfbG9nRXZhbHVhdGlvbkZlZWRiYWNrKGV2YWx1YXRvclJlc3BvbnNlLCBydW4sIHNvdXJjZUluZm8pIHtcbiAgICAgICAgY29uc3QgZXZhbFJlc3VsdHMgPSB0aGlzLl9zZWxlY3RFdmFsUmVzdWx0cyhldmFsdWF0b3JSZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlcyBvZiBldmFsUmVzdWx0cykge1xuICAgICAgICAgICAgbGV0IHNvdXJjZUluZm9fID0gc291cmNlSW5mbyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChyZXMuZXZhbHVhdG9ySW5mbykge1xuICAgICAgICAgICAgICAgIHNvdXJjZUluZm9fID0geyAuLi5yZXMuZXZhbHVhdG9ySW5mbywgLi4uc291cmNlSW5mb18gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBydW5JZF8gPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcy50YXJnZXRSdW5JZCkge1xuICAgICAgICAgICAgICAgIHJ1bklkXyA9IHJlcy50YXJnZXRSdW5JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bikge1xuICAgICAgICAgICAgICAgIHJ1bklkXyA9IHJ1bi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZlZWRiYWNrcy5wdXNoKGF3YWl0IHRoaXMuY3JlYXRlRmVlZGJhY2socnVuSWRfLCByZXMua2V5LCB7XG4gICAgICAgICAgICAgICAgc2NvcmU6IHJlcy5zY29yZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHJlcy5jb21tZW50LFxuICAgICAgICAgICAgICAgIGNvcnJlY3Rpb246IHJlcy5jb3JyZWN0aW9uLFxuICAgICAgICAgICAgICAgIHNvdXJjZUluZm86IHNvdXJjZUluZm9fLFxuICAgICAgICAgICAgICAgIHNvdXJjZVJ1bklkOiByZXMuc291cmNlUnVuSWQsXG4gICAgICAgICAgICAgICAgZmVlZGJhY2tDb25maWc6IHJlcy5mZWVkYmFja0NvbmZpZyxcbiAgICAgICAgICAgICAgICBmZWVkYmFja1NvdXJjZVR5cGU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2V2YWxSZXN1bHRzLCBmZWVkYmFja3NdO1xuICAgIH1cbiAgICBhc3luYyBsb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbykge1xuICAgICAgICBjb25zdCBbcmVzdWx0c10gPSBhd2FpdCB0aGlzLl9sb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbyk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBUEkgZm9yIG1hbmFnaW5nIGFubm90YXRpb24gcXVldWVzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTGlzdCB0aGUgYW5ub3RhdGlvbiBxdWV1ZXMgb24gdGhlIExhbmdTbWl0aCBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgbGlzdGluZyBhbm5vdGF0aW9uIHF1ZXVlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXVlSWRzIC0gVGhlIElEcyBvZiB0aGUgcXVldWVzIHRvIGZpbHRlciBieVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVldWUgdG8gZmlsdGVyIGJ5XG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZUNvbnRhaW5zIC0gVGhlIHN1YnN0cmluZyB0aGF0IHRoZSBxdWV1ZSBuYW1lIHNob3VsZCBjb250YWluXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcXVldWVzIHRvIHJldHVyblxuICAgICAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIG9mIEFubm90YXRpb25RdWV1ZSBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RBbm5vdGF0aW9uUXVldWVzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHF1ZXVlSWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIGxpbWl0IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChxdWV1ZUlkcykge1xuICAgICAgICAgICAgcXVldWVJZHMuZm9yRWFjaCgoaWQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRVdWlkKGlkLCBgcXVldWVJZHNbJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRzXCIsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlmIChuYW1lQ29udGFpbnMpXG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBuYW1lQ29udGFpbnMpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwibGltaXRcIiwgKGxpbWl0ICE9PSB1bmRlZmluZWQgPyBNYXRoLm1pbihsaW1pdCwgMTAwKSA6IDEwMCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcXVldWVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9hbm5vdGF0aW9uLXF1ZXVlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogcXVldWVzO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIGNvdW50ID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhbm5vdGF0aW9uIHF1ZXVlIG9uIHRoZSBMYW5nU21pdGggQVBJLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGFuIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZXNjcmlwdGlvbiAtIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBBbm5vdGF0aW9uUXVldWUgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQW5ub3RhdGlvblF1ZXVlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkZXNjcmlwdGlvbiwgcXVldWVJZCwgcnVicmljSW5zdHJ1Y3Rpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaWQ6IHF1ZXVlSWQgfHwgdXVpZC52NCgpLFxuICAgICAgICAgICAgcnVicmljX2luc3RydWN0aW9uczogcnVicmljSW5zdHJ1Y3Rpb25zLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhib2R5KS5maWx0ZXIoKFtfLCB2XSkgPT4gdiAhPT0gdW5kZWZpbmVkKSkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZSB0byByZWFkXG4gICAgICogQHJldHVybnMgVGhlIEFubm90YXRpb25RdWV1ZVdpdGhEZXRhaWxzIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRBbm5vdGF0aW9uUXVldWUocXVldWVJZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJyZWFkIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gYW5ub3RhdGlvbiBxdWV1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVldWUgSUQuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWUgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdXBkYXRpbmcgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5ldyBuYW1lIGZvciB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlc2NyaXB0aW9uIC0gVGhlIG5ldyBkZXNjcmlwdGlvbiBmb3IgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVBbm5vdGF0aW9uUXVldWUocXVldWVJZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRlc2NyaXB0aW9uLCBydWJyaWNJbnN0cnVjdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHJ1YnJpY19pbnN0cnVjdGlvbnM6IHJ1YnJpY0luc3RydWN0aW9ucyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gYW5ub3RhdGlvbiBxdWV1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVldWUgSUQuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWUgdG8gZGVsZXRlXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImRlbGV0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcnVucyB0byBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBydW5JZHMgLSBUaGUgSURzIG9mIHRoZSBydW5zIHRvIGJlIGFkZGVkIHRvIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgYWRkUnVuc1RvQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIHJ1bklkcykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfS9ydW5zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocnVuSWRzLm1hcCgoaWQsIGkpID0+IGFzc2VydFV1aWQoaWQsIGBydW5JZHNbJHtpfV1gKS50b1N0cmluZygpKSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiYWRkIHJ1bnMgdG8gYW5ub3RhdGlvbiBxdWV1ZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgcnVuIGZyb20gYW4gYW5ub3RhdGlvbiBxdWV1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBydW4gdG8gcmV0cmlldmVcbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIFJ1bldpdGhBbm5vdGF0aW9uUXVldWVJbmZvIG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcnVuIGlzIG5vdCBmb3VuZCBhdCB0aGUgZ2l2ZW4gaW5kZXggb3IgZm9yIG90aGVyIEFQSS1yZWxhdGVkIGVycm9yc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFJ1bkZyb21Bbm5vdGF0aW9uUXVldWUocXVldWVJZCwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGAvYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vcnVuYDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0ke2Jhc2VVcmx9LyR7aW5kZXh9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImdldCBydW4gZnJvbSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBydW4gZnJvbSBhbiBhbiBhbm5vdGF0aW9uIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIGRlbGV0ZSB0aGUgcnVuIGZyb21cbiAgICAgKiBAcGFyYW0gcXVldWVSdW5JZCAtIFRoZSBJRCBvZiB0aGUgcnVuIHRvIGRlbGV0ZSBmcm9tIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlUnVuRnJvbUFubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBxdWV1ZVJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3J1bnMvJHthc3NlcnRVdWlkKHF1ZXVlUnVuSWQsIFwicXVldWVSdW5JZFwiKX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImRlbGV0ZSBydW4gZnJvbSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNpemUgb2YgYW4gYW5ub3RhdGlvbiBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFNpemVGcm9tQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vc2l6ZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJnZXQgc2l6ZSBmcm9tIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIF9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgIHJldHVybiBvd25lciA9PSBcIi1cIiB8fCBzZXR0aW5ncy50ZW5hbnRfaGFuZGxlID09PSBvd25lcjtcbiAgICB9XG4gICAgYXN5bmMgX293bmVyQ29uZmxpY3RFcnJvcihhY3Rpb24sIG93bmVyKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5fZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgQ2Fubm90ICR7YWN0aW9ufSBmb3IgYW5vdGhlciB0ZW5hbnQuXFxuXG4gICAgICBDdXJyZW50IHRlbmFudDogJHtzZXR0aW5ncy50ZW5hbnRfaGFuZGxlfVxcblxuICAgICAgUmVxdWVzdGVkIHRlbmFudDogJHtvd25lcn1gKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldExhdGVzdENvbW1pdEhhc2gocHJvbXB0T3duZXJBbmROYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9jb21taXRzLyR7cHJvbXB0T3duZXJBbmROYW1lfS8/bGltaXQ9JHsxfSZvZmZzZXQ9JHswfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbCA9IHR5cGVvZiBqc29uLmRldGFpbCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8ganNvbi5kZXRhaWxcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGpzb24uZGV0YWlsKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBFcnJvciAke3Jlcy5zdGF0dXN9OiAke3Jlcy5zdGF0dXNUZXh0fVxcbiR7ZGV0YWlsfWApO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24uY29tbWl0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb24uY29tbWl0c1swXS5jb21taXRfaGFzaDtcbiAgICB9XG4gICAgYXN5bmMgX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBsaWtlKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2xpa2VzLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBsaWtlOiBsaWtlIH0pLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGAke2xpa2UgPyBcImxpa2VcIiA6IFwidW5saWtlXCJ9IHByb21wdGApO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UHJvbXB0VXJsKHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBjb21taXRIYXNoXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgaWYgKGNvbW1pdEhhc2ggIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L2h1Yi8ke293bmVyfS8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaC5zdWJzdHJpbmcoMCwgOCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vaHViLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgaWYgKGNvbW1pdEhhc2ggIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3Byb21wdHMvJHtwcm9tcHROYW1lfS8ke2NvbW1pdEhhc2guc3Vic3RyaW5nKDAsIDgpfT9vcmdhbml6YXRpb25JZD0ke3NldHRpbmdzLmlkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3Byb21wdHMvJHtwcm9tcHROYW1lfT9vcmdhbml6YXRpb25JZD0ke3NldHRpbmdzLmlkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gYXdhaXQgdGhpcy5nZXRQcm9tcHQocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiAhIXByb21wdDtcbiAgICB9XG4gICAgYXN5bmMgbGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saWtlT3JVbmxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saWtlT3JVbmxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgZmFsc2UpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdENvbW1pdHMocHJvbXB0T3duZXJBbmROYW1lKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY29tbWl0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoYC9jb21taXRzLyR7cHJvbXB0T3duZXJBbmROYW1lfS9gLCBuZXcgVVJMU2VhcmNoUGFyYW1zKCksIChyZXMpID0+IHJlcy5jb21taXRzKSkge1xuICAgICAgICAgICAgeWllbGQqIGNvbW1pdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKmxpc3RQcm9tcHRzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwic29ydF9maWVsZFwiLCBvcHRpb25zPy5zb3J0RmllbGQgPz8gXCJ1cGRhdGVkX2F0XCIpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwic29ydF9kaXJlY3Rpb25cIiwgXCJkZXNjXCIpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaXNfYXJjaGl2ZWRcIiwgKCEhb3B0aW9ucz8uaXNBcmNoaXZlZCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaXNfcHVibGljXCIsIG9wdGlvbnMuaXNQdWJsaWMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnM/LnF1ZXJ5KSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicXVlcnlcIiwgb3B0aW9ucy5xdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9tcHRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9yZXBvc1wiLCBwYXJhbXMsIChyZXMpID0+IHJlcy5yZXBvcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBwcm9tcHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3JlcG9zLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJnZXQgcHJvbXB0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQucmVwbykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNQdWJsaWMgJiYgIXNldHRpbmdzLnRlbmFudF9oYW5kbGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNyZWF0ZSBhIHB1YmxpYyBwcm9tcHQgd2l0aG91dCBmaXJzdFxcblxuICAgICAgICBjcmVhdGluZyBhIExhbmdDaGFpbiBIdWIgaGFuZGxlLlxuICAgICAgICBZb3UgY2FuIGFkZCBhIGhhbmRsZSBieSBjcmVhdGluZyBhIHB1YmxpYyBwcm9tcHQgYXQ6XFxuXG4gICAgICAgIGh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbS9wcm9tcHRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwiY3JlYXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcmVwb19oYW5kbGU6IHByb21wdE5hbWUsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8uZGVzY3JpcHRpb24gJiYgeyBkZXNjcmlwdGlvbjogb3B0aW9ucy5kZXNjcmlwdGlvbiB9KSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5yZWFkbWUgJiYgeyByZWFkbWU6IG9wdGlvbnMucmVhZG1lIH0pLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LnRhZ3MgJiYgeyB0YWdzOiBvcHRpb25zLnRhZ3MgfSksXG4gICAgICAgICAgICBpc19wdWJsaWM6ICEhb3B0aW9ucz8uaXNQdWJsaWMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3JlcG9zL2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBwcm9tcHRcIik7XG4gICAgICAgIGNvbnN0IHsgcmVwbyB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVwbztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ29tbWl0KHByb21wdElkZW50aWZpZXIsIG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnByb21wdEV4aXN0cyhwcm9tcHRJZGVudGlmaWVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21wdCBkb2VzIG5vdCBleGlzdCwgeW91IG11c3QgY3JlYXRlIGl0IGZpcnN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCByZXNvbHZlZFBhcmVudENvbW1pdEhhc2ggPSBvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoID09PSBcImxhdGVzdFwiIHx8ICFvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuX2dldExhdGVzdENvbW1pdEhhc2goYCR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gKVxuICAgICAgICAgICAgOiBvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgbWFuaWZlc3Q6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSksXG4gICAgICAgICAgICBwYXJlbnRfY29tbWl0OiByZXNvbHZlZFBhcmVudENvbW1pdEhhc2gsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBjb21taXRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb21wdFVybChgJHtvd25lcn0vJHtwcm9tcHROYW1lfSR7cmVzdWx0LmNvbW1pdF9oYXNoID8gYDoke3Jlc3VsdC5jb21taXRfaGFzaH1gIDogXCJcIn1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGV4YW1wbGVzIHdpdGggYXR0YWNobWVudHMgdXNpbmcgbXVsdGlwYXJ0IGZvcm0gZGF0YS5cbiAgICAgKiBAcGFyYW0gdXBkYXRlcyBMaXN0IG9mIEV4YW1wbGVVcGRhdGVXaXRoQXR0YWNobWVudHMgb2JqZWN0cyB0byB1cHNlcnRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHVwZGF0ZSByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBkYXRlcyA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwZGF0ZXMpO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGRhdGVzID0gW10pIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fZ2V0TXVsdGlQYXJ0U3VwcG9ydCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBMYW5nU21pdGggZGVwbG95bWVudCBkb2VzIG5vdCBhbGxvdyB1c2luZyB0aGUgbXVsdGlwYXJ0IGV4YW1wbGVzIGVuZHBvaW50LCBwbGVhc2UgdXBncmFkZSB5b3VyIGRlcGxveW1lbnQgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGV4YW1wbGUgb2YgdXBkYXRlcykge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUlkID0gZXhhbXBsZS5pZDtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIG1haW4gZXhhbXBsZSBib2R5XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQm9keSA9IHtcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5tZXRhZGF0YSAmJiB7IG1ldGFkYXRhOiBleGFtcGxlLm1ldGFkYXRhIH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnNwbGl0ICYmIHsgc3BsaXQ6IGV4YW1wbGUuc3BsaXQgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQWRkIG1haW4gZXhhbXBsZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEV4YW1wbGUgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlQm9keSwgYFNlcmlhbGl6aW5nIGJvZHkgZm9yIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZEV4YW1wbGVdLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChleGFtcGxlSWQsIGV4YW1wbGVCbG9iKTtcbiAgICAgICAgICAgIC8vIEFkZCBpbnB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRJbnB1dHMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLmlucHV0cywgYFNlcmlhbGl6aW5nIGlucHV0cyBmb3IgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHNCbG9iID0gbmV3IEJsb2IoW3N0cmluZ2lmaWVkSW5wdXRzXSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5pbnB1dHNgLCBpbnB1dHNCbG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBvdXRwdXRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZE91dHB1dHMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLm91dHB1dHMsIGBTZXJpYWxpemluZyBvdXRwdXRzIHdobGUgdXBkYXRpbmcgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZE91dHB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9Lm91dHB1dHNgLCBvdXRwdXRzQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgYXR0YWNobWVudHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBhdHRhY2htZW50XSBvZiBPYmplY3QuZW50cmllcyhleGFtcGxlLmF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgW21pbWVUeXBlLCBkYXRhXSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IGF0dGFjaG1lbnQubWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXR0YWNobWVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRCbG9iID0gbmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgJHttaW1lVHlwZX07IGxlbmd0aD0ke2RhdGEuYnl0ZUxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uYXR0YWNobWVudC4ke25hbWV9YCwgYXR0YWNobWVudEJsb2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleGFtcGxlLmF0dGFjaG1lbnRzX29wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEF0dGFjaG1lbnRzT3BlcmF0aW9ucyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUuYXR0YWNobWVudHNfb3BlcmF0aW9ucywgYFNlcmlhbGl6aW5nIGF0dGFjaG1lbnRzIHdoaWxlIHVwZGF0aW5nIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudHNPcGVyYXRpb25zQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZEF0dGFjaG1lbnRzT3BlcmF0aW9uc10sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uYXR0YWNobWVudHNfb3BlcmF0aW9uc2AsIGF0dGFjaG1lbnRzT3BlcmF0aW9uc0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJZFRvVXNlID0gZGF0YXNldElkID8/IHVwZGF0ZXNbMF0/LmRhdGFzZXRfaWQ7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9JHt0aGlzLl9nZXRQbGF0Zm9ybUVuZHBvaW50UGF0aChgZGF0YXNldHMvJHtkYXRhc2V0SWRUb1VzZX0vZXhhbXBsZXNgKX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgZXhhbXBsZXMgd2l0aCBhdHRhY2htZW50cyB1c2luZyBtdWx0aXBhcnQgZm9ybSBkYXRhLlxuICAgICAqIEBwYXJhbSB1cGxvYWRzIExpc3Qgb2YgRXhhbXBsZVVwbG9hZFdpdGhBdHRhY2htZW50cyBvYmplY3RzIHRvIHVwbG9hZFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0aGUgdXBsb2FkIHJlc3BvbnNlXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSBMYW5nU21pdGggdmVyc2lvbnMsIHBsZWFzZSB1c2UgYGNyZWF0ZUV4YW1wbGVzYCBpbnN0ZWFkXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGxvYWRzID0gW10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBsb2Fkcyk7XG4gICAgfVxuICAgIGFzeW5jIF91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwbG9hZHMgPSBbXSkge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9nZXRNdWx0aVBhcnRTdXBwb3J0KCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIExhbmdTbWl0aCBkZXBsb3ltZW50IGRvZXMgbm90IGFsbG93IHVzaW5nIHRoZSBtdWx0aXBhcnQgZXhhbXBsZXMgZW5kcG9pbnQsIHBsZWFzZSB1cGdyYWRlIHlvdXIgZGVwbG95bWVudCB0byB0aGUgbGF0ZXN0IHZlcnNpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvciAoY29uc3QgZXhhbXBsZSBvZiB1cGxvYWRzKSB7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlSWQgPSAoZXhhbXBsZS5pZCA/PyB1dWlkLnY0KCkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBtYWluIGV4YW1wbGUgYm9keVxuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUJvZHkgPSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogZXhhbXBsZS5jcmVhdGVkX2F0LFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLm1ldGFkYXRhICYmIHsgbWV0YWRhdGE6IGV4YW1wbGUubWV0YWRhdGEgfSksXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUuc3BsaXQgJiYgeyBzcGxpdDogZXhhbXBsZS5zcGxpdCB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5zb3VyY2VfcnVuX2lkICYmIHsgc291cmNlX3J1bl9pZDogZXhhbXBsZS5zb3VyY2VfcnVuX2lkIH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnVzZV9zb3VyY2VfcnVuX2lvICYmIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5faW86IGV4YW1wbGUudXNlX3NvdXJjZV9ydW5faW8sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUudXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHMgJiYge1xuICAgICAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9hdHRhY2htZW50czogZXhhbXBsZS51c2Vfc291cmNlX3J1bl9hdHRhY2htZW50cyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBBZGQgbWFpbiBleGFtcGxlIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkRXhhbXBsZSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGVCb2R5LCBgU2VyaWFsaXppbmcgYm9keSBmb3IgdXBsb2FkZWQgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVCbG9iID0gbmV3IEJsb2IoW3N0cmluZ2lmaWVkRXhhbXBsZV0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGV4YW1wbGVJZCwgZXhhbXBsZUJsb2IpO1xuICAgICAgICAgICAgLy8gQWRkIGlucHV0cyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZElucHV0cyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUuaW5wdXRzLCBgU2VyaWFsaXppbmcgaW5wdXRzIGZvciB1cGxvYWRlZCBleGFtcGxlIHdpdGggaWQ6ICR7ZXhhbXBsZUlkfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRJbnB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmlucHV0c2AsIGlucHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIG91dHB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkT3V0cHV0cyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUub3V0cHV0cywgYFNlcmlhbGl6aW5nIG91dHB1dHMgZm9yIHVwbG9hZGVkIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRPdXRwdXRzXSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5vdXRwdXRzYCwgb3V0cHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGF0dGFjaG1lbnRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgYXR0YWNobWVudF0gb2YgT2JqZWN0LmVudHJpZXMoZXhhbXBsZS5hdHRhY2htZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0YWNobWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFttaW1lVHlwZSwgZGF0YV0gPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUgPSBhdHRhY2htZW50Lm1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF0dGFjaG1lbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50QmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7bWltZVR5cGV9OyBsZW5ndGg9JHtkYXRhLmJ5dGVMZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmF0dGFjaG1lbnQuJHtuYW1lfWAsIGF0dGFjaG1lbnRCbG9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0ke3RoaXMuX2dldFBsYXRmb3JtRW5kcG9pbnRQYXRoKGBkYXRhc2V0cy8ke2RhdGFzZXRJZH0vZXhhbXBsZXNgKX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGxvYWQgZXhhbXBsZXNcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgZG9lcyBub3QgZXhpc3QsIHlvdSBtdXN0IGNyZWF0ZSBpdCBmaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwidXBkYXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmIChvcHRpb25zPy5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChvcHRpb25zPy5yZWFkbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQucmVhZG1lID0gb3B0aW9ucy5yZWFkbWU7XG4gICAgICAgIGlmIChvcHRpb25zPy50YWdzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLnRhZ3MgPSBvcHRpb25zLnRhZ3M7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5pc19wdWJsaWMgPSBvcHRpb25zLmlzUHVibGljO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNBcmNoaXZlZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5pc19hcmNoaXZlZCA9IG9wdGlvbnMuaXNBcmNoaXZlZDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcGF5bG9hZCBpcyBlbXB0eVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGF5bG9hZCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCB1cGRhdGUgb3B0aW9ucyBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBwcm9tcHRcIik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuX293bmVyQ29uZmxpY3RFcnJvcihcImRlbGV0ZSBhIHByb21wdFwiLCBvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vcmVwb3MvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBwdWxsUHJvbXB0Q29tbWl0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBjb21taXRIYXNoXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vY29tbWl0cy8ke293bmVyfS8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaH0ke29wdGlvbnM/LmluY2x1ZGVNb2RlbCA/IFwiP2luY2x1ZGVfbW9kZWw9dHJ1ZVwiIDogXCJcIn1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwicHVsbCBwcm9tcHQgY29tbWl0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgIHJlcG86IHByb21wdE5hbWUsXG4gICAgICAgICAgICBjb21taXRfaGFzaDogcmVzdWx0LmNvbW1pdF9oYXNoLFxuICAgICAgICAgICAgbWFuaWZlc3Q6IHJlc3VsdC5tYW5pZmVzdCxcbiAgICAgICAgICAgIGV4YW1wbGVzOiByZXN1bHQuZXhhbXBsZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgdXNlIGBpbXBvcnQgeyBwdWxsIH0gZnJvbSBcImxhbmdjaGFpbi9odWJcImAgaW5zdGVhZC5cbiAgICAgKiBVc2luZyB0aGlzIG1ldGhvZCBkaXJlY3RseSByZXR1cm5zIHRoZSBKU09OIHN0cmluZyBvZiB0aGUgcHJvbXB0IHJhdGhlciB0aGFuIGEgTGFuZ0NoYWluIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9wdWxsUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0T2JqZWN0ID0gYXdhaXQgdGhpcy5wdWxsUHJvbXB0Q29tbWl0KHByb21wdElkZW50aWZpZXIsIHtcbiAgICAgICAgICAgIGluY2x1ZGVNb2RlbDogb3B0aW9ucz8uaW5jbHVkZU1vZGVsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gSlNPTi5zdHJpbmdpZnkocHJvbXB0T2JqZWN0Lm1hbmlmZXN0KTtcbiAgICAgICAgcmV0dXJuIHByb21wdDtcbiAgICB9XG4gICAgYXN5bmMgcHVzaFByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvciB1cGRhdGUgcHJvbXB0IG1ldGFkYXRhXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnByb21wdEV4aXN0cyhwcm9tcHRJZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgT2JqZWN0LmtleXMob3B0aW9ucykuc29tZSgoa2V5KSA9PiBrZXkgIT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVQcm9tcHQocHJvbXB0SWRlbnRpZmllciwge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucz8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJlYWRtZTogb3B0aW9ucz8ucmVhZG1lLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiBvcHRpb25zPy50YWdzLFxuICAgICAgICAgICAgICAgICAgICBpc1B1YmxpYzogb3B0aW9ucz8uaXNQdWJsaWMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnM/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHJlYWRtZTogb3B0aW9ucz8ucmVhZG1lLFxuICAgICAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnM/LnRhZ3MsXG4gICAgICAgICAgICAgICAgaXNQdWJsaWM6IG9wdGlvbnM/LmlzUHVibGljLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zPy5vYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRQcm9tcHRVcmwocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgY29tbWl0IHdpdGggdGhlIG5ldyBtYW5pZmVzdFxuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmNyZWF0ZUNvbW1pdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zPy5vYmplY3QsIHtcbiAgICAgICAgICAgIHBhcmVudENvbW1pdEhhc2g6IG9wdGlvbnM/LnBhcmVudENvbW1pdEhhc2gsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSBhIHB1YmxpYyBkYXRhc2V0IHRvIHlvdXIgb3duIGxhbmdzbWl0aCB0ZW5hbnQuXG4gICAgICogVGhpcyBvcGVyYXRpb24gaXMgaWRlbXBvdGVudC4gSWYgeW91IGFscmVhZHkgaGF2ZSBhIGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgZG8gbm90aGluZy5cbiAgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuT3JVcmwgVGhlIHRva2VuIG9mIHRoZSBwdWJsaWMgZGF0YXNldCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgY2xvbmluZyB0aGUgZGF0YXNldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlQXBpVXJsXSBUaGUgVVJMIG9mIHRoZSBsYW5nc21pdGggc2VydmVyIHdoZXJlIHRoZSBkYXRhIGlzIGhvc3RlZC4gRGVmYXVsdHMgdG8gdGhlIEFQSSBVUkwgb2YgeW91ciBjdXJyZW50IGNsaWVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGF0YXNldE5hbWVdIFRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGNyZWF0ZSBpbiB5b3VyIHRlbmFudC4gRGVmYXVsdHMgdG8gdGhlIG5hbWUgb2YgdGhlIHB1YmxpYyBkYXRhc2V0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGNsb25lUHVibGljRGF0YXNldCh0b2tlbk9yVXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBzb3VyY2VBcGlVcmwgPSB0aGlzLmFwaVVybCwgZGF0YXNldE5hbWUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IFtwYXJzZWRBcGlVcmwsIHRva2VuVXVpZF0gPSB0aGlzLnBhcnNlVG9rZW5PclVybCh0b2tlbk9yVXJsLCBzb3VyY2VBcGlVcmwpO1xuICAgICAgICBjb25zdCBzb3VyY2VDbGllbnQgPSBuZXcgQ2xpZW50KHtcbiAgICAgICAgICAgIGFwaVVybDogcGFyc2VkQXBpVXJsLFxuICAgICAgICAgICAgLy8gUGxhY2Vob2xkZXIgQVBJIGtleSBub3QgbmVlZGVkIGFueW1vcmUgaW4gbW9zdCBjYXNlcywgYnV0XG4gICAgICAgICAgICAvLyBzb21lIHByaXZhdGUgZGVwbG95bWVudHMgbWF5IGhhdmUgQVBJIGtleS1iYXNlZCByYXRlIGxpbWl0aW5nXG4gICAgICAgICAgICAvLyB0aGF0IHdvdWxkIGNhdXNlIHRoaXMgdG8gZmFpbCBpZiB3ZSBwcm92aWRlIG5vIHZhbHVlLlxuICAgICAgICAgICAgYXBpS2V5OiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkcyA9IGF3YWl0IHNvdXJjZUNsaWVudC5yZWFkU2hhcmVkRGF0YXNldCh0b2tlblV1aWQpO1xuICAgICAgICBjb25zdCBmaW5hbERhdGFzZXROYW1lID0gZGF0YXNldE5hbWUgfHwgZHMubmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChhd2FpdCB0aGlzLmhhc0RhdGFzZXQoeyBkYXRhc2V0SWQ6IGZpbmFsRGF0YXNldE5hbWUgfSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRGF0YXNldCAke2ZpbmFsRGF0YXNldE5hbWV9IGFscmVhZHkgZXhpc3RzIGluIHlvdXIgdGVuYW50LiBTa2lwcGluZy5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIC8vIGAuaGFzRGF0YXNldGAgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZGF0YXNldCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICAgIC8vIG5vLW9wIGluIHRoYXQgY2FzZVxuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIGV4YW1wbGVzIGZpcnN0LCB0aGVuIGNyZWF0ZSB0aGUgZGF0YXNldFxuICAgICAgICBjb25zdCBleGFtcGxlcyA9IGF3YWl0IHNvdXJjZUNsaWVudC5saXN0U2hhcmVkRXhhbXBsZXModG9rZW5VdWlkKTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMuY3JlYXRlRGF0YXNldChmaW5hbERhdGFzZXROYW1lLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZHMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBkYXRhVHlwZTogZHMuZGF0YV90eXBlIHx8IFwia3ZcIixcbiAgICAgICAgICAgIGlucHV0c1NjaGVtYTogZHMuaW5wdXRzX3NjaGVtYV9kZWZpbml0aW9uID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG91dHB1dHNTY2hlbWE6IGRzLm91dHB1dHNfc2NoZW1hX2RlZmluaXRpb24gPz8gdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlRXhhbXBsZXMoe1xuICAgICAgICAgICAgICAgIGlucHV0czogZXhhbXBsZXMubWFwKChlKSA9PiBlLmlucHV0cyksXG4gICAgICAgICAgICAgICAgb3V0cHV0czogZXhhbXBsZXMuZmxhdE1hcCgoZSkgPT4gKGUub3V0cHV0cyA/IFtlLm91dHB1dHNdIDogW10pKSxcbiAgICAgICAgICAgICAgICBkYXRhc2V0SWQ6IGRhdGFzZXQuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgY3JlYXRpbmcgZGF0YXNldCAke2ZpbmFsRGF0YXNldE5hbWV9LiBgICtcbiAgICAgICAgICAgICAgICBcIllvdSBzaG91bGQgZGVsZXRlIGl0IG1hbnVhbGx5LlwiKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VUb2tlbk9yVXJsKHVybE9yVG9rZW4sIGFwaVVybCwgbnVtUGFydHMgPSAyLCBraW5kID0gXCJkYXRhc2V0XCIpIHtcbiAgICAgICAgLy8gVHJ5IHBhcnNpbmcgYXMgVVVJRFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZCh1cmxPclRva2VuKTsgLy8gV2lsbCB0aHJvdyBpZiBpdCdzIG5vdCBhIFVVSUQuXG4gICAgICAgICAgICByZXR1cm4gW2FwaVVybCwgdXJsT3JUb2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIC8vIG5vLW9wIGlmIGl0J3Mgbm90IGEgdXVpZFxuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIGFzIFVSTFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmxPclRva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHBhcnNlZFVybC5wYXRobmFtZVxuICAgICAgICAgICAgICAgIC5zcGxpdChcIi9cIilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0ICE9PSBcIlwiKTtcbiAgICAgICAgICAgIGlmIChwYXRoUGFydHMubGVuZ3RoID49IG51bVBhcnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5VdWlkID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSBudW1QYXJ0c107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthcGlVcmwsIHRva2VuVXVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljICR7a2luZH0gVVJMOiAke3VybE9yVG9rZW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljICR7a2luZH0gVVJMIG9yIHRva2VuOiAke3VybE9yVG9rZW59YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXdhaXRzIGFsbCBwZW5kaW5nIHRyYWNlIGJhdGNoZXMuIFVzZWZ1bCBmb3IgZW52aXJvbm1lbnRzIHdoZXJlXG4gICAgICogeW91IG5lZWQgdG8gYmUgc3VyZSB0aGF0IGFsbCB0cmFjaW5nIHJlcXVlc3RzIGZpbmlzaCBiZWZvcmUgZXhlY3V0aW9uIGVuZHMsXG4gICAgICogc3VjaCBhcyBzZXJ2ZXJsZXNzIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcImxhbmdzbWl0aFwiO1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgICAqXG4gICAgICogdHJ5IHtcbiAgICAgKiAgIC8vIFRyYWNpbmcgaGFwcGVucyBoZXJlXG4gICAgICogICAuLi5cbiAgICAgKiB9IGZpbmFsbHkge1xuICAgICAqICAgYXdhaXQgY2xpZW50LmF3YWl0UGVuZGluZ1RyYWNlQmF0Y2hlcygpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYWxsIGN1cnJlbnRseSBwZW5kaW5nIHRyYWNlcyBoYXZlIHNlbnQuXG4gICAgICovXG4gICAgYXN5bmMgYXdhaXRQZW5kaW5nVHJhY2VCYXRjaGVzKCkge1xuICAgICAgICBpZiAodGhpcy5tYW51YWxGbHVzaE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXTogV2hlbiB0cmFjaW5nIGluIG1hbnVhbCBmbHVzaCBtb2RlLCB5b3UgbXVzdCBjYWxsIGBhd2FpdCBjbGllbnQuZmx1c2goKWAgbWFudWFsbHkgdG8gc3VibWl0IHRyYWNlIGJhdGNoZXMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIC4uLnRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubWFwKCh7IGl0ZW1Qcm9taXNlIH0pID0+IGl0ZW1Qcm9taXNlKSxcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIucXVldWUub25JZGxlKCksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAodGhpcy5sYW5nU21pdGhUb09URUxUcmFuc2xhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGdldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cygpPy5ERUZBVUxUX0xBTkdTTUlUSF9TUEFOX1BST0NFU1NPUj8uZm9yY2VGbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFeGFtcGxlQ3JlYXRlKGlucHV0KSB7XG4gICAgcmV0dXJuIFwiZGF0YXNldF9pZFwiIGluIGlucHV0IHx8IFwiZGF0YXNldF9uYW1lXCIgaW4gaW5wdXQ7XG59XG4iXSwibmFtZXMiOlsidXVpZCIsIkxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IiLCJnZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMiLCJnZXRPVEVMVHJhY2UiLCJnZXRPVEVMQ29udGV4dCIsIkFzeW5jQ2FsbGVyIiwiY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUiLCJpc0xhbmdDaGFpbk1lc3NhZ2UiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsImdldFJ1bnRpbWVFbnZpcm9ubWVudCIsImdldE90ZWxFbmFibGVkIiwiX192ZXJzaW9uX18iLCJhc3NlcnRVdWlkIiwid2Fybk9uY2UiLCJwYXJzZVByb21wdElkZW50aWZpZXIiLCJyYWlzZUZvclN0YXR1cyIsIl9nbG9iYWxGZXRjaEltcGxlbWVudGF0aW9uSXNOb2RlRmV0Y2giLCJfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nIiwibWVyZ2VSdW50aW1lRW52SW50b1J1biIsInJ1biIsInJ1bnRpbWVFbnYiLCJlbnZWYXJzIiwiZXh0cmEiLCJtZXRhZGF0YSIsInJ1bnRpbWUiLCJyZXZpc2lvbl9pZCIsInVuZGVmaW5lZCIsImdldFRyYWNpbmdTYW1wbGluZ1JhdGUiLCJjb25maWdSYXRlIiwic2FtcGxpbmdSYXRlU3RyIiwidG9TdHJpbmciLCJzYW1wbGluZ1JhdGUiLCJwYXJzZUZsb2F0IiwiRXJyb3IiLCJpc0xvY2FsaG9zdCIsInVybCIsInN0cmlwcGVkVXJsIiwicmVwbGFjZSIsImhvc3RuYW1lIiwic3BsaXQiLCJ0b0FycmF5IiwiaXRlcmFibGUiLCJyZXN1bHQiLCJpdGVtIiwicHVzaCIsInRyaW1RdW90ZXMiLCJzdHIiLCJ0cmltIiwiaGFuZGxlNDI5IiwicmVzcG9uc2UiLCJzdGF0dXMiLCJyZXRyeUFmdGVyIiwicGFyc2VJbnQiLCJoZWFkZXJzIiwiZ2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiX2Zvcm1hdEZlZWRiYWNrU2NvcmUiLCJzY29yZSIsIk51bWJlciIsInRvRml4ZWQiLCJBdXRvQmF0Y2hRdWV1ZSIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInBlZWsiLCJpdGVtcyIsIml0ZW1Qcm9taXNlUmVzb2x2ZSIsIml0ZW1Qcm9taXNlIiwic2l6ZSIsImlkIiwibGVuZ3RoIiwiYWN0aW9uIiwicGF5bG9hZCIsIm90ZWxDb250ZXh0IiwiYXBpS2V5IiwiYXBpVXJsIiwic2l6ZUJ5dGVzIiwicG9wIiwidXBUb1NpemVCeXRlcyIsInBvcHBlZCIsInBvcHBlZFNpemVCeXRlcyIsInNoaWZ0IiwibWFwIiwiaXQiLCJmb3JFYWNoIiwiREVGQVVMVF9CQVRDSF9TSVpFX0xJTUlUX0JZVEVTIiwiU0VSVkVSX0lORk9fUkVRVUVTVF9USU1FT1VUIiwiREVGQVVMVF9BUElfVVJMIiwiQ2xpZW50IiwiY29uZmlnIiwiU2V0IiwiZGVmYXVsdENvbmZpZyIsImdldERlZmF1bHRDbGllbnRDb25maWciLCJ0cmFjaW5nU2FtcGxlUmF0ZSIsInRyYWNpbmdTYW1wbGluZ1JhdGUiLCJlbmRzV2l0aCIsInNsaWNlIiwid2ViVXJsIiwidGltZW91dF9tcyIsImNhbGxlciIsImNhbGxlck9wdGlvbnMiLCJkZWJ1ZyIsInRyYWNlQmF0Y2hDb25jdXJyZW5jeSIsImJhdGNoSW5nZXN0Q2FsbGVyIiwibWF4UmV0cmllcyIsIm1heENvbmN1cnJlbmN5Iiwib25GYWlsZWRSZXNwb25zZUhvb2siLCJoaWRlSW5wdXRzIiwiYW5vbnltaXplciIsImhpZGVPdXRwdXRzIiwiYXV0b0JhdGNoVHJhY2luZyIsImJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uIiwiYmF0Y2hTaXplQnl0ZXNMaW1pdCIsImZldGNoT3B0aW9ucyIsIm1hbnVhbEZsdXNoTW9kZSIsImxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IiLCJnZXRIb3N0VXJsIiwiaW5jbHVkZXMiLCJfZ2V0UGxhdGZvcm1FbmRwb2ludFBhdGgiLCJwYXRoIiwibmVlZHNWMVByZWZpeCIsInByb2Nlc3NJbnB1dHMiLCJpbnB1dHMiLCJwcm9jZXNzT3V0cHV0cyIsIm91dHB1dHMiLCJwcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMiLCJydW5QYXJhbXMiLCJfZ2V0UmVzcG9uc2UiLCJxdWVyeVBhcmFtcyIsInBhcmFtc1N0cmluZyIsImNhbGwiLCJtZXRob2QiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJfZ2V0IiwianNvbiIsIl9nZXRQYWdpbmF0ZWQiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0cmFuc2Zvcm0iLCJvZmZzZXQiLCJsaW1pdCIsInNldCIsIlN0cmluZyIsIl9nZXRDdXJzb3JQYWdpbmF0ZWRMaXN0IiwiYm9keSIsInJlcXVlc3RNZXRob2QiLCJkYXRhS2V5IiwiYm9keVBhcmFtcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNwb25zZUJvZHkiLCJjdXJzb3JzIiwibmV4dCIsImN1cnNvciIsIl9zaG91bGRTYW1wbGUiLCJNYXRoIiwicmFuZG9tIiwiX2ZpbHRlckZvclNhbXBsaW5nIiwicnVucyIsInBhdGNoIiwic2FtcGxlZCIsImZpbHRlcmVkUG9zdFV1aWRzIiwiaGFzIiwidHJhY2VfaWQiLCJkZWxldGUiLCJ0cmFjZUlkIiwiYWRkIiwiX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMiLCJzZXJ2ZXJJbmZvIiwiX2Vuc3VyZVNlcnZlckluZm8iLCJiYXRjaF9pbmdlc3RfY29uZmlnIiwic2l6ZV9saW1pdF9ieXRlcyIsIl9nZXRNdWx0aVBhcnRTdXBwb3J0IiwiaW5zdGFuY2VfZmxhZ3MiLCJkYXRhc2V0X2V4YW1wbGVzX211bHRpcGFydF9lbmFibGVkIiwiZHJhaW5BdXRvQmF0Y2hRdWV1ZSIsImJhdGNoU2l6ZUxpbWl0IiwicHJvbWlzZXMiLCJhdXRvQmF0Y2hRdWV1ZSIsImJhdGNoIiwiZG9uZSIsImJhdGNoZXNCeURlc3RpbmF0aW9uIiwicmVkdWNlIiwiYWNjIiwiaXNEZWZhdWx0IiwiYmF0Y2hLZXkiLCJiYXRjaFByb21pc2VzIiwiZW50cmllcyIsImJhdGNoUHJvbWlzZSIsIl9wcm9jZXNzQmF0Y2giLCJhbGxCYXRjaGVzUHJvbWlzZSIsImFsbCIsImZpbmFsbHkiLCJvcHRpb25zIiwiX3NlbmRCYXRjaFRvT1RFTFRyYW5zbGF0b3IiLCJpbmdlc3RQYXJhbXMiLCJydW5DcmVhdGVzIiwiZmlsdGVyIiwicnVuVXBkYXRlcyIsInVzZV9tdWx0aXBhcnRfZW5kcG9pbnQiLCJtdWx0aXBhcnRJbmdlc3RSdW5zIiwiYmF0Y2hJbmdlc3RSdW5zIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsIm90ZWxDb250ZXh0TWFwIiwiTWFwIiwib3BlcmF0aW9ucyIsIm9wZXJhdGlvbiIsImV4cG9ydEJhdGNoIiwicHJvY2Vzc1J1bk9wZXJhdGlvbiIsImNsZWFyVGltZW91dCIsImF1dG9CYXRjaFRpbWVvdXQiLCJzaXplTGltaXRCeXRlcyIsImF1dG9CYXRjaEFnZ3JlZ2F0aW9uRGVsYXlNcyIsIl9nZXRTZXJ2ZXJJbmZvIiwiQWNjZXB0IiwibG9nIiwiX2dldFNlcnZlckluZm9Qcm9taXNlIiwiX3NlcnZlckluZm8iLCJ3YXJuIiwidGhlbiIsIl9nZXRTZXR0aW5ncyIsInNldHRpbmdzIiwiZmx1c2giLCJfY2xvbmVDdXJyZW50T1RFTENvbnRleHQiLCJvdGVsX3RyYWNlIiwib3RlbF9jb250ZXh0IiwiY3VycmVudFNwYW4iLCJnZXRBY3RpdmVTcGFuIiwic2V0U3BhbiIsImFjdGl2ZSIsImNyZWF0ZVJ1biIsInNlc3Npb25fbmFtZSIsInByb2plY3RfbmFtZSIsInJ1bkNyZWF0ZSIsInN0YXJ0X3RpbWUiLCJEYXRlIiwibm93IiwiZG90dGVkX29yZGVyIiwiY2F0Y2giLCJtZXJnZWRSdW5DcmVhdGVQYXJhbSIsInByZXBhcmVkQ3JlYXRlUGFyYW1zIiwiY3JlYXRlIiwicHJlcGFyZWRVcGRhdGVQYXJhbXMiLCJ1cGRhdGUiLCJjcmVhdGVCeUlkIiwicGFyYW1zIiwic3RhbmRhbG9uZVVwZGF0ZXMiLCJ1cGRhdGVQYXJhbSIsInZhbHVlcyIsInJhd0JhdGNoIiwicG9zdCIsImJhdGNoQ2h1bmtzIiwiayIsImtleSIsImJhdGNoSXRlbXMiLCJyZXZlcnNlIiwiYmF0Y2hJdGVtIiwicnVuSWRzIiwiY29uY2F0Iiwiam9pbiIsIl9wb3N0QmF0Y2hJbmdlc3RSdW5zIiwiYWxsQXR0YWNobWVudHMiLCJwcmVwYXJlZENyZWF0ZSIsImF0dGFjaG1lbnRzIiwiaW52YWxpZFJ1bkNyZWF0ZSIsImZpbmQiLCJpbnZhbGlkUnVuVXBkYXRlIiwicnVuVXBkYXRlIiwiYWNjdW11bGF0ZWRDb250ZXh0IiwiYWNjdW11bGF0ZWRQYXJ0cyIsInBheWxvYWRzIiwib3JpZ2luYWxQYXlsb2FkIiwiZXZlbnRzIiwic2VyaWFsaXplZCIsImZpZWxkcyIsInN0cmluZ2lmaWVkUGF5bG9hZCIsIm5hbWUiLCJCbG9iIiwidHlwZSIsInN0cmluZ2lmaWVkVmFsdWUiLCJhdHRhY2htZW50IiwiY29udGVudFR5cGUiLCJjb250ZW50IiwiQXJyYXkiLCJpc0FycmF5IiwibWltZVR5cGUiLCJkYXRhIiwiYnl0ZUxlbmd0aCIsIl9zZW5kTXVsdGlwYXJ0UmVxdWVzdCIsIl9jcmVhdGVOb2RlRmV0Y2hCb2R5IiwicGFydHMiLCJib3VuZGFyeSIsImNodW5rcyIsInBhcnQiLCJhcnJheUJ1ZmZlciIsIl9jcmVhdGVNdWx0aXBhcnRTdHJlYW0iLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJzdHJlYW0iLCJSZWFkYWJsZVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsIndyaXRlQ2h1bmsiLCJjaHVuayIsImVucXVldWUiLCJlbmNvZGUiLCJwYXlsb2FkU3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwicmVhZCIsInJlbGVhc2VMb2NrIiwiY2xvc2UiLCJjb250ZXh0IiwiaXNOb2RlRmV0Y2giLCJidWlsZEJ1ZmZlcmVkIiwiYnVpbGRTdHJlYW0iLCJzZW5kIiwiZHVwbGV4IiwicmVzIiwic3RyZWFtZWRBdHRlbXB0IiwibXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWQiLCJtZXNzYWdlIiwidXBkYXRlUnVuIiwicnVuSWQiLCJlbmRfdGltZSIsInBhcmVudF9ydW5faWQiLCJyZWFkUnVuIiwibG9hZENoaWxkUnVucyIsIl9sb2FkQ2hpbGRSdW5zIiwiZ2V0UnVuVXJsIiwicHJvamVjdE9wdHMiLCJzZXNzaW9uSWQiLCJzZXNzaW9uX2lkIiwicHJvamVjdE5hbWUiLCJyZWFkUHJvamVjdCIsInByb2plY3RJZCIsInByb2plY3QiLCJ0ZW5hbnRJZCIsIl9nZXRUZW5hbnRJZCIsInJ1bl8iLCJhcHBfcGF0aCIsImJhc2VVcmwiLCJjaGlsZFJ1bnMiLCJsaXN0UnVucyIsImlzUm9vdCIsInRyZWVtYXAiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiY2hpbGRSdW4iLCJzdGFydHNXaXRoIiwiY2hpbGRfcnVucyIsInByb3BzIiwicGFyZW50UnVuSWQiLCJyZWZlcmVuY2VFeGFtcGxlSWQiLCJzdGFydFRpbWUiLCJleGVjdXRpb25PcmRlciIsInJ1blR5cGUiLCJxdWVyeSIsInRyYWNlRmlsdGVyIiwidHJlZUZpbHRlciIsInNlbGVjdCIsIm9yZGVyIiwicHJvamVjdElkcyIsInByb2plY3ROYW1lcyIsInByb2plY3RJZHNfIiwiZGVmYXVsdF9zZWxlY3QiLCJzZXNzaW9uIiwicnVuX3R5cGUiLCJyZWZlcmVuY2VfZXhhbXBsZSIsInRyYWNlX2ZpbHRlciIsInRyZWVfZmlsdGVyIiwiZXhlY3V0aW9uX29yZGVyIiwicGFyZW50X3J1biIsInRvSVNPU3RyaW5nIiwidHJhY2UiLCJpc19yb290IiwicnVuc1lpZWxkZWQiLCJuZXdSdW5zIiwibGlzdEdyb3VwUnVucyIsImdyb3VwQnkiLCJlbmRUaW1lIiwiYmFzZUJvZHkiLCJncm91cF9ieSIsImN1cnJlbnRPZmZzZXQiLCJjdXJyZW50Qm9keSIsImZpbHRlcmVkUGF5bG9hZCIsImZyb21FbnRyaWVzIiwiXyIsImdyb3VwcyIsInRvdGFsIiwidGhyZWFkIiwiZ2V0UnVuU3RhdHMiLCJwYXJlbnRSdW4iLCJyZWZlcmVuY2VFeGFtcGxlSWRzIiwiZGF0YVNvdXJjZVR5cGUiLCJkYXRhX3NvdXJjZV90eXBlIiwic2hhcmVSdW4iLCJzaGFyZUlkIiwicnVuX2lkIiwic2hhcmVfdG9rZW4iLCJ2NCIsInVuc2hhcmVSdW4iLCJyZWFkUnVuU2hhcmVkTGluayIsImxpc3RTaGFyZWRSdW5zIiwic2hhcmVUb2tlbiIsImFwcGVuZCIsInJlYWREYXRhc2V0U2hhcmVkU2NoZW1hIiwiZGF0YXNldElkIiwiZGF0YXNldE5hbWUiLCJkYXRhc2V0IiwicmVhZERhdGFzZXQiLCJzaGFyZVNjaGVtYSIsInNoYXJlRGF0YXNldCIsImRhdGFzZXRfaWQiLCJ1bnNoYXJlRGF0YXNldCIsInJlYWRTaGFyZWREYXRhc2V0IiwibGlzdFNoYXJlZEV4YW1wbGVzIiwiZXhhbXBsZUlkcyIsInVybFBhcmFtcyIsInYiLCJvayIsImRldGFpbCIsInN0YXR1c1RleHQiLCJleGFtcGxlIiwiX2hvc3RVcmwiLCJjcmVhdGVQcm9qZWN0IiwiZGVzY3JpcHRpb24iLCJ1cHNlcnQiLCJwcm9qZWN0RXh0cmEiLCJyZWZlcmVuY2VEYXRhc2V0SWQiLCJ1cHNlcnRfIiwiZW5kcG9pbnQiLCJ1cGRhdGVQcm9qZWN0IiwiaGFzUHJvamVjdCIsImluY2x1ZGVTdGF0cyIsImdldFByb2plY3RVcmwiLCJnZXREYXRhc2V0VXJsIiwiX3RlbmFudElkIiwicHJvamVjdHMiLCJ0ZW5hbnRfaWQiLCJsaXN0UHJvamVjdHMiLCJuYW1lQ29udGFpbnMiLCJyZWZlcmVuY2VEYXRhc2V0TmFtZSIsInJlZmVyZW5jZUZyZWUiLCJkZWxldGVQcm9qZWN0IiwicHJvamVjdElkXyIsInVwbG9hZENzdiIsImNzdkZpbGUiLCJmaWxlTmFtZSIsImlucHV0S2V5cyIsIm91dHB1dEtleXMiLCJkYXRhVHlwZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJjcmVhdGVEYXRhc2V0IiwiaW5wdXRzU2NoZW1hIiwib3V0cHV0c1NjaGVtYSIsImRhdGFfdHlwZSIsImlucHV0c19zY2hlbWFfZGVmaW5pdGlvbiIsIm91dHB1dHNfc2NoZW1hX2RlZmluaXRpb24iLCJoYXNEYXRhc2V0IiwidG9Mb2NhbGVMb3dlckNhc2UiLCJkaWZmRGF0YXNldFZlcnNpb25zIiwiZnJvbVZlcnNpb24iLCJ0b1ZlcnNpb24iLCJkYXRhc2V0SWRfIiwiZnJvbV92ZXJzaW9uIiwidG9fdmVyc2lvbiIsInJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyIsImRhdGFzZXRUZXh0IiwidGV4dCIsImxpbmUiLCJwYXJzZSIsImxpc3REYXRhc2V0cyIsImRhdGFzZXRJZHMiLCJkYXRhc2V0TmFtZUNvbnRhaW5zIiwiaWRfIiwiZGF0YXNldHMiLCJ1cGRhdGVEYXRhc2V0IiwiX2RhdGFzZXRJZCIsInVwZGF0ZURhdGFzZXRUYWciLCJhc09mIiwidGFnIiwiYXNfb2YiLCJkZWxldGVEYXRhc2V0IiwiaW5kZXhEYXRhc2V0Iiwic2ltaWxhckV4YW1wbGVzIiwiY3JlYXRlRXhhbXBsZSIsImlucHV0c09yVXBkYXRlIiwiaXNFeGFtcGxlQ3JlYXRlIiwiZGF0YXNldE5hbWVfIiwiZGF0YXNldF9uYW1lIiwiY3JlYXRlZEF0XyIsImNyZWF0ZWRBdCIsImNyZWF0ZWRfYXQiLCJleGFtcGxlSWQiLCJzb3VyY2VfcnVuX2lkIiwic291cmNlUnVuSWQiLCJ1c2Vfc291cmNlX3J1bl9pbyIsInVzZVNvdXJjZVJ1bklPIiwidXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHMiLCJ1c2VTb3VyY2VSdW5BdHRhY2htZW50cyIsIl91cGxvYWRFeGFtcGxlc011bHRpcGFydCIsInJlYWRFeGFtcGxlIiwiZXhhbXBsZV9pZHMiLCJjcmVhdGVFeGFtcGxlcyIsInByb3BzT3JVcGxvYWRzIiwidXBsb2FkcyIsImV4YW1wbGVzIiwic3BsaXRzIiwic291cmNlUnVuSWRzIiwidXNlU291cmNlUnVuSU9zIiwiZm9ybWF0dGVkRXhhbXBsZXMiLCJpbnB1dCIsImlkeCIsImNyZWF0ZUxMTUV4YW1wbGUiLCJnZW5lcmF0aW9uIiwib3V0cHV0IiwiY3JlYXRlQ2hhdEV4YW1wbGUiLCJnZW5lcmF0aW9ucyIsImZpbmFsSW5wdXQiLCJmaW5hbE91dHB1dCIsInJhd0V4YW1wbGUiLCJhdHRhY2htZW50X3VybHMiLCJyZXN0IiwicHJlc2lnbmVkX3VybCIsIm1pbWVfdHlwZSIsImxpc3RFeGFtcGxlcyIsImlubGluZVMzVXJscyIsImluY2x1ZGVBdHRhY2htZW50cyIsImRhdGFzZXRfdmVyc2lvbiIsImlubGluZVMzVXJsc18iLCJzZXJpYWxpemVkTWV0YWRhdGEiLCJmaWVsZCIsImkiLCJyYXdFeGFtcGxlcyIsImRlbGV0ZUV4YW1wbGUiLCJ1cGRhdGVFeGFtcGxlIiwiZXhhbXBsZUlkT3JVcGRhdGUiLCJ1cGRhdGVUb1VzZSIsIl91cGRhdGVFeGFtcGxlc011bHRpcGFydCIsInVwZGF0ZUV4YW1wbGVzIiwicmVhZERhdGFzZXRWZXJzaW9uIiwicmVzb2x2ZWREYXRhc2V0SWQiLCJsaXN0RGF0YXNldFNwbGl0cyIsInVwZGF0ZURhdGFzZXRTcGxpdHMiLCJzcGxpdE5hbWUiLCJyZW1vdmUiLCJzcGxpdF9uYW1lIiwiZXZhbHVhdGVSdW4iLCJldmFsdWF0b3IiLCJzb3VyY2VJbmZvIiwicmVmZXJlbmNlRXhhbXBsZSIsInJlZmVyZW5jZV9leGFtcGxlX2lkIiwiZmVlZGJhY2tSZXN1bHQiLCJmZWVkYmFja3MiLCJfbG9nRXZhbHVhdGlvbkZlZWRiYWNrIiwiY3JlYXRlRmVlZGJhY2siLCJjb3JyZWN0aW9uIiwiY29tbWVudCIsImZlZWRiYWNrU291cmNlVHlwZSIsImZlZWRiYWNrSWQiLCJmZWVkYmFja0NvbmZpZyIsImNvbXBhcmF0aXZlRXhwZXJpbWVudElkIiwiZmVlZGJhY2tfc291cmNlIiwiZmVlZGJhY2siLCJjb21wYXJhdGl2ZV9leHBlcmltZW50X2lkIiwidXBkYXRlRmVlZGJhY2siLCJmZWVkYmFja1VwZGF0ZSIsInJlYWRGZWVkYmFjayIsImRlbGV0ZUZlZWRiYWNrIiwibGlzdEZlZWRiYWNrIiwiZmVlZGJhY2tLZXlzIiwiZmVlZGJhY2tTb3VyY2VUeXBlcyIsImNyZWF0ZVByZXNpZ25lZEZlZWRiYWNrVG9rZW4iLCJmZWVkYmFja0tleSIsImV4cGlyYXRpb24iLCJmZWVkYmFja19rZXkiLCJmZWVkYmFja19jb25maWciLCJob3VycyIsIm1pbnV0ZXMiLCJkYXlzIiwiY3JlYXRlQ29tcGFyYXRpdmVFeHBlcmltZW50IiwiZXhwZXJpbWVudElkcyIsInJlZmVyZW5jZV9kYXRhc2V0X2lkIiwiZXhwZXJpbWVudF9pZHMiLCJsaXN0UHJlc2lnbmVkRmVlZGJhY2tUb2tlbnMiLCJ0b2tlbnMiLCJfc2VsZWN0RXZhbFJlc3VsdHMiLCJyZXN1bHRzIiwicmVzdWx0c18iLCJldmFsdWF0b3JSZXNwb25zZSIsImV2YWxSZXN1bHRzIiwic291cmNlSW5mb18iLCJldmFsdWF0b3JJbmZvIiwicnVuSWRfIiwidGFyZ2V0UnVuSWQiLCJsb2dFdmFsdWF0aW9uRmVlZGJhY2siLCJsaXN0QW5ub3RhdGlvblF1ZXVlcyIsInF1ZXVlSWRzIiwibWluIiwiY291bnQiLCJxdWV1ZXMiLCJjcmVhdGVBbm5vdGF0aW9uUXVldWUiLCJxdWV1ZUlkIiwicnVicmljSW5zdHJ1Y3Rpb25zIiwicnVicmljX2luc3RydWN0aW9ucyIsInJlYWRBbm5vdGF0aW9uUXVldWUiLCJ1cGRhdGVBbm5vdGF0aW9uUXVldWUiLCJkZWxldGVBbm5vdGF0aW9uUXVldWUiLCJhZGRSdW5zVG9Bbm5vdGF0aW9uUXVldWUiLCJnZXRSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlIiwiaW5kZXgiLCJkZWxldGVSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlIiwicXVldWVSdW5JZCIsImdldFNpemVGcm9tQW5ub3RhdGlvblF1ZXVlIiwiX2N1cnJlbnRUZW5hbnRJc093bmVyIiwib3duZXIiLCJ0ZW5hbnRfaGFuZGxlIiwiX293bmVyQ29uZmxpY3RFcnJvciIsIl9nZXRMYXRlc3RDb21taXRIYXNoIiwicHJvbXB0T3duZXJBbmROYW1lIiwic3RhdHVzQ29kZSIsImNvbW1pdHMiLCJjb21taXRfaGFzaCIsIl9saWtlT3JVbmxpa2VQcm9tcHQiLCJwcm9tcHRJZGVudGlmaWVyIiwibGlrZSIsInByb21wdE5hbWUiLCJfZ2V0UHJvbXB0VXJsIiwiY29tbWl0SGFzaCIsInN1YnN0cmluZyIsInByb21wdEV4aXN0cyIsInByb21wdCIsImdldFByb21wdCIsImxpa2VQcm9tcHQiLCJ1bmxpa2VQcm9tcHQiLCJsaXN0Q29tbWl0cyIsImxpc3RQcm9tcHRzIiwic29ydEZpZWxkIiwiaXNBcmNoaXZlZCIsImlzUHVibGljIiwicHJvbXB0cyIsInJlcG9zIiwicmVwbyIsImNyZWF0ZVByb21wdCIsInJlcG9faGFuZGxlIiwicmVhZG1lIiwidGFncyIsImlzX3B1YmxpYyIsImNyZWF0ZUNvbW1pdCIsIm9iamVjdCIsInJlc29sdmVkUGFyZW50Q29tbWl0SGFzaCIsInBhcmVudENvbW1pdEhhc2giLCJtYW5pZmVzdCIsInBhcmVudF9jb21taXQiLCJ1cGRhdGVFeGFtcGxlc011bHRpcGFydCIsInVwZGF0ZXMiLCJleGFtcGxlQm9keSIsInN0cmluZ2lmaWVkRXhhbXBsZSIsImV4YW1wbGVCbG9iIiwic3RyaW5naWZpZWRJbnB1dHMiLCJpbnB1dHNCbG9iIiwic3RyaW5naWZpZWRPdXRwdXRzIiwib3V0cHV0c0Jsb2IiLCJhdHRhY2htZW50QmxvYiIsImF0dGFjaG1lbnRzX29wZXJhdGlvbnMiLCJzdHJpbmdpZmllZEF0dGFjaG1lbnRzT3BlcmF0aW9ucyIsImF0dGFjaG1lbnRzT3BlcmF0aW9uc0Jsb2IiLCJkYXRhc2V0SWRUb1VzZSIsInVwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0IiwidXBkYXRlUHJvbXB0IiwiaXNfYXJjaGl2ZWQiLCJrZXlzIiwiZGVsZXRlUHJvbXB0IiwicHVsbFByb21wdENvbW1pdCIsImluY2x1ZGVNb2RlbCIsIl9wdWxsUHJvbXB0IiwicHJvbXB0T2JqZWN0IiwicHVzaFByb21wdCIsInNvbWUiLCJjbG9uZVB1YmxpY0RhdGFzZXQiLCJ0b2tlbk9yVXJsIiwic291cmNlQXBpVXJsIiwicGFyc2VkQXBpVXJsIiwidG9rZW5VdWlkIiwicGFyc2VUb2tlbk9yVXJsIiwic291cmNlQ2xpZW50IiwiZHMiLCJmaW5hbERhdGFzZXROYW1lIiwiZmxhdE1hcCIsInVybE9yVG9rZW4iLCJudW1QYXJ0cyIsImtpbmQiLCJwYXJzZWRVcmwiLCJVUkwiLCJwYXRoUGFydHMiLCJwYXRobmFtZSIsImF3YWl0UGVuZGluZ1RyYWNlQmF0Y2hlcyIsInF1ZXVlIiwib25JZGxlIiwiREVGQVVMVF9MQU5HU01JVEhfU1BBTl9QUk9DRVNTT1IiLCJmb3JjZUZsdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/env.js":
/*!********************************************!*\
  !*** ./node_modules/langsmith/dist/env.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n\nconst isTracingEnabled = (tracingEnabled)=>{\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\n        \"TRACING_V2\",\n        \"TRACING\"\n    ];\n    return !!envVars.find((envVar)=>(0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(envVar) === \"true\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlFO0FBQzFELE1BQU1DLG1CQUFtQixDQUFDQztJQUM3QixJQUFJQSxtQkFBbUJDLFdBQVc7UUFDOUIsT0FBT0Q7SUFDWDtJQUNBLE1BQU1FLFVBQVU7UUFBQztRQUFjO0tBQVU7SUFDekMsT0FBTyxDQUFDLENBQUNBLFFBQVFDLElBQUksQ0FBQyxDQUFDQyxTQUFXTiw4RUFBK0JBLENBQUNNLFlBQVk7QUFDbEYsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9lbnYuanM/ZTU5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5leHBvcnQgY29uc3QgaXNUcmFjaW5nRW5hYmxlZCA9ICh0cmFjaW5nRW5hYmxlZCkgPT4ge1xuICAgIGlmICh0cmFjaW5nRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nRW5hYmxlZDtcbiAgICB9XG4gICAgY29uc3QgZW52VmFycyA9IFtcIlRSQUNJTkdfVjJcIiwgXCJUUkFDSU5HXCJdO1xuICAgIHJldHVybiAhIWVudlZhcnMuZmluZCgoZW52VmFyKSA9PiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKGVudlZhcikgPT09IFwidHJ1ZVwiKTtcbn07XG4iXSwibmFtZXMiOlsiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsImlzVHJhY2luZ0VuYWJsZWQiLCJ0cmFjaW5nRW5hYmxlZCIsInVuZGVmaW5lZCIsImVudlZhcnMiLCJmaW5kIiwiZW52VmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/experimental/otel/constants.js":
/*!********************************************************************!*\
  !*** ./node_modules/langsmith/dist/experimental/otel/constants.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_SDK_LLM_OPERATIONS: () => (/* binding */ AI_SDK_LLM_OPERATIONS),\n/* harmony export */   AI_SDK_TOOL_OPERATIONS: () => (/* binding */ AI_SDK_TOOL_OPERATIONS),\n/* harmony export */   GENAI_COMPLETION: () => (/* binding */ GENAI_COMPLETION),\n/* harmony export */   GENAI_PROMPT: () => (/* binding */ GENAI_PROMPT),\n/* harmony export */   GEN_AI_ASSISTANT_MESSAGE: () => (/* binding */ GEN_AI_ASSISTANT_MESSAGE),\n/* harmony export */   GEN_AI_CHOICE: () => (/* binding */ GEN_AI_CHOICE),\n/* harmony export */   GEN_AI_OPERATION_NAME: () => (/* binding */ GEN_AI_OPERATION_NAME),\n/* harmony export */   GEN_AI_REQUEST_EXTRA_BODY: () => (/* binding */ GEN_AI_REQUEST_EXTRA_BODY),\n/* harmony export */   GEN_AI_REQUEST_EXTRA_QUERY: () => (/* binding */ GEN_AI_REQUEST_EXTRA_QUERY),\n/* harmony export */   GEN_AI_REQUEST_FREQUENCY_PENALTY: () => (/* binding */ GEN_AI_REQUEST_FREQUENCY_PENALTY),\n/* harmony export */   GEN_AI_REQUEST_MAX_TOKENS: () => (/* binding */ GEN_AI_REQUEST_MAX_TOKENS),\n/* harmony export */   GEN_AI_REQUEST_MODEL: () => (/* binding */ GEN_AI_REQUEST_MODEL),\n/* harmony export */   GEN_AI_REQUEST_PRESENCE_PENALTY: () => (/* binding */ GEN_AI_REQUEST_PRESENCE_PENALTY),\n/* harmony export */   GEN_AI_REQUEST_TEMPERATURE: () => (/* binding */ GEN_AI_REQUEST_TEMPERATURE),\n/* harmony export */   GEN_AI_REQUEST_TOP_P: () => (/* binding */ GEN_AI_REQUEST_TOP_P),\n/* harmony export */   GEN_AI_RESPONSE_FINISH_REASONS: () => (/* binding */ GEN_AI_RESPONSE_FINISH_REASONS),\n/* harmony export */   GEN_AI_RESPONSE_ID: () => (/* binding */ GEN_AI_RESPONSE_ID),\n/* harmony export */   GEN_AI_RESPONSE_MODEL: () => (/* binding */ GEN_AI_RESPONSE_MODEL),\n/* harmony export */   GEN_AI_RESPONSE_SERVICE_TIER: () => (/* binding */ GEN_AI_RESPONSE_SERVICE_TIER),\n/* harmony export */   GEN_AI_RESPONSE_SYSTEM_FINGERPRINT: () => (/* binding */ GEN_AI_RESPONSE_SYSTEM_FINGERPRINT),\n/* harmony export */   GEN_AI_SERIALIZED_DOC: () => (/* binding */ GEN_AI_SERIALIZED_DOC),\n/* harmony export */   GEN_AI_SERIALIZED_NAME: () => (/* binding */ GEN_AI_SERIALIZED_NAME),\n/* harmony export */   GEN_AI_SERIALIZED_SIGNATURE: () => (/* binding */ GEN_AI_SERIALIZED_SIGNATURE),\n/* harmony export */   GEN_AI_SYSTEM: () => (/* binding */ GEN_AI_SYSTEM),\n/* harmony export */   GEN_AI_SYSTEM_MESSAGE: () => (/* binding */ GEN_AI_SYSTEM_MESSAGE),\n/* harmony export */   GEN_AI_USAGE_INPUT_TOKENS: () => (/* binding */ GEN_AI_USAGE_INPUT_TOKENS),\n/* harmony export */   GEN_AI_USAGE_INPUT_TOKEN_DETAILS: () => (/* binding */ GEN_AI_USAGE_INPUT_TOKEN_DETAILS),\n/* harmony export */   GEN_AI_USAGE_OUTPUT_TOKENS: () => (/* binding */ GEN_AI_USAGE_OUTPUT_TOKENS),\n/* harmony export */   GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS: () => (/* binding */ GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS),\n/* harmony export */   GEN_AI_USAGE_TOTAL_TOKENS: () => (/* binding */ GEN_AI_USAGE_TOTAL_TOKENS),\n/* harmony export */   GEN_AI_USER_MESSAGE: () => (/* binding */ GEN_AI_USER_MESSAGE),\n/* harmony export */   LANGSMITH_DOTTED_ORDER: () => (/* binding */ LANGSMITH_DOTTED_ORDER),\n/* harmony export */   LANGSMITH_IS_ROOT: () => (/* binding */ LANGSMITH_IS_ROOT),\n/* harmony export */   LANGSMITH_METADATA: () => (/* binding */ LANGSMITH_METADATA),\n/* harmony export */   LANGSMITH_NAME: () => (/* binding */ LANGSMITH_NAME),\n/* harmony export */   LANGSMITH_PARENT_RUN_ID: () => (/* binding */ LANGSMITH_PARENT_RUN_ID),\n/* harmony export */   LANGSMITH_REFERENCE_EXAMPLE_ID: () => (/* binding */ LANGSMITH_REFERENCE_EXAMPLE_ID),\n/* harmony export */   LANGSMITH_REQUEST_HEADERS: () => (/* binding */ LANGSMITH_REQUEST_HEADERS),\n/* harmony export */   LANGSMITH_REQUEST_STREAMING: () => (/* binding */ LANGSMITH_REQUEST_STREAMING),\n/* harmony export */   LANGSMITH_RUNTIME: () => (/* binding */ LANGSMITH_RUNTIME),\n/* harmony export */   LANGSMITH_RUN_ID: () => (/* binding */ LANGSMITH_RUN_ID),\n/* harmony export */   LANGSMITH_RUN_TYPE: () => (/* binding */ LANGSMITH_RUN_TYPE),\n/* harmony export */   LANGSMITH_SESSION_ID: () => (/* binding */ LANGSMITH_SESSION_ID),\n/* harmony export */   LANGSMITH_SESSION_NAME: () => (/* binding */ LANGSMITH_SESSION_NAME),\n/* harmony export */   LANGSMITH_TAGS: () => (/* binding */ LANGSMITH_TAGS),\n/* harmony export */   LANGSMITH_TRACEABLE: () => (/* binding */ LANGSMITH_TRACEABLE),\n/* harmony export */   LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID: () => (/* binding */ LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID),\n/* harmony export */   LANGSMITH_TRACE_ID: () => (/* binding */ LANGSMITH_TRACE_ID),\n/* harmony export */   LANGSMITH_USAGE_METADATA: () => (/* binding */ LANGSMITH_USAGE_METADATA)\n/* harmony export */ });\n// OpenTelemetry GenAI semantic convention attribute names\nconst GEN_AI_OPERATION_NAME = \"gen_ai.operation.name\";\nconst GEN_AI_SYSTEM = \"gen_ai.system\";\nconst GEN_AI_REQUEST_MODEL = \"gen_ai.request.model\";\nconst GEN_AI_RESPONSE_MODEL = \"gen_ai.response.model\";\nconst GEN_AI_USAGE_INPUT_TOKENS = \"gen_ai.usage.input_tokens\";\nconst GEN_AI_USAGE_OUTPUT_TOKENS = \"gen_ai.usage.output_tokens\";\nconst GEN_AI_USAGE_TOTAL_TOKENS = \"gen_ai.usage.total_tokens\";\nconst GEN_AI_REQUEST_MAX_TOKENS = \"gen_ai.request.max_tokens\";\nconst GEN_AI_REQUEST_TEMPERATURE = \"gen_ai.request.temperature\";\nconst GEN_AI_REQUEST_TOP_P = \"gen_ai.request.top_p\";\nconst GEN_AI_REQUEST_FREQUENCY_PENALTY = \"gen_ai.request.frequency_penalty\";\nconst GEN_AI_REQUEST_PRESENCE_PENALTY = \"gen_ai.request.presence_penalty\";\nconst GEN_AI_RESPONSE_FINISH_REASONS = \"gen_ai.response.finish_reasons\";\nconst GENAI_PROMPT = \"gen_ai.prompt\";\nconst GENAI_COMPLETION = \"gen_ai.completion\";\nconst GEN_AI_REQUEST_EXTRA_QUERY = \"gen_ai.request.extra_query\";\nconst GEN_AI_REQUEST_EXTRA_BODY = \"gen_ai.request.extra_body\";\nconst GEN_AI_SERIALIZED_NAME = \"gen_ai.serialized.name\";\nconst GEN_AI_SERIALIZED_SIGNATURE = \"gen_ai.serialized.signature\";\nconst GEN_AI_SERIALIZED_DOC = \"gen_ai.serialized.doc\";\nconst GEN_AI_RESPONSE_ID = \"gen_ai.response.id\";\nconst GEN_AI_RESPONSE_SERVICE_TIER = \"gen_ai.response.service_tier\";\nconst GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = \"gen_ai.response.system_fingerprint\";\nconst GEN_AI_USAGE_INPUT_TOKEN_DETAILS = \"gen_ai.usage.input_token_details\";\nconst GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = \"gen_ai.usage.output_token_details\";\n// LangSmith custom attributes\nconst LANGSMITH_SESSION_ID = \"langsmith.trace.session_id\";\nconst LANGSMITH_SESSION_NAME = \"langsmith.trace.session_name\";\nconst LANGSMITH_RUN_TYPE = \"langsmith.span.kind\";\nconst LANGSMITH_NAME = \"langsmith.trace.name\";\nconst LANGSMITH_METADATA = \"langsmith.metadata\";\nconst LANGSMITH_TAGS = \"langsmith.span.tags\";\nconst LANGSMITH_RUNTIME = \"langsmith.span.runtime\";\nconst LANGSMITH_REQUEST_STREAMING = \"langsmith.request.streaming\";\nconst LANGSMITH_REQUEST_HEADERS = \"langsmith.request.headers\";\nconst LANGSMITH_RUN_ID = \"langsmith.span.id\";\nconst LANGSMITH_TRACE_ID = \"langsmith.trace.id\";\nconst LANGSMITH_DOTTED_ORDER = \"langsmith.span.dotted_order\";\nconst LANGSMITH_PARENT_RUN_ID = \"langsmith.span.parent_id\";\nconst LANGSMITH_USAGE_METADATA = \"langsmith.usage_metadata\";\nconst LANGSMITH_REFERENCE_EXAMPLE_ID = \"langsmith.reference_example_id\";\nconst LANGSMITH_TRACEABLE = \"langsmith.traceable\";\nconst LANGSMITH_IS_ROOT = \"langsmith.is_root\";\nconst LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID = \"langsmith.traceable_parent_otel_span_id\";\n// GenAI event names\nconst GEN_AI_SYSTEM_MESSAGE = \"gen_ai.system.message\";\nconst GEN_AI_USER_MESSAGE = \"gen_ai.user.message\";\nconst GEN_AI_ASSISTANT_MESSAGE = \"gen_ai.assistant.message\";\nconst GEN_AI_CHOICE = \"gen_ai.choice\";\nconst AI_SDK_LLM_OPERATIONS = [\n    \"ai.generateText.doGenerate\",\n    \"ai.streamText.doStream\",\n    \"ai.generateObject.doGenerate\",\n    \"ai.streamObject.doStream\"\n];\nconst AI_SDK_TOOL_OPERATIONS = [\n    \"ai.toolCall\"\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwREFBMEQ7QUFDbkQsTUFBTUEsd0JBQXdCLHdCQUF3QjtBQUN0RCxNQUFNQyxnQkFBZ0IsZ0JBQWdCO0FBQ3RDLE1BQU1DLHVCQUF1Qix1QkFBdUI7QUFDcEQsTUFBTUMsd0JBQXdCLHdCQUF3QjtBQUN0RCxNQUFNQyw0QkFBNEIsNEJBQTRCO0FBQzlELE1BQU1DLDZCQUE2Qiw2QkFBNkI7QUFDaEUsTUFBTUMsNEJBQTRCLDRCQUE0QjtBQUM5RCxNQUFNQyw0QkFBNEIsNEJBQTRCO0FBQzlELE1BQU1DLDZCQUE2Qiw2QkFBNkI7QUFDaEUsTUFBTUMsdUJBQXVCLHVCQUF1QjtBQUNwRCxNQUFNQyxtQ0FBbUMsbUNBQW1DO0FBQzVFLE1BQU1DLGtDQUFrQyxrQ0FBa0M7QUFDMUUsTUFBTUMsaUNBQWlDLGlDQUFpQztBQUN4RSxNQUFNQyxlQUFlLGdCQUFnQjtBQUNyQyxNQUFNQyxtQkFBbUIsb0JBQW9CO0FBQzdDLE1BQU1DLDZCQUE2Qiw2QkFBNkI7QUFDaEUsTUFBTUMsNEJBQTRCLDRCQUE0QjtBQUM5RCxNQUFNQyx5QkFBeUIseUJBQXlCO0FBQ3hELE1BQU1DLDhCQUE4Qiw4QkFBOEI7QUFDbEUsTUFBTUMsd0JBQXdCLHdCQUF3QjtBQUN0RCxNQUFNQyxxQkFBcUIscUJBQXFCO0FBQ2hELE1BQU1DLCtCQUErQiwrQkFBK0I7QUFDcEUsTUFBTUMscUNBQXFDLHFDQUFxQztBQUNoRixNQUFNQyxtQ0FBbUMsbUNBQW1DO0FBQzVFLE1BQU1DLG9DQUFvQyxvQ0FBb0M7QUFDckYsOEJBQThCO0FBQ3ZCLE1BQU1DLHVCQUF1Qiw2QkFBNkI7QUFDMUQsTUFBTUMseUJBQXlCLCtCQUErQjtBQUM5RCxNQUFNQyxxQkFBcUIsc0JBQXNCO0FBQ2pELE1BQU1DLGlCQUFpQix1QkFBdUI7QUFDOUMsTUFBTUMscUJBQXFCLHFCQUFxQjtBQUNoRCxNQUFNQyxpQkFBaUIsc0JBQXNCO0FBQzdDLE1BQU1DLG9CQUFvQix5QkFBeUI7QUFDbkQsTUFBTUMsOEJBQThCLDhCQUE4QjtBQUNsRSxNQUFNQyw0QkFBNEIsNEJBQTRCO0FBQzlELE1BQU1DLG1CQUFtQixvQkFBb0I7QUFDN0MsTUFBTUMscUJBQXFCLHFCQUFxQjtBQUNoRCxNQUFNQyx5QkFBeUIsOEJBQThCO0FBQzdELE1BQU1DLDBCQUEwQiwyQkFBMkI7QUFDM0QsTUFBTUMsMkJBQTJCLDJCQUEyQjtBQUM1RCxNQUFNQyxpQ0FBaUMsaUNBQWlDO0FBQ3hFLE1BQU1DLHNCQUFzQixzQkFBc0I7QUFDbEQsTUFBTUMsb0JBQW9CLG9CQUFvQjtBQUM5QyxNQUFNQywwQ0FBMEMsMENBQTBDO0FBQ2pHLG9CQUFvQjtBQUNiLE1BQU1DLHdCQUF3Qix3QkFBd0I7QUFDdEQsTUFBTUMsc0JBQXNCLHNCQUFzQjtBQUNsRCxNQUFNQywyQkFBMkIsMkJBQTJCO0FBQzVELE1BQU1DLGdCQUFnQixnQkFBZ0I7QUFDdEMsTUFBTUMsd0JBQXdCO0lBQ2pDO0lBQ0E7SUFDQTtJQUNBO0NBQ0gsQ0FBQztBQUNLLE1BQU1DLHlCQUF5QjtJQUFDO0NBQWMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9leHBlcmltZW50YWwvb3RlbC9jb25zdGFudHMuanM/ZDAzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPcGVuVGVsZW1ldHJ5IEdlbkFJIHNlbWFudGljIGNvbnZlbnRpb24gYXR0cmlidXRlIG5hbWVzXG5leHBvcnQgY29uc3QgR0VOX0FJX09QRVJBVElPTl9OQU1FID0gXCJnZW5fYWkub3BlcmF0aW9uLm5hbWVcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfU1lTVEVNID0gXCJnZW5fYWkuc3lzdGVtXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFUVVFU1RfTU9ERUwgPSBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFU1BPTlNFX01PREVMID0gXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5TID0gXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTlMgPSBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1VTQUdFX1RPVEFMX1RPS0VOUyA9IFwiZ2VuX2FpLnVzYWdlLnRvdGFsX3Rva2Vuc1wiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX01BWF9UT0tFTlMgPSBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9URU1QRVJBVFVSRSA9IFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9UT1BfUCA9IFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9GUkVRVUVOQ1lfUEVOQUxUWSA9IFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9QUkVTRU5DRV9QRU5BTFRZID0gXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFU1BPTlNFX0ZJTklTSF9SRUFTT05TID0gXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjtcbmV4cG9ydCBjb25zdCBHRU5BSV9QUk9NUFQgPSBcImdlbl9haS5wcm9tcHRcIjtcbmV4cG9ydCBjb25zdCBHRU5BSV9DT01QTEVUSU9OID0gXCJnZW5fYWkuY29tcGxldGlvblwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX0VYVFJBX1FVRVJZID0gXCJnZW5fYWkucmVxdWVzdC5leHRyYV9xdWVyeVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX0VYVFJBX0JPRFkgPSBcImdlbl9haS5yZXF1ZXN0LmV4dHJhX2JvZHlcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfU0VSSUFMSVpFRF9OQU1FID0gXCJnZW5fYWkuc2VyaWFsaXplZC5uYW1lXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1NFUklBTElaRURfU0lHTkFUVVJFID0gXCJnZW5fYWkuc2VyaWFsaXplZC5zaWduYXR1cmVcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfU0VSSUFMSVpFRF9ET0MgPSBcImdlbl9haS5zZXJpYWxpemVkLmRvY1wiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVNQT05TRV9JRCA9IFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFU1BPTlNFX1NFUlZJQ0VfVElFUiA9IFwiZ2VuX2FpLnJlc3BvbnNlLnNlcnZpY2VfdGllclwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVNQT05TRV9TWVNURU1fRklOR0VSUFJJTlQgPSBcImdlbl9haS5yZXNwb25zZS5zeXN0ZW1fZmluZ2VycHJpbnRcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5fREVUQUlMUyA9IFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2VuX2RldGFpbHNcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOX0RFVEFJTFMgPSBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5fZGV0YWlsc1wiO1xuLy8gTGFuZ1NtaXRoIGN1c3RvbSBhdHRyaWJ1dGVzXG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1NFU1NJT05fSUQgPSBcImxhbmdzbWl0aC50cmFjZS5zZXNzaW9uX2lkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1NFU1NJT05fTkFNRSA9IFwibGFuZ3NtaXRoLnRyYWNlLnNlc3Npb25fbmFtZVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SVU5fVFlQRSA9IFwibGFuZ3NtaXRoLnNwYW4ua2luZFwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9OQU1FID0gXCJsYW5nc21pdGgudHJhY2UubmFtZVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9NRVRBREFUQSA9IFwibGFuZ3NtaXRoLm1ldGFkYXRhXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1RBR1MgPSBcImxhbmdzbWl0aC5zcGFuLnRhZ3NcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUlVOVElNRSA9IFwibGFuZ3NtaXRoLnNwYW4ucnVudGltZVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SRVFVRVNUX1NUUkVBTUlORyA9IFwibGFuZ3NtaXRoLnJlcXVlc3Quc3RyZWFtaW5nXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1JFUVVFU1RfSEVBREVSUyA9IFwibGFuZ3NtaXRoLnJlcXVlc3QuaGVhZGVyc1wiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SVU5fSUQgPSBcImxhbmdzbWl0aC5zcGFuLmlkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1RSQUNFX0lEID0gXCJsYW5nc21pdGgudHJhY2UuaWRcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfRE9UVEVEX09SREVSID0gXCJsYW5nc21pdGguc3Bhbi5kb3R0ZWRfb3JkZXJcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUEFSRU5UX1JVTl9JRCA9IFwibGFuZ3NtaXRoLnNwYW4ucGFyZW50X2lkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1VTQUdFX01FVEFEQVRBID0gXCJsYW5nc21pdGgudXNhZ2VfbWV0YWRhdGFcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUkVGRVJFTkNFX0VYQU1QTEVfSUQgPSBcImxhbmdzbWl0aC5yZWZlcmVuY2VfZXhhbXBsZV9pZFwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9UUkFDRUFCTEUgPSBcImxhbmdzbWl0aC50cmFjZWFibGVcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfSVNfUk9PVCA9IFwibGFuZ3NtaXRoLmlzX3Jvb3RcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfVFJBQ0VBQkxFX1BBUkVOVF9PVEVMX1NQQU5fSUQgPSBcImxhbmdzbWl0aC50cmFjZWFibGVfcGFyZW50X290ZWxfc3Bhbl9pZFwiO1xuLy8gR2VuQUkgZXZlbnQgbmFtZXNcbmV4cG9ydCBjb25zdCBHRU5fQUlfU1lTVEVNX01FU1NBR0UgPSBcImdlbl9haS5zeXN0ZW0ubWVzc2FnZVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9VU0VSX01FU1NBR0UgPSBcImdlbl9haS51c2VyLm1lc3NhZ2VcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfQVNTSVNUQU5UX01FU1NBR0UgPSBcImdlbl9haS5hc3Npc3RhbnQubWVzc2FnZVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9DSE9JQ0UgPSBcImdlbl9haS5jaG9pY2VcIjtcbmV4cG9ydCBjb25zdCBBSV9TREtfTExNX09QRVJBVElPTlMgPSBbXG4gICAgXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgIFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgIFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgIFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG5dO1xuZXhwb3J0IGNvbnN0IEFJX1NES19UT09MX09QRVJBVElPTlMgPSBbXCJhaS50b29sQ2FsbFwiXTtcbiJdLCJuYW1lcyI6WyJHRU5fQUlfT1BFUkFUSU9OX05BTUUiLCJHRU5fQUlfU1lTVEVNIiwiR0VOX0FJX1JFUVVFU1RfTU9ERUwiLCJHRU5fQUlfUkVTUE9OU0VfTU9ERUwiLCJHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5TIiwiR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTlMiLCJHRU5fQUlfVVNBR0VfVE9UQUxfVE9LRU5TIiwiR0VOX0FJX1JFUVVFU1RfTUFYX1RPS0VOUyIsIkdFTl9BSV9SRVFVRVNUX1RFTVBFUkFUVVJFIiwiR0VOX0FJX1JFUVVFU1RfVE9QX1AiLCJHRU5fQUlfUkVRVUVTVF9GUkVRVUVOQ1lfUEVOQUxUWSIsIkdFTl9BSV9SRVFVRVNUX1BSRVNFTkNFX1BFTkFMVFkiLCJHRU5fQUlfUkVTUE9OU0VfRklOSVNIX1JFQVNPTlMiLCJHRU5BSV9QUk9NUFQiLCJHRU5BSV9DT01QTEVUSU9OIiwiR0VOX0FJX1JFUVVFU1RfRVhUUkFfUVVFUlkiLCJHRU5fQUlfUkVRVUVTVF9FWFRSQV9CT0RZIiwiR0VOX0FJX1NFUklBTElaRURfTkFNRSIsIkdFTl9BSV9TRVJJQUxJWkVEX1NJR05BVFVSRSIsIkdFTl9BSV9TRVJJQUxJWkVEX0RPQyIsIkdFTl9BSV9SRVNQT05TRV9JRCIsIkdFTl9BSV9SRVNQT05TRV9TRVJWSUNFX1RJRVIiLCJHRU5fQUlfUkVTUE9OU0VfU1lTVEVNX0ZJTkdFUlBSSU5UIiwiR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOX0RFVEFJTFMiLCJHRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOX0RFVEFJTFMiLCJMQU5HU01JVEhfU0VTU0lPTl9JRCIsIkxBTkdTTUlUSF9TRVNTSU9OX05BTUUiLCJMQU5HU01JVEhfUlVOX1RZUEUiLCJMQU5HU01JVEhfTkFNRSIsIkxBTkdTTUlUSF9NRVRBREFUQSIsIkxBTkdTTUlUSF9UQUdTIiwiTEFOR1NNSVRIX1JVTlRJTUUiLCJMQU5HU01JVEhfUkVRVUVTVF9TVFJFQU1JTkciLCJMQU5HU01JVEhfUkVRVUVTVF9IRUFERVJTIiwiTEFOR1NNSVRIX1JVTl9JRCIsIkxBTkdTTUlUSF9UUkFDRV9JRCIsIkxBTkdTTUlUSF9ET1RURURfT1JERVIiLCJMQU5HU01JVEhfUEFSRU5UX1JVTl9JRCIsIkxBTkdTTUlUSF9VU0FHRV9NRVRBREFUQSIsIkxBTkdTTUlUSF9SRUZFUkVOQ0VfRVhBTVBMRV9JRCIsIkxBTkdTTUlUSF9UUkFDRUFCTEUiLCJMQU5HU01JVEhfSVNfUk9PVCIsIkxBTkdTTUlUSF9UUkFDRUFCTEVfUEFSRU5UX09URUxfU1BBTl9JRCIsIkdFTl9BSV9TWVNURU1fTUVTU0FHRSIsIkdFTl9BSV9VU0VSX01FU1NBR0UiLCJHRU5fQUlfQVNTSVNUQU5UX01FU1NBR0UiLCJHRU5fQUlfQ0hPSUNFIiwiQUlfU0RLX0xMTV9PUEVSQVRJT05TIiwiQUlfU0RLX1RPT0xfT1BFUkFUSU9OUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/experimental/otel/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/experimental/otel/translator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/dist/experimental/otel/translator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangSmithToOTELTranslator: () => (/* binding */ LangSmithToOTELTranslator)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(rsc)/./node_modules/langsmith/dist/experimental/otel/constants.js\");\n/* harmony import */ var _singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../singletons/otel.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/otel.js\");\n\n\nconst WELL_KNOWN_OPERATION_NAMES = {\n    llm: \"chat\",\n    tool: \"execute_tool\",\n    retriever: \"embeddings\",\n    embedding: \"embeddings\",\n    prompt: \"chat\"\n};\nfunction getOperationName(runType) {\n    return WELL_KNOWN_OPERATION_NAMES[runType] || runType;\n}\nclass LangSmithToOTELTranslator {\n    constructor(){\n        Object.defineProperty(this, \"spans\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    exportBatch(operations, otelContextMap) {\n        for (const op of operations){\n            try {\n                if (!op.run) {\n                    continue;\n                }\n                if (op.operation === \"post\") {\n                    const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));\n                    if (span && !op.run.end_time) {\n                        this.spans.set(op.id, span);\n                    }\n                } else {\n                    this.updateSpanForRun(op, op.run);\n                }\n            } catch (e) {\n                console.error(`Error processing operation ${op.id}:`, e);\n            }\n        }\n    }\n    createSpanForRun(op, runInfo, otelContext) {\n        const activeSpan = otelContext && (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELTrace)().getSpan(otelContext);\n        if (!activeSpan) {\n            return;\n        }\n        try {\n            return this.finishSpanSetup(activeSpan, runInfo, op);\n        } catch (e) {\n            console.error(`Failed to create span for run ${op.id}:`, e);\n            return undefined;\n        }\n    }\n    finishSpanSetup(span, runInfo, op) {\n        // Set all attributes\n        this.setSpanAttributes(span, runInfo, op);\n        // Set status based on error\n        if (runInfo.error) {\n            span.setStatus({\n                code: 2\n            }); // ERROR status\n            span.recordException(new Error(runInfo.error));\n        } else {\n            span.setStatus({\n                code: 1\n            }); // OK status\n        }\n        // End the span if end_time is present\n        if (runInfo.end_time) {\n            span.end(new Date(runInfo.end_time));\n        }\n        return span;\n    }\n    updateSpanForRun(op, runInfo) {\n        try {\n            const span = this.spans.get(op.id);\n            if (!span) {\n                console.debug(`No span found for run ${op.id} during update`);\n                return;\n            }\n            // Update attributes\n            this.setSpanAttributes(span, runInfo, op);\n            // Update status based on error\n            if (runInfo.error) {\n                span.setStatus({\n                    code: 2\n                }); // ERROR status\n                span.recordException(new Error(runInfo.error));\n            } else {\n                span.setStatus({\n                    code: 1\n                }); // OK status\n            }\n            // End the span if end_time is present\n            const endTime = runInfo.end_time;\n            if (endTime) {\n                span.end(new Date(endTime));\n                this.spans.delete(op.id);\n            }\n        } catch (e) {\n            console.error(`Failed to update span for run ${op.id}:`, e);\n        }\n    }\n    extractModelName(runInfo) {\n        // Try to get model name from metadata\n        if (runInfo.extra?.metadata) {\n            const metadata = runInfo.extra.metadata;\n            // First check for ls_model_name in metadata\n            if (metadata.ls_model_name) {\n                return metadata.ls_model_name;\n            }\n            // Then check invocation_params for model info\n            if (metadata.invocation_params) {\n                const invocationParams = metadata.invocation_params;\n                if (invocationParams.model) {\n                    return invocationParams.model;\n                } else if (invocationParams.model_name) {\n                    return invocationParams.model_name;\n                }\n            }\n        }\n        return;\n    }\n    setSpanAttributes(span, runInfo, op) {\n        if (\"run_type\" in runInfo && runInfo.run_type) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_RUN_TYPE, runInfo.run_type);\n            // Set GenAI attributes according to OTEL semantic conventions\n            const operationName = getOperationName(runInfo.run_type || \"chain\");\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_OPERATION_NAME, operationName);\n        }\n        if (\"name\" in runInfo && runInfo.name) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_NAME, runInfo.name);\n        }\n        if (\"session_id\" in runInfo && runInfo.session_id) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_SESSION_ID, runInfo.session_id);\n        }\n        if (\"session_name\" in runInfo && runInfo.session_name) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_SESSION_NAME, runInfo.session_name);\n        }\n        // Set gen_ai.system\n        this.setGenAiSystem(span, runInfo);\n        // Set model name if available\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MODEL, modelName);\n        }\n        // Set token usage information\n        if (\"prompt_tokens\" in runInfo && typeof runInfo.prompt_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);\n        }\n        if (\"completion_tokens\" in runInfo && typeof runInfo.completion_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);\n        }\n        if (\"total_tokens\" in runInfo && typeof runInfo.total_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);\n        }\n        // Set other parameters from invocation_params\n        this.setInvocationParameters(span, runInfo);\n        // Set metadata and tags if available\n        const metadata = runInfo.extra?.metadata || {};\n        for (const [key, value] of Object.entries(metadata)){\n            if (value !== null && value !== undefined) {\n                span.setAttribute(`${_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_METADATA}.${key}`, String(value));\n            }\n        }\n        const tags = runInfo.tags;\n        if (tags && Array.isArray(tags)) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_TAGS, tags.join(\", \"));\n        } else if (tags) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_TAGS, String(tags));\n        }\n        // Support additional serialized attributes, if present\n        if (\"serialized\" in runInfo && typeof runInfo.serialized === \"object\") {\n            const serialized = runInfo.serialized;\n            if (serialized.name) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_NAME, String(serialized.name));\n            }\n            if (serialized.signature) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));\n            }\n            if (serialized.doc) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_DOC, String(serialized.doc));\n            }\n        }\n        // Set inputs/outputs if available\n        this.setIOAttributes(span, op);\n    }\n    setGenAiSystem(span, runInfo) {\n        // Default to \"langchain\" if we can't determine the system\n        let system = \"langchain\";\n        // Extract model name to determine the system\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            const modelLower = modelName.toLowerCase();\n            if (modelLower.includes(\"anthropic\") || modelLower.startsWith(\"claude\")) {\n                system = \"anthropic\";\n            } else if (modelLower.includes(\"bedrock\")) {\n                system = \"aws.bedrock\";\n            } else if (modelLower.includes(\"azure\") && modelLower.includes(\"openai\")) {\n                system = \"az.ai.openai\";\n            } else if (modelLower.includes(\"azure\") && modelLower.includes(\"inference\")) {\n                system = \"az.ai.inference\";\n            } else if (modelLower.includes(\"cohere\")) {\n                system = \"cohere\";\n            } else if (modelLower.includes(\"deepseek\")) {\n                system = \"deepseek\";\n            } else if (modelLower.includes(\"gemini\")) {\n                system = \"gemini\";\n            } else if (modelLower.includes(\"groq\")) {\n                system = \"groq\";\n            } else if (modelLower.includes(\"watson\") || modelLower.includes(\"ibm\")) {\n                system = \"ibm.watsonx.ai\";\n            } else if (modelLower.includes(\"mistral\")) {\n                system = \"mistral_ai\";\n            } else if (modelLower.includes(\"gpt\") || modelLower.includes(\"openai\")) {\n                system = \"openai\";\n            } else if (modelLower.includes(\"perplexity\") || modelLower.includes(\"sonar\")) {\n                system = \"perplexity\";\n            } else if (modelLower.includes(\"vertex\")) {\n                system = \"vertex_ai\";\n            } else if (modelLower.includes(\"xai\") || modelLower.includes(\"grok\")) {\n                system = \"xai\";\n            }\n        }\n        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SYSTEM, system);\n    }\n    setInvocationParameters(span, runInfo) {\n        if (!runInfo.extra?.metadata?.invocation_params) {\n            return;\n        }\n        const invocationParams = runInfo.extra.metadata.invocation_params;\n        // Set relevant invocation parameters\n        if (invocationParams.max_tokens !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);\n        }\n        if (invocationParams.temperature !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);\n        }\n        if (invocationParams.top_p !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_TOP_P, invocationParams.top_p);\n        }\n        if (invocationParams.frequency_penalty !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);\n        }\n        if (invocationParams.presence_penalty !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);\n        }\n    }\n    setIOAttributes(span, op) {\n        if (op.run.inputs) {\n            try {\n                const inputs = op.run.inputs;\n                if (typeof inputs === \"object\" && inputs !== null) {\n                    if (inputs.model && Array.isArray(inputs.messages)) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MODEL, inputs.model);\n                    }\n                    // Set additional request attributes if available\n                    if (inputs.stream !== undefined) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_REQUEST_STREAMING, inputs.stream);\n                    }\n                    if (inputs.extra_headers) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));\n                    }\n                    if (inputs.extra_query) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));\n                    }\n                    if (inputs.extra_body) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));\n                    }\n                }\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GENAI_PROMPT, JSON.stringify(inputs));\n            } catch (e) {\n                console.debug(`Failed to process inputs for run ${op.id}`, e);\n            }\n        }\n        if (op.run.outputs) {\n            try {\n                const outputs = op.run.outputs;\n                // Extract token usage from outputs (for LLM runs)\n                const tokenUsage = this.getUnifiedRunTokens(outputs);\n                if (tokenUsage) {\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);\n                }\n                if (outputs && typeof outputs === \"object\") {\n                    if (outputs.model) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_MODEL, String(outputs.model));\n                    }\n                    // Extract additional response attributes\n                    if (outputs.id) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_ID, outputs.id);\n                    }\n                    if (outputs.choices && Array.isArray(outputs.choices)) {\n                        const finishReasons = outputs.choices// eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        .map((choice)=>choice.finish_reason)// eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        .filter((reason)=>reason).map(String);\n                        if (finishReasons.length > 0) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(\", \"));\n                        }\n                    }\n                    if (outputs.service_tier) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);\n                    }\n                    if (outputs.system_fingerprint) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);\n                    }\n                    if (outputs.usage_metadata && typeof outputs.usage_metadata === \"object\") {\n                        const usageMetadata = outputs.usage_metadata;\n                        if (usageMetadata.input_token_details) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));\n                        }\n                        if (usageMetadata.output_token_details) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));\n                        }\n                    }\n                }\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GENAI_COMPLETION, JSON.stringify(outputs));\n            } catch (e) {\n                console.debug(`Failed to process outputs for run ${op.id}`, e);\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getUnifiedRunTokens(outputs) {\n        if (!outputs) {\n            return null;\n        }\n        // Search in non-generations lists\n        let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);\n        if (tokenUsage) {\n            return tokenUsage;\n        }\n        // Find if direct kwarg in outputs\n        const keys = Object.keys(outputs);\n        for (const key of keys){\n            const haystack = outputs[key];\n            if (!haystack || typeof haystack !== \"object\") {\n                continue;\n            }\n            tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);\n            if (tokenUsage) {\n                return tokenUsage;\n            }\n            if (haystack.lc === 1 && haystack.kwargs && typeof haystack.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        // Find in generations\n        const generations = outputs.generations || [];\n        if (!Array.isArray(generations)) {\n            return null;\n        }\n        const flatGenerations = Array.isArray(generations[0]) ? generations.flat() : generations;\n        for (const generation of flatGenerations){\n            if (typeof generation === \"object\" && generation.message && typeof generation.message === \"object\" && generation.message.kwargs && typeof generation.message.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        return null;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extractUnifiedRunTokens(outputs) {\n        if (!outputs || typeof outputs !== \"object\") {\n            return null;\n        }\n        if (typeof outputs.input_tokens !== \"number\" || typeof outputs.output_tokens !== \"number\") {\n            return null;\n        }\n        return [\n            outputs.input_tokens,\n            outputs.output_tokens\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvdHJhbnNsYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFDWTtBQUN4RCxNQUFNRSw2QkFBNkI7SUFDL0JDLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsUUFBUTtBQUNaO0FBQ0EsU0FBU0MsaUJBQWlCQyxPQUFPO0lBQzdCLE9BQU9QLDBCQUEwQixDQUFDTyxRQUFRLElBQUlBO0FBQ2xEO0FBQ08sTUFBTUM7SUFDVEMsYUFBYztRQUNWQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sSUFBSUM7UUFDZjtJQUNKO0lBQ0FDLFlBQVlDLFVBQVUsRUFBRUMsY0FBYyxFQUFFO1FBQ3BDLEtBQUssTUFBTUMsTUFBTUYsV0FBWTtZQUN6QixJQUFJO2dCQUNBLElBQUksQ0FBQ0UsR0FBR0MsR0FBRyxFQUFFO29CQUNUO2dCQUNKO2dCQUNBLElBQUlELEdBQUdFLFNBQVMsS0FBSyxRQUFRO29CQUN6QixNQUFNQyxPQUFPLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNKLElBQUlBLEdBQUdDLEdBQUcsRUFBRUYsZUFBZU0sR0FBRyxDQUFDTCxHQUFHTSxFQUFFO29CQUN2RSxJQUFJSCxRQUFRLENBQUNILEdBQUdDLEdBQUcsQ0FBQ00sUUFBUSxFQUFFO3dCQUMxQixJQUFJLENBQUNDLEtBQUssQ0FBQ0MsR0FBRyxDQUFDVCxHQUFHTSxFQUFFLEVBQUVIO29CQUMxQjtnQkFDSixPQUNLO29CQUNELElBQUksQ0FBQ08sZ0JBQWdCLENBQUNWLElBQUlBLEdBQUdDLEdBQUc7Z0JBQ3BDO1lBQ0osRUFDQSxPQUFPVSxHQUFHO2dCQUNOQyxRQUFRQyxLQUFLLENBQUMsQ0FBQywyQkFBMkIsRUFBRWIsR0FBR00sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFF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V0FBV0MsT0FBTyxLQUFLLFlBQzlCRCxXQUFXQyxPQUFPLENBQUNMLE1BQU0sSUFDekIsT0FBT0ksV0FBV0MsT0FBTyxDQUFDTCxNQUFNLEtBQUssVUFBVTtnQkFDL0M1QixhQUFhLElBQUksQ0FBQ3dCLHVCQUF1QixDQUFDUSxXQUFXQyxPQUFPLENBQUNMLE1BQU0sQ0FBQ1gsY0FBYztnQkFDbEYsSUFBSWpCLFlBQVk7b0JBQ1osT0FBT0E7Z0JBQ1g7WUFDSjtRQUNKO1FBQ0EsT0FBTztJQUNYO0lBQ0EsOERBQThEO0lBQzlEd0Isd0JBQXdCekIsT0FBTyxFQUFFO1FBQzdCLElBQUksQ0FBQ0EsV0FBVyxPQUFPQSxZQUFZLFVBQVU7WUFDekMsT0FBTztRQUNYO1FBQ0EsSUFBSSxPQUFPQSxRQUFRbUMsWUFBWSxLQUFLLFlBQ2hDLE9BQU9uQyxRQUFRb0MsYUFBYSxLQUFLLFVBQVU7WUFDM0MsT0FBTztRQUNYO1FBQ0EsT0FBTztZQUFDcEMsUUFBUW1DLFlBQVk7WUFBRW5DLFFBQVFvQyxhQUFhO1NBQUM7SUFDeEQ7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9leHBlcmltZW50YWwvb3RlbC90cmFuc2xhdG9yLmpzP2Y0NTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0T1RFTFRyYWNlIH0gZnJvbSBcIi4uLy4uL3NpbmdsZXRvbnMvb3RlbC5qc1wiO1xuY29uc3QgV0VMTF9LTk9XTl9PUEVSQVRJT05fTkFNRVMgPSB7XG4gICAgbGxtOiBcImNoYXRcIixcbiAgICB0b29sOiBcImV4ZWN1dGVfdG9vbFwiLFxuICAgIHJldHJpZXZlcjogXCJlbWJlZGRpbmdzXCIsXG4gICAgZW1iZWRkaW5nOiBcImVtYmVkZGluZ3NcIixcbiAgICBwcm9tcHQ6IFwiY2hhdFwiLFxufTtcbmZ1bmN0aW9uIGdldE9wZXJhdGlvbk5hbWUocnVuVHlwZSkge1xuICAgIHJldHVybiBXRUxMX0tOT1dOX09QRVJBVElPTl9OQU1FU1tydW5UeXBlXSB8fCBydW5UeXBlO1xufVxuZXhwb3J0IGNsYXNzIExhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzcGFuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBleHBvcnRCYXRjaChvcGVyYXRpb25zLCBvdGVsQ29udGV4dE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcC5ydW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcC5vcGVyYXRpb24gPT09IFwicG9zdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLmNyZWF0ZVNwYW5Gb3JSdW4ob3AsIG9wLnJ1biwgb3RlbENvbnRleHRNYXAuZ2V0KG9wLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFuICYmICFvcC5ydW4uZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhbnMuc2V0KG9wLmlkLCBzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTcGFuRm9yUnVuKG9wLCBvcC5ydW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBvcGVyYXRpb24gJHtvcC5pZH06YCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU3BhbkZvclJ1bihvcCwgcnVuSW5mbywgb3RlbENvbnRleHQpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlU3BhbiA9IG90ZWxDb250ZXh0ICYmIGdldE9URUxUcmFjZSgpLmdldFNwYW4ob3RlbENvbnRleHQpO1xuICAgICAgICBpZiAoIWFjdGl2ZVNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoU3BhblNldHVwKGFjdGl2ZVNwYW4sIHJ1bkluZm8sIG9wKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBzcGFuIGZvciBydW4gJHtvcC5pZH06YCwgZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmlzaFNwYW5TZXR1cChzcGFuLCBydW5JbmZvLCBvcCkge1xuICAgICAgICAvLyBTZXQgYWxsIGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5zZXRTcGFuQXR0cmlidXRlcyhzcGFuLCBydW5JbmZvLCBvcCk7XG4gICAgICAgIC8vIFNldCBzdGF0dXMgYmFzZWQgb24gZXJyb3JcbiAgICAgICAgaWYgKHJ1bkluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogMiB9KTsgLy8gRVJST1Igc3RhdHVzXG4gICAgICAgICAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbihuZXcgRXJyb3IocnVuSW5mby5lcnJvcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiAxIH0pOyAvLyBPSyBzdGF0dXNcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmQgdGhlIHNwYW4gaWYgZW5kX3RpbWUgaXMgcHJlc2VudFxuICAgICAgICBpZiAocnVuSW5mby5lbmRfdGltZSkge1xuICAgICAgICAgICAgc3Bhbi5lbmQobmV3IERhdGUocnVuSW5mby5lbmRfdGltZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICB1cGRhdGVTcGFuRm9yUnVuKG9wLCBydW5JbmZvKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5zcGFucy5nZXQob3AuaWQpO1xuICAgICAgICAgICAgaWYgKCFzcGFuKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgTm8gc3BhbiBmb3VuZCBmb3IgcnVuICR7b3AuaWR9IGR1cmluZyB1cGRhdGVgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgdGhpcy5zZXRTcGFuQXR0cmlidXRlcyhzcGFuLCBydW5JbmZvLCBvcCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGJhc2VkIG9uIGVycm9yXG4gICAgICAgICAgICBpZiAocnVuSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogMiB9KTsgLy8gRVJST1Igc3RhdHVzXG4gICAgICAgICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24obmV3IEVycm9yKHJ1bkluZm8uZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogMSB9KTsgLy8gT0sgc3RhdHVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbmQgdGhlIHNwYW4gaWYgZW5kX3RpbWUgaXMgcHJlc2VudFxuICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHJ1bkluZm8uZW5kX3RpbWU7XG4gICAgICAgICAgICBpZiAoZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIHNwYW4uZW5kKG5ldyBEYXRlKGVuZFRpbWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwYW5zLmRlbGV0ZShvcC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgc3BhbiBmb3IgcnVuICR7b3AuaWR9OmAsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4dHJhY3RNb2RlbE5hbWUocnVuSW5mbykge1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IG1vZGVsIG5hbWUgZnJvbSBtZXRhZGF0YVxuICAgICAgICBpZiAocnVuSW5mby5leHRyYT8ubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcnVuSW5mby5leHRyYS5tZXRhZGF0YTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGZvciBsc19tb2RlbF9uYW1lIGluIG1ldGFkYXRhXG4gICAgICAgICAgICBpZiAobWV0YWRhdGEubHNfbW9kZWxfbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YS5sc19tb2RlbF9uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlbiBjaGVjayBpbnZvY2F0aW9uX3BhcmFtcyBmb3IgbW9kZWwgaW5mb1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmludm9jYXRpb25fcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52b2NhdGlvblBhcmFtcyA9IG1ldGFkYXRhLmludm9jYXRpb25fcGFyYW1zO1xuICAgICAgICAgICAgICAgIGlmIChpbnZvY2F0aW9uUGFyYW1zLm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZvY2F0aW9uUGFyYW1zLm1vZGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnZvY2F0aW9uUGFyYW1zLm1vZGVsX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludm9jYXRpb25QYXJhbXMubW9kZWxfbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRTcGFuQXR0cmlidXRlcyhzcGFuLCBydW5JbmZvLCBvcCkge1xuICAgICAgICBpZiAoXCJydW5fdHlwZVwiIGluIHJ1bkluZm8gJiYgcnVuSW5mby5ydW5fdHlwZSkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9SVU5fVFlQRSwgcnVuSW5mby5ydW5fdHlwZSk7XG4gICAgICAgICAgICAvLyBTZXQgR2VuQUkgYXR0cmlidXRlcyBhY2NvcmRpbmcgdG8gT1RFTCBzZW1hbnRpYyBjb252ZW50aW9uc1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uTmFtZSA9IGdldE9wZXJhdGlvbk5hbWUocnVuSW5mby5ydW5fdHlwZSB8fCBcImNoYWluXCIpO1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9PUEVSQVRJT05fTkFNRSwgb3BlcmF0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwibmFtZVwiIGluIHJ1bkluZm8gJiYgcnVuSW5mby5uYW1lKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX05BTUUsIHJ1bkluZm8ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic2Vzc2lvbl9pZFwiIGluIHJ1bkluZm8gJiYgcnVuSW5mby5zZXNzaW9uX2lkKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX1NFU1NJT05fSUQsIHJ1bkluZm8uc2Vzc2lvbl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic2Vzc2lvbl9uYW1lXCIgaW4gcnVuSW5mbyAmJiBydW5JbmZvLnNlc3Npb25fbmFtZSkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9TRVNTSU9OX05BTUUsIHJ1bkluZm8uc2Vzc2lvbl9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgZ2VuX2FpLnN5c3RlbVxuICAgICAgICB0aGlzLnNldEdlbkFpU3lzdGVtKHNwYW4sIHJ1bkluZm8pO1xuICAgICAgICAvLyBTZXQgbW9kZWwgbmFtZSBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGhpcy5leHRyYWN0TW9kZWxOYW1lKHJ1bkluZm8pO1xuICAgICAgICBpZiAobW9kZWxOYW1lKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfTU9ERUwsIG1vZGVsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRva2VuIHVzYWdlIGluZm9ybWF0aW9uXG4gICAgICAgIGlmIChcInByb21wdF90b2tlbnNcIiBpbiBydW5JbmZvICYmXG4gICAgICAgICAgICB0eXBlb2YgcnVuSW5mby5wcm9tcHRfdG9rZW5zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOUywgcnVuSW5mby5wcm9tcHRfdG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjb21wbGV0aW9uX3Rva2Vuc1wiIGluIHJ1bkluZm8gJiZcbiAgICAgICAgICAgIHR5cGVvZiBydW5JbmZvLmNvbXBsZXRpb25fdG9rZW5zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTlMsIHJ1bkluZm8uY29tcGxldGlvbl90b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInRvdGFsX3Rva2Vuc1wiIGluIHJ1bkluZm8gJiYgdHlwZW9mIHJ1bkluZm8udG90YWxfdG9rZW5zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX1RPVEFMX1RPS0VOUywgcnVuSW5mby50b3RhbF90b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvdGhlciBwYXJhbWV0ZXJzIGZyb20gaW52b2NhdGlvbl9wYXJhbXNcbiAgICAgICAgdGhpcy5zZXRJbnZvY2F0aW9uUGFyYW1ldGVycyhzcGFuLCBydW5JbmZvKTtcbiAgICAgICAgLy8gU2V0IG1ldGFkYXRhIGFuZCB0YWdzIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHJ1bkluZm8uZXh0cmE/Lm1ldGFkYXRhIHx8IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoYCR7Y29uc3RhbnRzLkxBTkdTTUlUSF9NRVRBREFUQX0uJHtrZXl9YCwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFncyA9IHJ1bkluZm8udGFncztcbiAgICAgICAgaWYgKHRhZ3MgJiYgQXJyYXkuaXNBcnJheSh0YWdzKSkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9UQUdTLCB0YWdzLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFncykge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9UQUdTLCBTdHJpbmcodGFncykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1cHBvcnQgYWRkaXRpb25hbCBzZXJpYWxpemVkIGF0dHJpYnV0ZXMsIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKFwic2VyaWFsaXplZFwiIGluIHJ1bkluZm8gJiYgdHlwZW9mIHJ1bkluZm8uc2VyaWFsaXplZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHJ1bkluZm8uc2VyaWFsaXplZDtcbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1NFUklBTElaRURfTkFNRSwgU3RyaW5nKHNlcmlhbGl6ZWQubmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWQuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9TRVJJQUxJWkVEX1NJR05BVFVSRSwgU3RyaW5nKHNlcmlhbGl6ZWQuc2lnbmF0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZC5kb2MpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1NFUklBTElaRURfRE9DLCBTdHJpbmcoc2VyaWFsaXplZC5kb2MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgaW5wdXRzL291dHB1dHMgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRoaXMuc2V0SU9BdHRyaWJ1dGVzKHNwYW4sIG9wKTtcbiAgICB9XG4gICAgc2V0R2VuQWlTeXN0ZW0oc3BhbiwgcnVuSW5mbykge1xuICAgICAgICAvLyBEZWZhdWx0IHRvIFwibGFuZ2NoYWluXCIgaWYgd2UgY2FuJ3QgZGV0ZXJtaW5lIHRoZSBzeXN0ZW1cbiAgICAgICAgbGV0IHN5c3RlbSA9IFwibGFuZ2NoYWluXCI7XG4gICAgICAgIC8vIEV4dHJhY3QgbW9kZWwgbmFtZSB0byBkZXRlcm1pbmUgdGhlIHN5c3RlbVxuICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB0aGlzLmV4dHJhY3RNb2RlbE5hbWUocnVuSW5mbyk7XG4gICAgICAgIGlmIChtb2RlbE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsTG93ZXIgPSBtb2RlbE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiYW50aHJvcGljXCIpIHx8IG1vZGVsTG93ZXIuc3RhcnRzV2l0aChcImNsYXVkZVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiYW50aHJvcGljXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiYmVkcm9ja1wiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiYXdzLmJlZHJvY2tcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJhenVyZVwiKSAmJlxuICAgICAgICAgICAgICAgIG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJvcGVuYWlcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImF6LmFpLm9wZW5haVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImF6dXJlXCIpICYmXG4gICAgICAgICAgICAgICAgbW9kZWxMb3dlci5pbmNsdWRlcyhcImluZmVyZW5jZVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiYXouYWkuaW5mZXJlbmNlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiY29oZXJlXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJjb2hlcmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJkZWVwc2Vla1wiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiZGVlcHNlZWtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJnZW1pbmlcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImdlbWluaVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImdyb3FcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImdyb3FcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJ3YXRzb25cIikgfHwgbW9kZWxMb3dlci5pbmNsdWRlcyhcImlibVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiaWJtLndhdHNvbnguYWlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJtaXN0cmFsXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJtaXN0cmFsX2FpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiZ3B0XCIpIHx8IG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJvcGVuYWlcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcIm9wZW5haVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcInBlcnBsZXhpdHlcIikgfHxcbiAgICAgICAgICAgICAgICBtb2RlbExvd2VyLmluY2x1ZGVzKFwic29uYXJcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcInBlcnBsZXhpdHlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJ2ZXJ0ZXhcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcInZlcnRleF9haVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcInhhaVwiKSB8fCBtb2RlbExvd2VyLmluY2x1ZGVzKFwiZ3Jva1wiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwieGFpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9TWVNURU0sIHN5c3RlbSk7XG4gICAgfVxuICAgIHNldEludm9jYXRpb25QYXJhbWV0ZXJzKHNwYW4sIHJ1bkluZm8pIHtcbiAgICAgICAgaWYgKCFydW5JbmZvLmV4dHJhPy5tZXRhZGF0YT8uaW52b2NhdGlvbl9wYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnZvY2F0aW9uUGFyYW1zID0gcnVuSW5mby5leHRyYS5tZXRhZGF0YS5pbnZvY2F0aW9uX3BhcmFtcztcbiAgICAgICAgLy8gU2V0IHJlbGV2YW50IGludm9jYXRpb24gcGFyYW1ldGVyc1xuICAgICAgICBpZiAoaW52b2NhdGlvblBhcmFtcy5tYXhfdG9rZW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9NQVhfVE9LRU5TLCBpbnZvY2F0aW9uUGFyYW1zLm1heF90b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZvY2F0aW9uUGFyYW1zLnRlbXBlcmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9URU1QRVJBVFVSRSwgaW52b2NhdGlvblBhcmFtcy50ZW1wZXJhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludm9jYXRpb25QYXJhbXMudG9wX3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX1RPUF9QLCBpbnZvY2F0aW9uUGFyYW1zLnRvcF9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52b2NhdGlvblBhcmFtcy5mcmVxdWVuY3lfcGVuYWx0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfRlJFUVVFTkNZX1BFTkFMVFksIGludm9jYXRpb25QYXJhbXMuZnJlcXVlbmN5X3BlbmFsdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZvY2F0aW9uUGFyYW1zLnByZXNlbmNlX3BlbmFsdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX1BSRVNFTkNFX1BFTkFMVFksIGludm9jYXRpb25QYXJhbXMucHJlc2VuY2VfcGVuYWx0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SU9BdHRyaWJ1dGVzKHNwYW4sIG9wKSB7XG4gICAgICAgIGlmIChvcC5ydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG9wLnJ1bi5pbnB1dHM7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dHMgPT09IFwib2JqZWN0XCIgJiYgaW5wdXRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMubW9kZWwgJiYgQXJyYXkuaXNBcnJheShpbnB1dHMubWVzc2FnZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfTU9ERUwsIGlucHV0cy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFkZGl0aW9uYWwgcmVxdWVzdCBhdHRyaWJ1dGVzIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLnN0cmVhbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX1JFUVVFU1RfU1RSRUFNSU5HLCBpbnB1dHMuc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmV4dHJhX2hlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5MQU5HU01JVEhfUkVRVUVTVF9IRUFERVJTLCBKU09OLnN0cmluZ2lmeShpbnB1dHMuZXh0cmFfaGVhZGVycykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMuZXh0cmFfcXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9FWFRSQV9RVUVSWSwgSlNPTi5zdHJpbmdpZnkoaW5wdXRzLmV4dHJhX3F1ZXJ5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cy5leHRyYV9ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfRVhUUkFfQk9EWSwgSlNPTi5zdHJpbmdpZnkoaW5wdXRzLmV4dHJhX2JvZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOQUlfUFJPTVBULCBKU09OLnN0cmluZ2lmeShpbnB1dHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgRmFpbGVkIHRvIHByb2Nlc3MgaW5wdXRzIGZvciBydW4gJHtvcC5pZH1gLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3AucnVuLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IG9wLnJ1bi5vdXRwdXRzO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdG9rZW4gdXNhZ2UgZnJvbSBvdXRwdXRzIChmb3IgTExNIHJ1bnMpXG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Vc2FnZSA9IHRoaXMuZ2V0VW5pZmllZFJ1blRva2VucyhvdXRwdXRzKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5Vc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOUywgdG9rZW5Vc2FnZVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOUywgdG9rZW5Vc2FnZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfVE9UQUxfVE9LRU5TLCB0b2tlblVzYWdlWzBdICsgdG9rZW5Vc2FnZVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzICYmIHR5cGVvZiBvdXRwdXRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFU1BPTlNFX01PREVMLCBTdHJpbmcob3V0cHV0cy5tb2RlbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgYWRkaXRpb25hbCByZXNwb25zZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFU1BPTlNFX0lELCBvdXRwdXRzLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy5jaG9pY2VzICYmIEFycmF5LmlzQXJyYXkob3V0cHV0cy5jaG9pY2VzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluaXNoUmVhc29ucyA9IG91dHB1dHMuY2hvaWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoY2hvaWNlKSA9PiBjaG9pY2UuZmluaXNoX3JlYXNvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHJlYXNvbikgPT4gcmVhc29uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hSZWFzb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFU1BPTlNFX0ZJTklTSF9SRUFTT05TLCBmaW5pc2hSZWFzb25zLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHMuc2VydmljZV90aWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFU1BPTlNFX1NFUlZJQ0VfVElFUiwgb3V0cHV0cy5zZXJ2aWNlX3RpZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLnN5c3RlbV9maW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVNQT05TRV9TWVNURU1fRklOR0VSUFJJTlQsIG91dHB1dHMuc3lzdGVtX2ZpbmdlcnByaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy51c2FnZV9tZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG91dHB1dHMudXNhZ2VfbWV0YWRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzYWdlTWV0YWRhdGEgPSBvdXRwdXRzLnVzYWdlX21ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzYWdlTWV0YWRhdGEuaW5wdXRfdG9rZW5fZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5fREVUQUlMUywgSlNPTi5zdHJpbmdpZnkodXNhZ2VNZXRhZGF0YS5pbnB1dF90b2tlbl9kZXRhaWxzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNhZ2VNZXRhZGF0YS5vdXRwdXRfdG9rZW5fZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOX0RFVEFJTFMsIEpTT04uc3RyaW5naWZ5KHVzYWdlTWV0YWRhdGEub3V0cHV0X3Rva2VuX2RldGFpbHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOQUlfQ09NUExFVElPTiwgSlNPTi5zdHJpbmdpZnkob3V0cHV0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBGYWlsZWQgdG8gcHJvY2VzcyBvdXRwdXRzIGZvciBydW4gJHtvcC5pZH1gLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGdldFVuaWZpZWRSdW5Ub2tlbnMob3V0cHV0cykge1xuICAgICAgICBpZiAoIW91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlYXJjaCBpbiBub24tZ2VuZXJhdGlvbnMgbGlzdHNcbiAgICAgICAgbGV0IHRva2VuVXNhZ2UgPSB0aGlzLmV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zKG91dHB1dHMudXNhZ2VfbWV0YWRhdGEpO1xuICAgICAgICBpZiAodG9rZW5Vc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuVXNhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCBpZiBkaXJlY3Qga3dhcmcgaW4gb3V0cHV0c1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3V0cHV0cyk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhheXN0YWNrID0gb3V0cHV0c1trZXldO1xuICAgICAgICAgICAgaWYgKCFoYXlzdGFjayB8fCB0eXBlb2YgaGF5c3RhY2sgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuVXNhZ2UgPSB0aGlzLmV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zKGhheXN0YWNrLnVzYWdlX21ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmICh0b2tlblVzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuVXNhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGF5c3RhY2subGMgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBoYXlzdGFjay5rd2FyZ3MgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgaGF5c3RhY2sua3dhcmdzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5Vc2FnZSA9IHRoaXMuZXh0cmFjdFVuaWZpZWRSdW5Ub2tlbnMoaGF5c3RhY2sua3dhcmdzLnVzYWdlX21ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5Vc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5Vc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCBpbiBnZW5lcmF0aW9uc1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IG91dHB1dHMuZ2VuZXJhdGlvbnMgfHwgW107XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShnZW5lcmF0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYXRHZW5lcmF0aW9ucyA9IEFycmF5LmlzQXJyYXkoZ2VuZXJhdGlvbnNbMF0pXG4gICAgICAgICAgICA/IGdlbmVyYXRpb25zLmZsYXQoKVxuICAgICAgICAgICAgOiBnZW5lcmF0aW9ucztcbiAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0aW9uIG9mIGZsYXRHZW5lcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW5lcmF0aW9uID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbi5tZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGdlbmVyYXRpb24ubWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb24ubWVzc2FnZS5rd2FyZ3MgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZ2VuZXJhdGlvbi5tZXNzYWdlLmt3YXJncyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRva2VuVXNhZ2UgPSB0aGlzLmV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zKGdlbmVyYXRpb24ubWVzc2FnZS5rd2FyZ3MudXNhZ2VfbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblVzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlblVzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBleHRyYWN0VW5pZmllZFJ1blRva2VucyhvdXRwdXRzKSB7XG4gICAgICAgIGlmICghb3V0cHV0cyB8fCB0eXBlb2Ygb3V0cHV0cyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXRzLmlucHV0X3Rva2VucyAhPT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIG91dHB1dHMub3V0cHV0X3Rva2VucyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtvdXRwdXRzLmlucHV0X3Rva2Vucywgb3V0cHV0cy5vdXRwdXRfdG9rZW5zXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiY29uc3RhbnRzIiwiZ2V0T1RFTFRyYWNlIiwiV0VMTF9LTk9XTl9PUEVSQVRJT05fTkFNRVMiLCJsbG0iLCJ0b29sIiwicmV0cmlldmVyIiwiZW1iZWRkaW5nIiwicHJvbXB0IiwiZ2V0T3BlcmF0aW9uTmFtZSIsInJ1blR5cGUiLCJMYW5nU21pdGhUb09URUxUcmFuc2xhdG9yIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiTWFwIiwiZXhwb3J0QmF0Y2giLCJvcGVyYXRpb25zIiwib3RlbENvbnRleHRNYXAiLCJvcCIsInJ1biIsIm9wZXJhdGlvbiIsInNwYW4iLCJjcmVhdGVTcGFuRm9yUnVuIiwiZ2V0IiwiaWQiLCJlbmRfdGltZSIsInNwYW5zIiwic2V0IiwidXBkYXRlU3BhbkZvclJ1biIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJydW5JbmZvIiwib3RlbENvbnRleHQiLCJhY3RpdmVTcGFuIiwiZ2V0U3BhbiIsImZpbmlzaFNwYW5TZXR1cCIsInVuZGVmaW5lZCIsInNldFNwYW5BdHRyaWJ1dGVzIiwic2V0U3RhdHVzIiwiY29kZSIsInJlY29yZEV4Y2VwdGlvbiIsIkVycm9yIiwiZW5kIiwiRGF0ZSIsImRlYnVnIiwiZW5kVGltZSIsImRlbGV0ZSIsImV4dHJhY3RNb2RlbE5hbWUiLCJleHRyYSIsIm1ldGFkYXRhIiwibHNfbW9kZWxfbmFtZSIsImludm9jYXRpb25fcGFyYW1zIiwiaW52b2NhdGlvblBhcmFtcyIsIm1vZGVsIiwibW9kZWxfbmFtZSIsInJ1bl90eXBlIiwic2V0QXR0cmlidXRlIiwiTEFOR1NNSVRIX1JVTl9UWVBFIiwib3BlcmF0aW9uTmFtZSIsIkdFTl9BSV9PUEVSQVRJT05fTkFNRSIsIm5hbWUiLCJMQU5HU01JVEhfTkFNRSIsInNlc3Npb25faWQiLCJMQU5HU01JVEhfU0VTU0lPTl9JRCIsInNlc3Npb25fbmFtZSIsIkxBTkdTTUlUSF9TRVNTSU9OX05BTUUiLCJzZXRHZW5BaVN5c3RlbSIsIm1vZGVsTmFtZSIsIkdFTl9BSV9SRVFVRVNUX01PREVMIiwicHJvbXB0X3Rva2VucyIsIkdFTl9BSV9VU0FHRV9JTlBVVF9UT0tFTlMiLCJjb21wbGV0aW9uX3Rva2VucyIsIkdFTl9BSV9VU0FHRV9PVVRQVVRfVE9LRU5TIiwidG90YWxfdG9rZW5zIiwiR0VOX0FJX1VTQUdFX1RPVEFMX1RPS0VOUyIsInNldEludm9jYXRpb25QYXJhbWV0ZXJzIiwia2V5IiwiZW50cmllcyIsIkxBTkdTTUlUSF9NRVRBREFUQSIsIlN0cmluZyIsInRhZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJMQU5HU01JVEhfVEFHUyIsImpvaW4iLCJzZXJpYWxpemVkIiwiR0VOX0FJX1NFUklBTElaRURfTkFNRSIsInNpZ25hdHVyZSIsIkdFTl9BSV9TRVJJQUxJWkVEX1NJR05BVFVSRSIsImRvYyIsIkdFTl9BSV9TRVJJQUxJWkVEX0RPQyIsInNldElPQXR0cmlidXRlcyIsInN5c3RlbSIsIm1vZGVsTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic3RhcnRzV2l0aCIsIkdFTl9BSV9TWVNURU0iLCJtYXhfdG9rZW5zIiwiR0VOX0FJX1JFUVVFU1RfTUFYX1RPS0VOUyIsInRlbXBlcmF0dXJlIiwiR0VOX0FJX1JFUVVFU1RfVEVNUEVSQVRVUkUiLCJ0b3BfcCIsIkdFTl9BSV9SRVFVRVNUX1RPUF9QIiwiZnJlcXVlbmN5X3BlbmFsdHkiLCJHRU5fQUlfUkVRVUVTVF9GUkVRVUVOQ1lfUEVOQUxUWSIsInByZXNlbmNlX3BlbmFsdHkiLCJHRU5fQUlfUkVRVUVTVF9QUkVTRU5DRV9QRU5BTFRZIiwiaW5wdXRzIiwibWVzc2FnZXMiLCJzdHJlYW0iLCJMQU5HU01JVEhfUkVRVUVTVF9TVFJFQU1JTkciLCJleHRyYV9oZWFkZXJzIiwiTEFOR1NNSVRIX1JFUVVFU1RfSEVBREVSUyIsIkpTT04iLCJzdHJpbmdpZnkiLCJleHRyYV9xdWVyeSIsIkdFTl9BSV9SRVFVRVNUX0VYVFJBX1FVRVJZIiwiZXh0cmFfYm9keSIsIkdFTl9BSV9SRVFVRVNUX0VYVFJBX0JPRFkiLCJHRU5BSV9QUk9NUFQiLCJvdXRwdXRzIiwidG9rZW5Vc2FnZSIsImdldFVuaWZpZWRSdW5Ub2tlbnMiLCJHRU5fQUlfUkVTUE9OU0VfTU9ERUwiLCJHRU5fQUlfUkVTUE9OU0VfSUQiLCJjaG9pY2VzIiwiZmluaXNoUmVhc29ucyIsIm1hcCIsImNob2ljZSIsImZpbmlzaF9yZWFzb24iLCJmaWx0ZXIiLCJyZWFzb24iLCJsZW5ndGgiLCJHRU5fQUlfUkVTUE9OU0VfRklOSVNIX1JFQVNPTlMiLCJzZXJ2aWNlX3RpZXIiLCJHRU5fQUlfUkVTUE9OU0VfU0VSVklDRV9USUVSIiwic3lzdGVtX2ZpbmdlcnByaW50IiwiR0VOX0FJX1JFU1BPTlNFX1NZU1RFTV9GSU5HRVJQUklOVCIsInVzYWdlX21ldGFkYXRhIiwidXNhZ2VNZXRhZGF0YSIsImlucHV0X3Rva2VuX2RldGFpbHMiLCJHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5fREVUQUlMUyIsIm91dHB1dF90b2tlbl9kZXRhaWxzIiwiR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTl9ERVRBSUxTIiwiR0VOQUlfQ09NUExFVElPTiIsImV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zIiwia2V5cyIsImhheXN0YWNrIiwibGMiLCJrd2FyZ3MiLCJnZW5lcmF0aW9ucyIsImZsYXRHZW5lcmF0aW9ucyIsImZsYXQiLCJnZW5lcmF0aW9uIiwibWVzc2FnZSIsImlucHV0X3Rva2VucyIsIm91dHB1dF90b2tlbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/experimental/otel/translator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__),\n/* harmony export */   getDefaultProjectName: () => (/* reexport safe */ _utils_project_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultProjectName),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__.overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_project_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/project.js */ \"(rsc)/./node_modules/langsmith/dist/utils/project.js\");\n\n\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.3.58\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ0c7QUFDMkI7QUFDVDtBQUMzRCxpQ0FBaUM7QUFDMUIsTUFBTUksY0FBYyxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L2luZGV4LmpzP2FhMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQ2xpZW50LCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuZXhwb3J0IHsgUnVuVHJlZSB9IGZyb20gXCIuL3J1bl90cmVlcy5qc1wiO1xuZXhwb3J0IHsgb3ZlcnJpZGVGZXRjaEltcGxlbWVudGF0aW9uIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuZXhwb3J0IHsgZ2V0RGVmYXVsdFByb2plY3ROYW1lIH0gZnJvbSBcIi4vdXRpbHMvcHJvamVjdC5qc1wiO1xuLy8gVXBkYXRlIHVzaW5nIHlhcm4gYnVtcC12ZXJzaW9uXG5leHBvcnQgY29uc3QgX192ZXJzaW9uX18gPSBcIjAuMy41OFwiO1xuIl0sIm5hbWVzIjpbIkNsaWVudCIsIlJ1blRyZWUiLCJvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24iLCJnZXREZWZhdWx0UHJvamVjdE5hbWUiLCJfX3ZlcnNpb25fXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* binding */ isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/langsmith/dist/env.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/error.js */ \"(rsc)/./node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./singletons/constants.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/constants.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _utils_project_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/project.js */ \"(rsc)/./node_modules/langsmith/dist/utils/project.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n\n\n\n\n\n\n\n\n\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {\n    // Date only has millisecond precision, so we use the microseconds to break\n    // possible ties, avoiding incorrect run order\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    const microsecondPrecisionDatestring = `${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`;\n    return {\n        dottedOrder: stripNonAlphanumeric(microsecondPrecisionDatestring) + runId,\n        microsecondPrecisionDatestring\n    };\n}\n/**\n * Baggage header information\n */ class Baggage {\n    constructor(metadata, tags, project_name, replicas){\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.metadata = metadata;\n        this.tags = tags;\n        this.project_name = project_name;\n        this.replicas = replicas;\n    }\n    static fromHeader(value) {\n        const items = value.split(\",\");\n        let metadata = {};\n        let tags = [];\n        let project_name;\n        let replicas;\n        for (const item of items){\n            const [key, uriValue] = item.split(\"=\");\n            const value = decodeURIComponent(uriValue);\n            if (key === \"langsmith-metadata\") {\n                metadata = JSON.parse(value);\n            } else if (key === \"langsmith-tags\") {\n                tags = value.split(\",\");\n            } else if (key === \"langsmith-project\") {\n                project_name = value;\n            } else if (key === \"langsmith-replicas\") {\n                replicas = JSON.parse(value);\n            }\n        }\n        return new Baggage(metadata, tags, project_name, replicas);\n    }\n    toHeader() {\n        const items = [];\n        if (this.metadata && Object.keys(this.metadata).length > 0) {\n            items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);\n        }\n        if (this.tags && this.tags.length > 0) {\n            items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(\",\"))}`);\n        }\n        if (this.project_name) {\n            items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);\n        }\n        return items.join(\",\");\n    }\n}\nclass RunTree {\n    constructor(originalConfig){\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingEnabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Attachments associated with the run.\n         * Each entry is a tuple of [mime_type, bytes]\n         */ Object.defineProperty(this, \"attachments\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Projects to replicate this run to with optional updates.\n         */ Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_serialized_start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If you pass in a run tree directly, return a shallow clone\n        if (isRunTree(originalConfig)) {\n            Object.assign(this, {\n                ...originalConfig\n            });\n            return;\n        }\n        const defaultConfig = RunTree.getDefaultConfig();\n        const { metadata, ...config } = originalConfig;\n        const client = config.client ?? RunTree.getSharedClient();\n        const dedupedMetadata = {\n            ...metadata,\n            ...config?.extra?.metadata\n        };\n        config.extra = {\n            ...config.extra,\n            metadata: dedupedMetadata\n        };\n        Object.assign(this, {\n            ...defaultConfig,\n            ...config,\n            client\n        });\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            } else {\n                this.trace_id = this.id;\n            }\n        }\n        this.replicas = _ensureWriteReplicas(this.replicas);\n        this.execution_order ??= 1;\n        this.child_execution_order ??= 1;\n        if (!this.dotted_order) {\n            const { dottedOrder, microsecondPrecisionDatestring } = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + dottedOrder;\n            } else {\n                this.dotted_order = dottedOrder;\n            }\n            this._serialized_start_time = microsecondPrecisionDatestring;\n        }\n    }\n    set metadata(metadata) {\n        this.extra = {\n            ...this.extra,\n            metadata: {\n                ...this.extra?.metadata,\n                ...metadata\n            }\n        };\n    }\n    get metadata() {\n        return this.extra?.metadata;\n    }\n    static getDefaultConfig() {\n        return {\n            id: uuid__WEBPACK_IMPORTED_MODULE_7__[\"default\"](),\n            run_type: \"chain\",\n            project_name: (0,_utils_project_js__WEBPACK_IMPORTED_MODULE_5__.getDefaultProjectName)(),\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time: Date.now(),\n            serialized: {},\n            inputs: {},\n            extra: {}\n        };\n    }\n    static getSharedClient() {\n        if (!RunTree.sharedClient) {\n            RunTree.sharedClient = new _client_js__WEBPACK_IMPORTED_MODULE_0__.Client();\n        }\n        return RunTree.sharedClient;\n    }\n    createChild(config) {\n        const child_execution_order = this.child_execution_order + 1;\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            replicas: this.replicas,\n            client: this.client,\n            tracingEnabled: this.tracingEnabled,\n            execution_order: child_execution_order,\n            child_execution_order: child_execution_order\n        });\n        // Copy context vars over into the new run tree.\n        if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY in this) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            child[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY] = this[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY];\n        }\n        const LC_CHILD = Symbol.for(\"lc:child_config\");\n        const presentConfig = config.extra?.[LC_CHILD] ?? this.extra[LC_CHILD];\n        // tracing for LangChain is defined by the _parentRunId and runMap of the tracer\n        if (isRunnableConfigLike(presentConfig)) {\n            const newConfig = {\n                ...presentConfig\n            };\n            const callbacks = isCallbackManagerLike(newConfig.callbacks) ? newConfig.callbacks.copy?.() : undefined;\n            if (callbacks) {\n                // update the parent run id\n                Object.assign(callbacks, {\n                    _parentRunId: child.id\n                });\n                // only populate if we're in a newer LC.JS version\n                callbacks.handlers?.find(isLangChainTracerLike)?.updateFromRunTree?.(child);\n                newConfig.callbacks = callbacks;\n            }\n            child.extra[LC_CHILD] = newConfig;\n        }\n        // propagate child_execution_order upwards\n        const visited = new Set();\n        let current = this;\n        while(current != null && !visited.has(current.id)){\n            visited.add(current.id);\n            current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);\n            current = current.parent_run;\n        }\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now(), metadata) {\n        this.outputs = this.outputs ?? outputs;\n        this.error = this.error ?? error;\n        this.end_time = this.end_time ?? endTime;\n        if (metadata && Object.keys(metadata).length > 0) {\n            this.extra = this.extra ? {\n                ...this.extra,\n                metadata: {\n                    ...this.extra.metadata,\n                    ...metadata\n                }\n            } : {\n                metadata\n            };\n        }\n    }\n    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        // Avoid overwriting the runtime environment if it's already set\n        if (runExtra?.runtime?.library === undefined) {\n            if (!runExtra.runtime) {\n                runExtra.runtime = {};\n            }\n            if (runtimeEnv) {\n                for (const [k, v] of Object.entries(runtimeEnv)){\n                    if (!runExtra.runtime[k]) {\n                        runExtra.runtime[k] = v;\n                    }\n                }\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = run.child_runs.map((child_run)=>this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));\n            parent_run_id = undefined;\n        } else {\n            parent_run_id = run.parent_run?.id ?? run.parent_run_id;\n            child_runs = [];\n        }\n        return {\n            id: run.id,\n            name: run.name,\n            start_time: run._serialized_start_time ?? run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags,\n            attachments: run.attachments,\n            events: run.events\n        };\n    }\n    _remapForProject(projectName, runtimeEnv, excludeChildRuns = true) {\n        const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n        if (projectName === this.project_name) {\n            return baseRun;\n        }\n        // Create a deterministic UUID mapping for this project\n        const createRemappedId = (originalId)=>{\n            return uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"](`${originalId}:${projectName}`, uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"].DNS);\n        };\n        // Remap the current run's ID\n        const newId = createRemappedId(baseRun.id);\n        const newTraceId = baseRun.trace_id ? createRemappedId(baseRun.trace_id) : undefined;\n        const newParentRunId = baseRun.parent_run_id ? createRemappedId(baseRun.parent_run_id) : undefined;\n        let newDottedOrder;\n        if (baseRun.dotted_order) {\n            const segments = _parseDottedOrder(baseRun.dotted_order);\n            const rebuilt = [];\n            // Process all segments except the last one\n            for(let i = 0; i < segments.length - 1; i++){\n                const [timestamp, segmentId] = segments[i];\n                const remappedId = createRemappedId(segmentId);\n                rebuilt.push(timestamp.toISOString().replace(/[-:]/g, \"\").replace(\".\", \"\") + remappedId);\n            }\n            // Process the last segment with the new run ID\n            const [lastTimestamp] = segments[segments.length - 1];\n            rebuilt.push(lastTimestamp.toISOString().replace(/[-:]/g, \"\").replace(\".\", \"\") + newId);\n            newDottedOrder = rebuilt.join(\".\");\n        } else {\n            newDottedOrder = undefined;\n        }\n        const remappedRun = {\n            ...baseRun,\n            id: newId,\n            trace_id: newTraceId,\n            parent_run_id: newParentRunId,\n            dotted_order: newDottedOrder,\n            session_name: projectName\n        };\n        return remappedRun;\n    }\n    async postRun(excludeChildRuns = true) {\n        try {\n            const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getRuntimeEnvironment)();\n            if (this.replicas && this.replicas.length > 0) {\n                for (const { projectName, apiKey, apiUrl } of this.replicas){\n                    const runCreate = this._remapForProject(projectName ?? this.project_name, runtimeEnv, true);\n                    await this.client.createRun(runCreate, {\n                        apiKey,\n                        apiUrl\n                    });\n                }\n            } else {\n                const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n                await this.client.createRun(runCreate);\n            }\n            if (!excludeChildRuns) {\n                (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_6__.warnOnce)(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n                for (const childRun of this.child_runs){\n                    await childRun.postRun(false);\n                }\n            }\n        } catch (error) {\n            console.error(`Error in postRun for run ${this.id}:`, error);\n        }\n    }\n    async patchRun() {\n        if (this.replicas && this.replicas.length > 0) {\n            for (const { projectName, apiKey, apiUrl, updates } of this.replicas){\n                const runData = this._remapForProject(projectName ?? this.project_name);\n                await this.client.updateRun(runData.id, {\n                    inputs: runData.inputs,\n                    outputs: runData.outputs,\n                    error: runData.error,\n                    parent_run_id: runData.parent_run_id,\n                    session_name: runData.session_name,\n                    reference_example_id: runData.reference_example_id,\n                    end_time: runData.end_time,\n                    dotted_order: runData.dotted_order,\n                    trace_id: runData.trace_id,\n                    events: runData.events,\n                    tags: runData.tags,\n                    extra: runData.extra,\n                    attachments: this.attachments,\n                    ...updates\n                }, {\n                    apiKey,\n                    apiUrl\n                });\n            }\n        } else {\n            try {\n                const runUpdate = {\n                    end_time: this.end_time,\n                    error: this.error,\n                    inputs: this.inputs,\n                    outputs: this.outputs,\n                    parent_run_id: this.parent_run?.id ?? this.parent_run_id,\n                    reference_example_id: this.reference_example_id,\n                    extra: this.extra,\n                    events: this.events,\n                    dotted_order: this.dotted_order,\n                    trace_id: this.trace_id,\n                    tags: this.tags,\n                    attachments: this.attachments,\n                    session_name: this.project_name\n                };\n                await this.client.updateRun(this.id, runUpdate);\n            } catch (error) {\n                console.error(`Error in patchRun for run ${this.id}`, error);\n            }\n        }\n    }\n    toJSON() {\n        return this._convertToCreate(this, undefined, false);\n    }\n    /**\n     * Add an event to the run tree.\n     * @param event - A single event or string to add\n     */ addEvent(event) {\n        if (!this.events) {\n            this.events = [];\n        }\n        if (typeof event === \"string\") {\n            this.events.push({\n                name: \"event\",\n                time: new Date().toISOString(),\n                message: event\n            });\n        } else {\n            this.events.push({\n                ...event,\n                time: event.time ?? new Date().toISOString()\n            });\n        }\n    }\n    static fromRunnableConfig(parentConfig, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = parentConfig?.callbacks;\n        let parentRun;\n        let projectName;\n        let client;\n        let tracingEnabled = (0,_env_js__WEBPACK_IMPORTED_MODULE_1__.isTracingEnabled)();\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler)=>handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n            client = langChainTracer?.client;\n            tracingEnabled = tracingEnabled || !!langChainTracer;\n        }\n        if (!parentRun) {\n            return new RunTree({\n                ...props,\n                client,\n                tracingEnabled,\n                project_name: projectName\n            });\n        }\n        const parentRunTree = new RunTree({\n            name: parentRun.name,\n            id: parentRun.id,\n            trace_id: parentRun.trace_id,\n            dotted_order: parentRun.dotted_order,\n            client,\n            tracingEnabled,\n            project_name: projectName,\n            tags: [\n                ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? []))\n            ],\n            extra: {\n                metadata: {\n                    ...parentRun?.extra?.metadata,\n                    ...parentConfig?.metadata\n                }\n            }\n        });\n        return parentRunTree.createChild(props);\n    }\n    static fromDottedOrder(dottedOrder) {\n        return this.fromHeaders({\n            \"langsmith-trace\": dottedOrder\n        });\n    }\n    static fromHeaders(headers, inheritArgs) {\n        const rawHeaders = \"get\" in headers && typeof headers.get === \"function\" ? {\n            \"langsmith-trace\": headers.get(\"langsmith-trace\"),\n            baggage: headers.get(\"baggage\")\n        } : headers;\n        const headerTrace = rawHeaders[\"langsmith-trace\"];\n        if (!headerTrace || typeof headerTrace !== \"string\") return undefined;\n        const parentDottedOrder = headerTrace.trim();\n        const parsedDottedOrder = parentDottedOrder.split(\".\").map((part)=>{\n            const [strTime, uuid] = part.split(\"Z\");\n            return {\n                strTime,\n                time: Date.parse(strTime + \"Z\"),\n                uuid\n            };\n        });\n        const traceId = parsedDottedOrder[0].uuid;\n        const config = {\n            ...inheritArgs,\n            name: inheritArgs?.[\"name\"] ?? \"parent\",\n            run_type: inheritArgs?.[\"run_type\"] ?? \"chain\",\n            start_time: inheritArgs?.[\"start_time\"] ?? Date.now(),\n            id: parsedDottedOrder.at(-1)?.uuid,\n            trace_id: traceId,\n            dotted_order: parentDottedOrder\n        };\n        if (rawHeaders[\"baggage\"] && typeof rawHeaders[\"baggage\"] === \"string\") {\n            const baggage = Baggage.fromHeader(rawHeaders[\"baggage\"]);\n            config.metadata = baggage.metadata;\n            config.tags = baggage.tags;\n            config.project_name = baggage.project_name;\n            config.replicas = baggage.replicas;\n        }\n        return new RunTree(config);\n    }\n    toHeaders(headers) {\n        const result = {\n            \"langsmith-trace\": this.dotted_order,\n            baggage: new Baggage(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader()\n        };\n        if (headers) {\n            for (const [key, value] of Object.entries(result)){\n                headers.set(key, value);\n            }\n        }\n        return result;\n    }\n}\nObject.defineProperty(RunTree, \"sharedClient\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: null\n});\nfunction isRunTree(x) {\n    return x !== undefined && typeof x.createChild === \"function\" && typeof x.postRun === \"function\";\n}\nfunction isLangChainTracerLike(x) {\n    return typeof x === \"object\" && x != null && typeof x.name === \"string\" && x.name === \"langchain_tracer\";\n}\nfunction containsLangChainTracerLike(x) {\n    return Array.isArray(x) && x.some((callback)=>isLangChainTracerLike(callback));\n}\nfunction isCallbackManagerLike(x) {\n    return typeof x === \"object\" && x != null && Array.isArray(x.handlers);\n}\nfunction isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    return x !== undefined && typeof x.callbacks === \"object\" && // Callback manager with a langchain tracer\n    (containsLangChainTracerLike(x.callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it\n    containsLangChainTracerLike(x.callbacks));\n}\nfunction _parseDottedOrder(dottedOrder) {\n    const parts = dottedOrder.split(\".\");\n    return parts.map((part)=>{\n        const timestampStr = part.slice(0, -36);\n        const uuidStr = part.slice(-36);\n        // Parse timestamp: \"%Y%m%dT%H%M%S%fZ\" format\n        // Example: \"20231215T143045123456Z\"\n        const year = parseInt(timestampStr.slice(0, 4));\n        const month = parseInt(timestampStr.slice(4, 6)) - 1; // JS months are 0-indexed\n        const day = parseInt(timestampStr.slice(6, 8));\n        const hour = parseInt(timestampStr.slice(9, 11));\n        const minute = parseInt(timestampStr.slice(11, 13));\n        const second = parseInt(timestampStr.slice(13, 15));\n        const microsecond = parseInt(timestampStr.slice(15, 21));\n        const timestamp = new Date(year, month, day, hour, minute, second, microsecond / 1000);\n        return [\n            timestamp,\n            uuidStr\n        ];\n    });\n}\nfunction _getWriteReplicasFromEnv() {\n    const envVar = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGSMITH_RUNS_ENDPOINTS\");\n    if (!envVar) return [];\n    try {\n        const parsed = JSON.parse(envVar);\n        if (Array.isArray(parsed)) {\n            const replicas = [];\n            for (const item of parsed){\n                if (typeof item !== \"object\" || item === null) {\n                    console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: ` + `expected object, got ${typeof item}`);\n                    continue;\n                }\n                if (typeof item.api_url !== \"string\") {\n                    console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: ` + `expected string, got ${typeof item.api_url}`);\n                    continue;\n                }\n                if (typeof item.api_key !== \"string\") {\n                    console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: ` + `expected string, got ${typeof item.api_key}`);\n                    continue;\n                }\n                replicas.push({\n                    apiUrl: item.api_url.replace(/\\/$/, \"\"),\n                    apiKey: item.api_key\n                });\n            }\n            return replicas;\n        } else if (typeof parsed === \"object\" && parsed !== null) {\n            _checkEndpointEnvUnset(parsed);\n            const replicas = [];\n            for (const [url, key] of Object.entries(parsed)){\n                const cleanUrl = url.replace(/\\/$/, \"\");\n                if (typeof key === \"string\") {\n                    replicas.push({\n                        apiUrl: cleanUrl,\n                        apiKey: key\n                    });\n                } else {\n                    console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${url}: ` + `expected string, got ${typeof key}`);\n                    continue;\n                }\n            }\n            return replicas;\n        } else {\n            console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS – must be valid JSON array of \" + `objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof parsed}`);\n            return [];\n        }\n    } catch (e) {\n        if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_2__.isConflictingEndpointsError)(e)) {\n            throw e;\n        }\n        console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS – must be valid JSON array of \" + \"objects with api_url and api_key properties, or object mapping url->apiKey\");\n        return [];\n    }\n}\nfunction _ensureWriteReplicas(replicas) {\n    // If null -> fetch from env\n    if (replicas) {\n        return replicas.map((replica)=>{\n            if (Array.isArray(replica)) {\n                return {\n                    projectName: replica[0],\n                    updates: replica[1]\n                };\n            }\n            return replica;\n        });\n    }\n    return _getWriteReplicasFromEnv();\n}\nfunction _checkEndpointEnvUnset(parsed) {\n    if (Object.keys(parsed).length > 0 && (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"ENDPOINT\")) {\n        throw new _utils_error_js__WEBPACK_IMPORTED_MODULE_2__.ConflictingEndpointsError();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkI7QUFDUTtBQUNPO0FBQytDO0FBQ3JCO0FBQ1U7QUFDckI7QUFDTTtBQUN0QjtBQUMzQyxTQUFTVyxxQkFBcUJDLEtBQUs7SUFDL0IsT0FBT0EsTUFBTUMsT0FBTyxDQUFDLFVBQVU7QUFDbkM7QUFDTyxTQUFTQywyQkFBMkJDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxpQkFBaUIsQ0FBQztJQUN2RSwyRUFBMkU7SUFDM0UsOENBQThDO0lBQzlDLE1BQU1DLGNBQWNELGVBQWVFLE9BQU8sQ0FBQyxHQUFHQyxLQUFLLENBQUMsR0FBRyxHQUFHQyxRQUFRLENBQUMsR0FBRztJQUN0RSxNQUFNQyxpQ0FBaUMsQ0FBQyxFQUFFLElBQUlDLEtBQUtSLE9BQzlDUyxXQUFXLEdBQ1hKLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFRixZQUFZLENBQUMsQ0FBQztJQUNsQyxPQUFPO1FBQ0hPLGFBQWFkLHFCQUFxQlcsa0NBQWtDTjtRQUNwRU07SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNSTtJQUNGQyxZQUFZQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsWUFBWSxFQUFFQyxRQUFRLENBQUU7UUFDaERDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsWUFBWTtZQUNwQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCO1lBQ3hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0Ms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QUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYztZQUN0Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYztZQUN0Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsWUFBWTtZQUNwQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsU0FBUztZQUNqQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsU0FBUztZQUNqQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYztZQUN0Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBVTtZQUNsQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBVztZQUNuQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJ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Q04sSUFBSTVOLDRFQUEyQkEsQ0FBQzROLElBQUk7WUFDaEMsTUFBTUE7UUFDVjtRQUNBakUsUUFBUTZELElBQUksQ0FBQyxvRUFDVDtRQUNKLE9BQU8sRUFBRTtJQUNiO0FBQ0o7QUFDQSxTQUFTdkoscUJBQXFCckMsUUFBUTtJQUNsQyw0QkFBNEI7SUFDNUIsSUFBSUEsVUFBVTtRQUNWLE9BQU9BLFNBQVM4RixHQUFHLENBQUMsQ0FBQ21HO1lBQ2pCLElBQUl2QixNQUFNQyxPQUFPLENBQUNzQixVQUFVO2dCQUN4QixPQUFPO29CQUNIM0YsYUFBYTJGLE9BQU8sQ0FBQyxFQUFFO29CQUN2QmhFLFNBQVNnRSxPQUFPLENBQUMsRUFBRTtnQkFDdkI7WUFDSjtZQUNBLE9BQU9BO1FBQ1g7SUFDSjtJQUNBLE9BQU9SO0FBQ1g7QUFDQSxTQUFTSSx1QkFBdUJGLE1BQU07SUFDbEMsSUFBSTFMLE9BQU9nQixJQUFJLENBQUMwSyxRQUFRekssTUFBTSxHQUFHLEtBQzdCeEMsOEVBQStCQSxDQUFDLGFBQWE7UUFDN0MsTUFBTSxJQUFJTCxzRUFBeUJBO0lBQ3ZDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzPzUxMmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5pbXBvcnQgeyBpc1RyYWNpbmdFbmFibGVkIH0gZnJvbSBcIi4vZW52LmpzXCI7XG5pbXBvcnQgeyBpc0NvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IsIENvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IsIH0gZnJvbSBcIi4vdXRpbHMvZXJyb3IuanNcIjtcbmltcG9ydCB7IF9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkgfSBmcm9tIFwiLi9zaW5nbGV0b25zL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0UnVudGltZUVudmlyb25tZW50LCB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFByb2plY3ROYW1lIH0gZnJvbSBcIi4vdXRpbHMvcHJvamVjdC5qc1wiO1xuaW1wb3J0IHsgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tIFwiLi91dGlscy93YXJuLmpzXCI7XG5mdW5jdGlvbiBzdHJpcE5vbkFscGhhbnVtZXJpYyhpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bLTouXS9nLCBcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQsIGV4ZWN1dGlvbk9yZGVyID0gMSkge1xuICAgIC8vIERhdGUgb25seSBoYXMgbWlsbGlzZWNvbmQgcHJlY2lzaW9uLCBzbyB3ZSB1c2UgdGhlIG1pY3Jvc2Vjb25kcyB0byBicmVha1xuICAgIC8vIHBvc3NpYmxlIHRpZXMsIGF2b2lkaW5nIGluY29ycmVjdCBydW4gb3JkZXJcbiAgICBjb25zdCBwYWRkZWRPcmRlciA9IGV4ZWN1dGlvbk9yZGVyLnRvRml4ZWQoMCkuc2xpY2UoMCwgMykucGFkU3RhcnQoMywgXCIwXCIpO1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyA9IGAke25ldyBEYXRlKGVwb2NoKVxuICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAuc2xpY2UoMCwgLTEpfSR7cGFkZGVkT3JkZXJ9WmA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZG90dGVkT3JkZXI6IHN0cmlwTm9uQWxwaGFudW1lcmljKG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZykgKyBydW5JZCxcbiAgICAgICAgbWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nLFxuICAgIH07XG59XG4vKipcbiAqIEJhZ2dhZ2UgaGVhZGVyIGluZm9ybWF0aW9uXG4gKi9cbmNsYXNzIEJhZ2dhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhLCB0YWdzLCBwcm9qZWN0X25hbWUsIHJlcGxpY2FzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvamVjdF9uYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGxpY2FzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5wcm9qZWN0X25hbWUgPSBwcm9qZWN0X25hbWU7XG4gICAgICAgIHRoaXMucmVwbGljYXMgPSByZXBsaWNhcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZWFkZXIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICBsZXQgdGFncyA9IFtdO1xuICAgICAgICBsZXQgcHJvamVjdF9uYW1lO1xuICAgICAgICBsZXQgcmVwbGljYXM7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdXJpVmFsdWVdID0gaXRlbS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmlWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC1tZXRhZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJsYW5nc21pdGgtdGFnc1wiKSB7XG4gICAgICAgICAgICAgICAgdGFncyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJsYW5nc21pdGgtcHJvamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdF9uYW1lID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwibGFuZ3NtaXRoLXJlcGxpY2FzXCIpIHtcbiAgICAgICAgICAgICAgICByZXBsaWNhcyA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmFnZ2FnZShtZXRhZGF0YSwgdGFncywgcHJvamVjdF9uYW1lLCByZXBsaWNhcyk7XG4gICAgfVxuICAgIHRvSGVhZGVyKCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSAmJiBPYmplY3Qua2V5cyh0aGlzLm1ldGFkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBsYW5nc21pdGgtbWV0YWRhdGE9JHtlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkodGhpcy5tZXRhZGF0YSkpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRhZ3MgJiYgdGhpcy50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYGxhbmdzbWl0aC10YWdzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudGFncy5qb2luKFwiLFwiKSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdF9uYW1lKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBsYW5nc21pdGgtcHJvamVjdD0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLnByb2plY3RfbmFtZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zLmpvaW4oXCIsXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5UcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbENvbmZpZykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bl90eXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3RfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJlbnRfcnVuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcmVudF9ydW5faWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hpbGRfcnVuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFydF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuZF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4dHJhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VyaWFsaXplZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZlcmVuY2VfZXhhbXBsZV9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNlX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvdHRlZF9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjaW5nRW5hYmxlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGVjdXRpb25fb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hpbGRfZXhlY3V0aW9uX29yZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2htZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1bi5cbiAgICAgICAgICogRWFjaCBlbnRyeSBpcyBhIHR1cGxlIG9mIFttaW1lX3R5cGUsIGJ5dGVzXVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXR0YWNobWVudHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2plY3RzIHRvIHJlcGxpY2F0ZSB0aGlzIHJ1biB0byB3aXRoIG9wdGlvbmFsIHVwZGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXBsaWNhc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2VyaWFsaXplZF9zdGFydF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHlvdSBwYXNzIGluIGEgcnVuIHRyZWUgZGlyZWN0bHksIHJldHVybiBhIHNoYWxsb3cgY2xvbmVcbiAgICAgICAgaWYgKGlzUnVuVHJlZShvcmlnaW5hbENvbmZpZykpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyAuLi5vcmlnaW5hbENvbmZpZyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gUnVuVHJlZS5nZXREZWZhdWx0Q29uZmlnKCk7XG4gICAgICAgIGNvbnN0IHsgbWV0YWRhdGEsIC4uLmNvbmZpZyB9ID0gb3JpZ2luYWxDb25maWc7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGNvbmZpZy5jbGllbnQgPz8gUnVuVHJlZS5nZXRTaGFyZWRDbGllbnQoKTtcbiAgICAgICAgY29uc3QgZGVkdXBlZE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5jb25maWc/LmV4dHJhPy5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlnLmV4dHJhID0geyAuLi5jb25maWcuZXh0cmEsIG1ldGFkYXRhOiBkZWR1cGVkTWV0YWRhdGEgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IC4uLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZywgY2xpZW50IH0pO1xuICAgICAgICBpZiAoIXRoaXMudHJhY2VfaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudF9ydW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlX2lkID0gdGhpcy5wYXJlbnRfcnVuLnRyYWNlX2lkID8/IHRoaXMuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlX2lkID0gdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGxpY2FzID0gX2Vuc3VyZVdyaXRlUmVwbGljYXModGhpcy5yZXBsaWNhcyk7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uX29yZGVyID8/PSAxO1xuICAgICAgICB0aGlzLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA/Pz0gMTtcbiAgICAgICAgaWYgKCF0aGlzLmRvdHRlZF9vcmRlcikge1xuICAgICAgICAgICAgY29uc3QgeyBkb3R0ZWRPcmRlciwgbWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nIH0gPSBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdCh0aGlzLnN0YXJ0X3RpbWUsIHRoaXMuaWQsIHRoaXMuZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudF9ydW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdHRlZF9vcmRlciA9IHRoaXMucGFyZW50X3J1bi5kb3R0ZWRfb3JkZXIgKyBcIi5cIiArIGRvdHRlZE9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3R0ZWRfb3JkZXIgPSBkb3R0ZWRPcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NlcmlhbGl6ZWRfc3RhcnRfdGltZSA9IG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgbWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5leHRyYSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuZXh0cmEsXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZXh0cmE/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYT8ubWV0YWRhdGE7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q29uZmlnKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcImNoYWluXCIsXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IGdldERlZmF1bHRQcm9qZWN0TmFtZSgpLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBhcGlfdXJsOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0VORFBPSU5UXCIpID8/IFwiaHR0cDovL2xvY2FsaG9zdDoxOTg0XCIsXG4gICAgICAgICAgICBhcGlfa2V5OiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIiksXG4gICAgICAgICAgICBjYWxsZXJfb3B0aW9uczoge30sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgc2VyaWFsaXplZDoge30sXG4gICAgICAgICAgICBpbnB1dHM6IHt9LFxuICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U2hhcmVkQ2xpZW50KCkge1xuICAgICAgICBpZiAoIVJ1blRyZWUuc2hhcmVkQ2xpZW50KSB7XG4gICAgICAgICAgICBSdW5UcmVlLnNoYXJlZENsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUnVuVHJlZS5zaGFyZWRDbGllbnQ7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkKGNvbmZpZykge1xuICAgICAgICBjb25zdCBjaGlsZF9leGVjdXRpb25fb3JkZXIgPSB0aGlzLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciArIDE7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogdGhpcyxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogdGhpcy5wcm9qZWN0X25hbWUsXG4gICAgICAgICAgICByZXBsaWNhczogdGhpcy5yZXBsaWNhcyxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZDogdGhpcy50cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogY2hpbGRfZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBjaGlsZF9leGVjdXRpb25fb3JkZXIsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb3B5IGNvbnRleHQgdmFycyBvdmVyIGludG8gdGhlIG5ldyBydW4gdHJlZS5cbiAgICAgICAgaWYgKF9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkgaW4gdGhpcykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNoaWxkW19MQ19DT05URVhUX1ZBUklBQkxFU19LRVldID1cbiAgICAgICAgICAgICAgICB0aGlzW19MQ19DT05URVhUX1ZBUklBQkxFU19LRVldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IExDX0NISUxEID0gU3ltYm9sLmZvcihcImxjOmNoaWxkX2NvbmZpZ1wiKTtcbiAgICAgICAgY29uc3QgcHJlc2VudENvbmZpZyA9IGNvbmZpZy5leHRyYT8uW0xDX0NISUxEXSA/P1xuICAgICAgICAgICAgdGhpcy5leHRyYVtMQ19DSElMRF07XG4gICAgICAgIC8vIHRyYWNpbmcgZm9yIExhbmdDaGFpbiBpcyBkZWZpbmVkIGJ5IHRoZSBfcGFyZW50UnVuSWQgYW5kIHJ1bk1hcCBvZiB0aGUgdHJhY2VyXG4gICAgICAgIGlmIChpc1J1bm5hYmxlQ29uZmlnTGlrZShwcmVzZW50Q29uZmlnKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29uZmlnID0geyAuLi5wcmVzZW50Q29uZmlnIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBpc0NhbGxiYWNrTWFuYWdlckxpa2UobmV3Q29uZmlnLmNhbGxiYWNrcylcbiAgICAgICAgICAgICAgICA/IG5ld0NvbmZpZy5jYWxsYmFja3MuY29weT8uKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhcmVudCBydW4gaWRcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNhbGxiYWNrcywgeyBfcGFyZW50UnVuSWQ6IGNoaWxkLmlkIH0pO1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgcG9wdWxhdGUgaWYgd2UncmUgaW4gYSBuZXdlciBMQy5KUyB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLmhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgID8uZmluZChpc0xhbmdDaGFpblRyYWNlckxpa2UpXG4gICAgICAgICAgICAgICAgICAgID8udXBkYXRlRnJvbVJ1blRyZWU/LihjaGlsZCk7XG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLmV4dHJhW0xDX0NISUxEXSA9IG5ld0NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wYWdhdGUgY2hpbGRfZXhlY3V0aW9uX29yZGVyIHVwd2FyZHNcbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50LmlkKSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoY3VycmVudC5pZCk7XG4gICAgICAgICAgICBjdXJyZW50LmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IE1hdGgubWF4KGN1cnJlbnQuY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBjaGlsZF9leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50X3J1bjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkX3J1bnMucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgYXN5bmMgZW5kKG91dHB1dHMsIGVycm9yLCBlbmRUaW1lID0gRGF0ZS5ub3coKSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gdGhpcy5vdXRwdXRzID8/IG91dHB1dHM7XG4gICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLmVycm9yID8/IGVycm9yO1xuICAgICAgICB0aGlzLmVuZF90aW1lID0gdGhpcy5lbmRfdGltZSA/PyBlbmRUaW1lO1xuICAgICAgICBpZiAobWV0YWRhdGEgJiYgT2JqZWN0LmtleXMobWV0YWRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmEgPSB0aGlzLmV4dHJhXG4gICAgICAgICAgICAgICAgPyB7IC4uLnRoaXMuZXh0cmEsIG1ldGFkYXRhOiB7IC4uLnRoaXMuZXh0cmEubWV0YWRhdGEsIC4uLm1ldGFkYXRhIH0gfVxuICAgICAgICAgICAgICAgIDogeyBtZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb252ZXJ0VG9DcmVhdGUocnVuLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBydW5FeHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICAgICAgLy8gQXZvaWQgb3ZlcndyaXRpbmcgdGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQgaWYgaXQncyBhbHJlYWR5IHNldFxuICAgICAgICBpZiAocnVuRXh0cmE/LnJ1bnRpbWU/LmxpYnJhcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFydW5FeHRyYS5ydW50aW1lKSB7XG4gICAgICAgICAgICAgICAgcnVuRXh0cmEucnVudGltZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bnRpbWVFbnYpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhydW50aW1lRW52KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWVba10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZF9ydW5zO1xuICAgICAgICBsZXQgcGFyZW50X3J1bl9pZDtcbiAgICAgICAgaWYgKCFleGNsdWRlQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBjaGlsZF9ydW5zID0gcnVuLmNoaWxkX3J1bnMubWFwKChjaGlsZF9ydW4pID0+IHRoaXMuX2NvbnZlcnRUb0NyZWF0ZShjaGlsZF9ydW4sIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMpKTtcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkID0gcnVuLnBhcmVudF9ydW4/LmlkID8/IHJ1bi5wYXJlbnRfcnVuX2lkO1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuLm5hbWUsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uX3NlcmlhbGl6ZWRfc3RhcnRfdGltZSA/PyBydW4uc3RhcnRfdGltZSxcbiAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bi5yZWZlcmVuY2VfZXhhbXBsZV9pZCxcbiAgICAgICAgICAgIGV4dHJhOiBydW5FeHRyYSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHJ1bi5zZXJpYWxpemVkLFxuICAgICAgICAgICAgZXJyb3I6IHJ1bi5lcnJvcixcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IHJ1bi5vdXRwdXRzLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiBydW4ucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogY2hpbGRfcnVucyxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudF9ydW5faWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MsXG4gICAgICAgICAgICBhdHRhY2htZW50czogcnVuLmF0dGFjaG1lbnRzLFxuICAgICAgICAgICAgZXZlbnRzOiBydW4uZXZlbnRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcmVtYXBGb3JQcm9qZWN0KHByb2plY3ROYW1lLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBiYXNlUnVuID0gdGhpcy5fY29udmVydFRvQ3JlYXRlKHRoaXMsIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMpO1xuICAgICAgICBpZiAocHJvamVjdE5hbWUgPT09IHRoaXMucHJvamVjdF9uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVJ1bjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBkZXRlcm1pbmlzdGljIFVVSUQgbWFwcGluZyBmb3IgdGhpcyBwcm9qZWN0XG4gICAgICAgIGNvbnN0IGNyZWF0ZVJlbWFwcGVkSWQgPSAob3JpZ2luYWxJZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHV1aWQudjUoYCR7b3JpZ2luYWxJZH06JHtwcm9qZWN0TmFtZX1gLCB1dWlkLnY1LkROUyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbWFwIHRoZSBjdXJyZW50IHJ1bidzIElEXG4gICAgICAgIGNvbnN0IG5ld0lkID0gY3JlYXRlUmVtYXBwZWRJZChiYXNlUnVuLmlkKTtcbiAgICAgICAgY29uc3QgbmV3VHJhY2VJZCA9IGJhc2VSdW4udHJhY2VfaWRcbiAgICAgICAgICAgID8gY3JlYXRlUmVtYXBwZWRJZChiYXNlUnVuLnRyYWNlX2lkKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG5ld1BhcmVudFJ1bklkID0gYmFzZVJ1bi5wYXJlbnRfcnVuX2lkXG4gICAgICAgICAgICA/IGNyZWF0ZVJlbWFwcGVkSWQoYmFzZVJ1bi5wYXJlbnRfcnVuX2lkKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBuZXdEb3R0ZWRPcmRlcjtcbiAgICAgICAgaWYgKGJhc2VSdW4uZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IF9wYXJzZURvdHRlZE9yZGVyKGJhc2VSdW4uZG90dGVkX29yZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYnVpbHQgPSBbXTtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYWxsIHNlZ21lbnRzIGV4Y2VwdCB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3RpbWVzdGFtcCwgc2VnbWVudElkXSA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFwcGVkSWQgPSBjcmVhdGVSZW1hcHBlZElkKHNlZ21lbnRJZCk7XG4gICAgICAgICAgICAgICAgcmVidWlsdC5wdXNoKHRpbWVzdGFtcC50b0lTT1N0cmluZygpLnJlcGxhY2UoL1stOl0vZywgXCJcIikucmVwbGFjZShcIi5cIiwgXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICByZW1hcHBlZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGxhc3Qgc2VnbWVudCB3aXRoIHRoZSBuZXcgcnVuIElEXG4gICAgICAgICAgICBjb25zdCBbbGFzdFRpbWVzdGFtcF0gPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJlYnVpbHQucHVzaChsYXN0VGltZXN0YW1wLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWy06XS9nLCBcIlwiKS5yZXBsYWNlKFwiLlwiLCBcIlwiKSArXG4gICAgICAgICAgICAgICAgbmV3SWQpO1xuICAgICAgICAgICAgbmV3RG90dGVkT3JkZXIgPSByZWJ1aWx0LmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RG90dGVkT3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtYXBwZWRSdW4gPSB7XG4gICAgICAgICAgICAuLi5iYXNlUnVuLFxuICAgICAgICAgICAgaWQ6IG5ld0lkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IG5ld1RyYWNlSWQsXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBuZXdQYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogbmV3RG90dGVkT3JkZXIsXG4gICAgICAgICAgICBzZXNzaW9uX25hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVtYXBwZWRSdW47XG4gICAgfVxuICAgIGFzeW5jIHBvc3RSdW4oZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcGxpY2FzICYmIHRoaXMucmVwbGljYXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBwcm9qZWN0TmFtZSwgYXBpS2V5LCBhcGlVcmwgfSBvZiB0aGlzLnJlcGxpY2FzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IHRoaXMuX3JlbWFwRm9yUHJvamVjdChwcm9qZWN0TmFtZSA/PyB0aGlzLnByb2plY3RfbmFtZSwgcnVudGltZUVudiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihydW5DcmVhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVuQ3JlYXRlID0gdGhpcy5fY29udmVydFRvQ3JlYXRlKHRoaXMsIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihydW5DcmVhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFleGNsdWRlQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UoXCJQb3N0aW5nIHdpdGggZXhjbHVkZUNoaWxkUnVucz1mYWxzZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiB0aGlzLmNoaWxkX3J1bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hpbGRSdW4ucG9zdFJ1bihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gcG9zdFJ1biBmb3IgcnVuICR7dGhpcy5pZH06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdGNoUnVuKCkge1xuICAgICAgICBpZiAodGhpcy5yZXBsaWNhcyAmJiB0aGlzLnJlcGxpY2FzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBwcm9qZWN0TmFtZSwgYXBpS2V5LCBhcGlVcmwsIHVwZGF0ZXMgfSBvZiB0aGlzLnJlcGxpY2FzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVuRGF0YSA9IHRoaXMuX3JlbWFwRm9yUHJvamVjdChwcm9qZWN0TmFtZSA/PyB0aGlzLnByb2plY3RfbmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQudXBkYXRlUnVuKHJ1bkRhdGEuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBydW5EYXRhLmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogcnVuRGF0YS5vdXRwdXRzLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogcnVuRGF0YS5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcnVuRGF0YS5wYXJlbnRfcnVuX2lkLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uX25hbWU6IHJ1bkRhdGEuc2Vzc2lvbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZV9pZDogcnVuRGF0YS5yZWZlcmVuY2VfZXhhbXBsZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgZW5kX3RpbWU6IHJ1bkRhdGEuZW5kX3RpbWUsXG4gICAgICAgICAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogcnVuRGF0YS5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiBydW5EYXRhLnRyYWNlX2lkLFxuICAgICAgICAgICAgICAgICAgICBldmVudHM6IHJ1bkRhdGEuZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiBydW5EYXRhLnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiBydW5EYXRhLmV4dHJhLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50czogdGhpcy5hdHRhY2htZW50cyxcbiAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlcyxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBydW5VcGRhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZF90aW1lOiB0aGlzLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiB0aGlzLnBhcmVudF9ydW4/LmlkID8/IHRoaXMucGFyZW50X3J1bl9pZCxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHRoaXMucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB0aGlzLmV4dHJhLFxuICAgICAgICAgICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHRoaXMuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogdGhpcy50cmFjZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50czogdGhpcy5hdHRhY2htZW50cyxcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnVwZGF0ZVJ1bih0aGlzLmlkLCBydW5VcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gcGF0Y2hSdW4gZm9yIHJ1biAke3RoaXMuaWR9YCwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUb0NyZWF0ZSh0aGlzLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IHRvIHRoZSBydW4gdHJlZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBBIHNpbmdsZSBldmVudCBvciBzdHJpbmcgdG8gYWRkXG4gICAgICovXG4gICAgYWRkRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImV2ZW50XCIsXG4gICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgICB0aW1lOiBldmVudC50aW1lID8/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUnVubmFibGVDb25maWcocGFyZW50Q29uZmlnLCBwcm9wcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhbmRsZSB0aGUgY2FsbGJhY2sgbWFuYWdlciBjYXNlIGZvciBub3dcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gcGFyZW50Q29uZmlnPy5jYWxsYmFja3M7XG4gICAgICAgIGxldCBwYXJlbnRSdW47XG4gICAgICAgIGxldCBwcm9qZWN0TmFtZTtcbiAgICAgICAgbGV0IGNsaWVudDtcbiAgICAgICAgbGV0IHRyYWNpbmdFbmFibGVkID0gaXNUcmFjaW5nRW5hYmxlZCgpO1xuICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSdW5JZCA9IGNhbGxiYWNrTWFuYWdlcj8uZ2V0UGFyZW50UnVuSWQ/LigpID8/IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBsYW5nQ2hhaW5UcmFjZXIgPSBjYWxsYmFja01hbmFnZXI/LmhhbmRsZXJzPy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyPy5uYW1lID09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbiAgICAgICAgICAgIHBhcmVudFJ1biA9IGxhbmdDaGFpblRyYWNlcj8uZ2V0UnVuPy4ocGFyZW50UnVuSWQpO1xuICAgICAgICAgICAgcHJvamVjdE5hbWUgPSBsYW5nQ2hhaW5UcmFjZXI/LnByb2plY3ROYW1lO1xuICAgICAgICAgICAgY2xpZW50ID0gbGFuZ0NoYWluVHJhY2VyPy5jbGllbnQ7XG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCA9IHRyYWNpbmdFbmFibGVkIHx8ICEhbGFuZ0NoYWluVHJhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50UnVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBwcm9qZWN0X25hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UnVuVHJlZSA9IG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgIG5hbWU6IHBhcmVudFJ1bi5uYW1lLFxuICAgICAgICAgICAgaWQ6IHBhcmVudFJ1bi5pZCxcbiAgICAgICAgICAgIHRyYWNlX2lkOiBwYXJlbnRSdW4udHJhY2VfaWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICB0YWdzOiBbXG4gICAgICAgICAgICAgICAgLi4ubmV3IFNldCgocGFyZW50UnVuPy50YWdzID8/IFtdKS5jb25jYXQocGFyZW50Q29uZmlnPy50YWdzID8/IFtdKSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnRSdW4/LmV4dHJhPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyZW50Q29uZmlnPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJlbnRSdW5UcmVlLmNyZWF0ZUNoaWxkKHByb3BzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Eb3R0ZWRPcmRlcihkb3R0ZWRPcmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSGVhZGVycyh7IFwibGFuZ3NtaXRoLXRyYWNlXCI6IGRvdHRlZE9yZGVyIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhlYWRlcnMoaGVhZGVycywgaW5oZXJpdEFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmF3SGVhZGVycyA9IFwiZ2V0XCIgaW4gaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycy5nZXQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgXCJsYW5nc21pdGgtdHJhY2VcIjogaGVhZGVycy5nZXQoXCJsYW5nc21pdGgtdHJhY2VcIiksXG4gICAgICAgICAgICAgICAgYmFnZ2FnZTogaGVhZGVycy5nZXQoXCJiYWdnYWdlXCIpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBoZWFkZXJzO1xuICAgICAgICBjb25zdCBoZWFkZXJUcmFjZSA9IHJhd0hlYWRlcnNbXCJsYW5nc21pdGgtdHJhY2VcIl07XG4gICAgICAgIGlmICghaGVhZGVyVHJhY2UgfHwgdHlwZW9mIGhlYWRlclRyYWNlICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFyZW50RG90dGVkT3JkZXIgPSBoZWFkZXJUcmFjZS50cmltKCk7XG4gICAgICAgIGNvbnN0IHBhcnNlZERvdHRlZE9yZGVyID0gcGFyZW50RG90dGVkT3JkZXIuc3BsaXQoXCIuXCIpLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3N0clRpbWUsIHV1aWRdID0gcGFydC5zcGxpdChcIlpcIik7XG4gICAgICAgICAgICByZXR1cm4geyBzdHJUaW1lLCB0aW1lOiBEYXRlLnBhcnNlKHN0clRpbWUgKyBcIlpcIiksIHV1aWQgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYWNlSWQgPSBwYXJzZWREb3R0ZWRPcmRlclswXS51dWlkO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAuLi5pbmhlcml0QXJncyxcbiAgICAgICAgICAgIG5hbWU6IGluaGVyaXRBcmdzPy5bXCJuYW1lXCJdID8/IFwicGFyZW50XCIsXG4gICAgICAgICAgICBydW5fdHlwZTogaW5oZXJpdEFyZ3M/LltcInJ1bl90eXBlXCJdID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IGluaGVyaXRBcmdzPy5bXCJzdGFydF90aW1lXCJdID8/IERhdGUubm93KCksXG4gICAgICAgICAgICBpZDogcGFyc2VkRG90dGVkT3JkZXIuYXQoLTEpPy51dWlkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHBhcmVudERvdHRlZE9yZGVyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmF3SGVhZGVyc1tcImJhZ2dhZ2VcIl0gJiYgdHlwZW9mIHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBiYWdnYWdlID0gQmFnZ2FnZS5mcm9tSGVhZGVyKHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdKTtcbiAgICAgICAgICAgIGNvbmZpZy5tZXRhZGF0YSA9IGJhZ2dhZ2UubWV0YWRhdGE7XG4gICAgICAgICAgICBjb25maWcudGFncyA9IGJhZ2dhZ2UudGFncztcbiAgICAgICAgICAgIGNvbmZpZy5wcm9qZWN0X25hbWUgPSBiYWdnYWdlLnByb2plY3RfbmFtZTtcbiAgICAgICAgICAgIGNvbmZpZy5yZXBsaWNhcyA9IGJhZ2dhZ2UucmVwbGljYXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSdW5UcmVlKGNvbmZpZyk7XG4gICAgfVxuICAgIHRvSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIFwibGFuZ3NtaXRoLXRyYWNlXCI6IHRoaXMuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgYmFnZ2FnZTogbmV3IEJhZ2dhZ2UodGhpcy5leHRyYT8ubWV0YWRhdGEsIHRoaXMudGFncywgdGhpcy5wcm9qZWN0X25hbWUsIHRoaXMucmVwbGljYXMpLnRvSGVhZGVyKCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuVHJlZSwgXCJzaGFyZWRDbGllbnRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBudWxsXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpc1J1blRyZWUoeCkge1xuICAgIHJldHVybiAoeCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiB4LmNyZWF0ZUNoaWxkID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIHgucG9zdFJ1biA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGlzTGFuZ0NoYWluVHJhY2VyTGlrZSh4KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB4ICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHgubmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICB4Lm5hbWUgPT09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSh4KSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHgpICYmIHguc29tZSgoY2FsbGJhY2spID0+IGlzTGFuZ0NoYWluVHJhY2VyTGlrZShjYWxsYmFjaykpKTtcbn1cbmZ1bmN0aW9uIGlzQ2FsbGJhY2tNYW5hZ2VyTGlrZSh4KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB4ICE9IG51bGwgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh4LmhhbmRsZXJzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSdW5uYWJsZUNvbmZpZ0xpa2UoeCkge1xuICAgIC8vIENoZWNrIHRoYXQgaXQncyBhbiBvYmplY3Qgd2l0aCBhIGNhbGxiYWNrcyBhcmdcbiAgICAvLyB0aGF0IGhhcyBlaXRoZXIgYSBDYWxsYmFja01hbmFnZXJMaWtlIG9iamVjdCB3aXRoIGEgbGFuZ2NoYWluIHRyYWNlciB3aXRoaW4gaXRcbiAgICAvLyBvciBhbiBhcnJheSB3aXRoIGEgTGFuZ0NoYWluVHJhY2VyTGlrZSBvYmplY3Qgd2l0aGluIGl0XG4gICAgcmV0dXJuICh4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIHguY2FsbGJhY2tzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIC8vIENhbGxiYWNrIG1hbmFnZXIgd2l0aCBhIGxhbmdjaGFpbiB0cmFjZXJcbiAgICAgICAgKGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSh4LmNhbGxiYWNrcz8uaGFuZGxlcnMpIHx8XG4gICAgICAgICAgICAvLyBPciBpdCdzIGFuIGFycmF5IHdpdGggYSBMYW5nQ2hhaW5UcmFjZXJMaWtlIG9iamVjdCB3aXRoaW4gaXRcbiAgICAgICAgICAgIGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSh4LmNhbGxiYWNrcykpKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZURvdHRlZE9yZGVyKGRvdHRlZE9yZGVyKSB7XG4gICAgY29uc3QgcGFydHMgPSBkb3R0ZWRPcmRlci5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBTdHIgPSBwYXJ0LnNsaWNlKDAsIC0zNik7XG4gICAgICAgIGNvbnN0IHV1aWRTdHIgPSBwYXJ0LnNsaWNlKC0zNik7XG4gICAgICAgIC8vIFBhcnNlIHRpbWVzdGFtcDogXCIlWSVtJWRUJUglTSVTJWZaXCIgZm9ybWF0XG4gICAgICAgIC8vIEV4YW1wbGU6IFwiMjAyMzEyMTVUMTQzMDQ1MTIzNDU2WlwiXG4gICAgICAgIGNvbnN0IHllYXIgPSBwYXJzZUludCh0aW1lc3RhbXBTdHIuc2xpY2UoMCwgNCkpO1xuICAgICAgICBjb25zdCBtb250aCA9IHBhcnNlSW50KHRpbWVzdGFtcFN0ci5zbGljZSg0LCA2KSkgLSAxOyAvLyBKUyBtb250aHMgYXJlIDAtaW5kZXhlZFxuICAgICAgICBjb25zdCBkYXkgPSBwYXJzZUludCh0aW1lc3RhbXBTdHIuc2xpY2UoNiwgOCkpO1xuICAgICAgICBjb25zdCBob3VyID0gcGFyc2VJbnQodGltZXN0YW1wU3RyLnNsaWNlKDksIDExKSk7XG4gICAgICAgIGNvbnN0IG1pbnV0ZSA9IHBhcnNlSW50KHRpbWVzdGFtcFN0ci5zbGljZSgxMSwgMTMpKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQodGltZXN0YW1wU3RyLnNsaWNlKDEzLCAxNSkpO1xuICAgICAgICBjb25zdCBtaWNyb3NlY29uZCA9IHBhcnNlSW50KHRpbWVzdGFtcFN0ci5zbGljZSgxNSwgMjEpKTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pY3Jvc2Vjb25kIC8gMTAwMCk7XG4gICAgICAgIHJldHVybiBbdGltZXN0YW1wLCB1dWlkU3RyXTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9nZXRXcml0ZVJlcGxpY2FzRnJvbUVudigpIHtcbiAgICBjb25zdCBlbnZWYXIgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTXCIpO1xuICAgIGlmICghZW52VmFyKVxuICAgICAgICByZXR1cm4gW107XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShlbnZWYXIpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XG4gICAgICAgICAgICBjb25zdCByZXBsaWNhcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJvYmplY3RcIiB8fCBpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBpdGVtIHR5cGUgaW4gTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTOiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBleHBlY3RlZCBvYmplY3QsIGdvdCAke3R5cGVvZiBpdGVtfWApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtLmFwaV91cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIGFwaV91cmwgdHlwZSBpbiBMQU5HU01JVEhfUlVOU19FTkRQT0lOVFM6IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIGl0ZW0uYXBpX3VybH1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS5hcGlfa2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBhcGlfa2V5IHR5cGUgaW4gTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTOiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBpdGVtLmFwaV9rZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBsaWNhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBpdGVtLmFwaV91cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IGl0ZW0uYXBpX2tleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXBsaWNhcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyc2VkID09PSBcIm9iamVjdFwiICYmIHBhcnNlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2NoZWNrRW5kcG9pbnRFbnZVbnNldChwYXJzZWQpO1xuICAgICAgICAgICAgY29uc3QgcmVwbGljYXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3VybCwga2V5XSBvZiBPYmplY3QuZW50cmllcyhwYXJzZWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5VcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxpY2FzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBjbGVhblVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaUtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCB2YWx1ZSB0eXBlIGluIExBTkdTTUlUSF9SVU5TX0VORFBPSU5UUyBmb3IgVVJMICR7dXJsfTogYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVwbGljYXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIExBTkdTTUlUSF9SVU5TX0VORFBPSU5UUyDigJMgbXVzdCBiZSB2YWxpZCBKU09OIGFycmF5IG9mIFwiICtcbiAgICAgICAgICAgICAgICBgb2JqZWN0cyB3aXRoIGFwaV91cmwgYW5kIGFwaV9rZXkgcHJvcGVydGllcywgb3Igb2JqZWN0IG1hcHBpbmcgdXJsLT5hcGlLZXksIGdvdCAke3R5cGVvZiBwYXJzZWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGlzQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvcihlKSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIExBTkdTTUlUSF9SVU5TX0VORFBPSU5UUyDigJMgbXVzdCBiZSB2YWxpZCBKU09OIGFycmF5IG9mIFwiICtcbiAgICAgICAgICAgIFwib2JqZWN0cyB3aXRoIGFwaV91cmwgYW5kIGFwaV9rZXkgcHJvcGVydGllcywgb3Igb2JqZWN0IG1hcHBpbmcgdXJsLT5hcGlLZXlcIik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZW5zdXJlV3JpdGVSZXBsaWNhcyhyZXBsaWNhcykge1xuICAgIC8vIElmIG51bGwgLT4gZmV0Y2ggZnJvbSBlbnZcbiAgICBpZiAocmVwbGljYXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxpY2FzLm1hcCgocmVwbGljYSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVwbGljYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogcmVwbGljYVswXSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlczogcmVwbGljYVsxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxpY2E7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX2dldFdyaXRlUmVwbGljYXNGcm9tRW52KCk7XG59XG5mdW5jdGlvbiBfY2hlY2tFbmRwb2ludEVudlVuc2V0KHBhcnNlZCkge1xuICAgIGlmIChPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkVORFBPSU5UXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ0VuZHBvaW50c0Vycm9yKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInV1aWQiLCJDbGllbnQiLCJpc1RyYWNpbmdFbmFibGVkIiwiaXNDb25mbGljdGluZ0VuZHBvaW50c0Vycm9yIiwiQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciIsIl9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0UnVudGltZUVudmlyb25tZW50IiwiZ2V0RGVmYXVsdFByb2plY3ROYW1lIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsIndhcm5PbmNlIiwic3RyaXBOb25BbHBoYW51bWVyaWMiLCJpbnB1dCIsInJlcGxhY2UiLCJjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdCIsImVwb2NoIiwicnVuSWQiLCJleGVjdXRpb25PcmRlciIsInBhZGRlZE9yZGVyIiwidG9GaXhlZCIsInNsaWNlIiwicGFkU3RhcnQiLCJtaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmciLCJEYXRlIiwidG9JU09TdHJpbmciLCJkb3R0ZWRPcmRlciIsIkJhZ2dhZ2UiLCJjb25zdHJ1Y3RvciIsIm1ldGFkYXRhIiwidGFncyIsInByb2plY3RfbmFtZSIsInJlcGxpY2FzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsImZyb21IZWFkZXIiLCJpdGVtcyIsInNwbGl0IiwiaXRlbSIsImtleSIsInVyaVZhbHVlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInBhcnNlIiwidG9IZWFkZXIiLCJrZXlzIiwibGVuZ3RoIiwicHVzaCIsImVuY29kZVVSSUNvbXBvbmVudCIsInN0cmluZ2lmeSIsImpvaW4iLCJSdW5UcmVlIiwib3JpZ2luYWxDb25maWciLCJpc1J1blRyZWUiLCJhc3NpZ24iLCJkZWZhdWx0Q29uZmlnIiwiZ2V0RGVmYXVsdENvbmZpZyIsImNvbmZpZyIsImNsaWVudCIsImdldFNoYXJlZENsaWVudCIsImRlZHVwZWRNZXRhZGF0YSIsImV4dHJhIiwidHJhY2VfaWQiLCJwYXJlbnRfcnVuIiwiaWQiLCJfZW5zdXJlV3JpdGVSZXBsaWNhcyIsImV4ZWN1dGlvbl9vcmRlciIsImNoaWxkX2V4ZWN1dGlvbl9vcmRlciIsImRvdHRlZF9vcmRlciIsInN0YXJ0X3RpbWUiLCJfc2VyaWFsaXplZF9zdGFydF90aW1lIiwidjQiLCJydW5fdHlwZSIsImNoaWxkX3J1bnMiLCJhcGlfdXJsIiwiYXBpX2tleSIsImNhbGxlcl9vcHRpb25zIiwibm93Iiwic2VyaWFsaXplZCIsImlucHV0cyIsInNoYXJlZENsaWVudCIsImNyZWF0ZUNoaWxkIiwiY2hpbGQiLCJ0cmFjaW5nRW5hYmxlZCIsIkxDX0NISUxEIiwiU3ltYm9sIiwiZm9yIiwicHJlc2VudENvbmZpZyIsImlzUnVubmFibGVDb25maWdMaWtlIiwibmV3Q29uZmlnIiwiY2FsbGJhY2tzIiwiaXNDYWxsYmFja01hbmFnZXJMaWtlIiwiY29weSIsInVuZGVmaW5lZCIsIl9wYXJlbnRSdW5JZCIsImhhbmRsZXJzIiwiZmluZCIsImlzTGFuZ0NoYWluVHJhY2VyTGlrZSIsInVwZGF0ZUZyb21SdW5UcmVlIiwidmlzaXRlZCIsIlNldCIsImN1cnJlbnQiLCJoYXMiLCJhZGQiLCJNYXRoIiwibWF4IiwiZW5kIiwib3V0cHV0cyIsImVycm9yIiwiZW5kVGltZSIsImVuZF90aW1lIiwiX2NvbnZlcnRUb0NyZWF0ZSIsInJ1biIsInJ1bnRpbWVFbnYiLCJleGNsdWRlQ2hpbGRSdW5zIiwicnVuRXh0cmEiLCJydW50aW1lIiwibGlicmFyeSIsImsiLCJ2IiwiZW50cmllcyIsInBhcmVudF9ydW5faWQiLCJtYXAiLCJjaGlsZF9ydW4iLCJuYW1lIiwicmVmZXJlbmNlX2V4YW1wbGVfaWQiLCJzZXNzaW9uX25hbWUiLCJhdHRhY2htZW50cyIsImV2ZW50cyIsIl9yZW1hcEZvclByb2plY3QiLCJwcm9qZWN0TmFtZSIsImJhc2VSdW4iLCJjcmVhdGVSZW1hcHBlZElkIiwib3JpZ2luYWxJZCIsInY1IiwiRE5TIiwibmV3SWQiLCJuZXdUcmFjZUlkIiwibmV3UGFyZW50UnVuSWQiLCJuZXdEb3R0ZWRPcmRlciIsInNlZ21lbnRzIiwiX3BhcnNlRG90dGVkT3JkZXIiLCJyZWJ1aWx0IiwiaSIsInRpbWVzdGFtcCIsInNlZ21lbnRJZCIsInJlbWFwcGVkSWQiLCJsYXN0VGltZXN0YW1wIiwicmVtYXBwZWRSdW4iLCJwb3N0UnVuIiwiYXBpS2V5IiwiYXBpVXJsIiwicnVuQ3JlYXRlIiwiY3JlYXRlUnVuIiwiY2hpbGRSdW4iLCJjb25zb2xlIiwicGF0Y2hSdW4iLCJ1cGRhdGVzIiwicnVuRGF0YSIsInVwZGF0ZVJ1biIsInJ1blVwZGF0ZSIsInRvSlNPTiIsImFkZEV2ZW50IiwiZXZlbnQiLCJ0aW1lIiwibWVzc2FnZSIsImZyb21SdW5uYWJsZUNvbmZpZyIsInBhcmVudENvbmZpZyIsInByb3BzIiwiY2FsbGJhY2tNYW5hZ2VyIiwicGFyZW50UnVuIiwicGFyZW50UnVuSWQiLCJnZXRQYXJlbnRSdW5JZCIsImxhbmdDaGFpblRyYWNlciIsImhhbmRsZXIiLCJnZXRSdW4iLCJwYXJlbnRSdW5UcmVlIiwiY29uY2F0IiwiZnJvbURvdHRlZE9yZGVyIiwiZnJvbUhlYWRlcnMiLCJoZWFkZXJzIiwiaW5oZXJpdEFyZ3MiLCJyYXdIZWFkZXJzIiwiZ2V0IiwiYmFnZ2FnZSIsImhlYWRlclRyYWNlIiwicGFyZW50RG90dGVkT3JkZXIiLCJ0cmltIiwicGFyc2VkRG90dGVkT3JkZXIiLCJwYXJ0Iiwic3RyVGltZSIsInRyYWNlSWQiLCJhdCIsInRvSGVhZGVycyIsInJlc3VsdCIsInNldCIsIngiLCJjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UiLCJBcnJheSIsImlzQXJyYXkiLCJzb21lIiwiY2FsbGJhY2siLCJwYXJ0cyIsInRpbWVzdGFtcFN0ciIsInV1aWRTdHIiLCJ5ZWFyIiwicGFyc2VJbnQiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWNyb3NlY29uZCIsIl9nZXRXcml0ZVJlcGxpY2FzRnJvbUVudiIsImVudlZhciIsInBhcnNlZCIsIndhcm4iLCJfY2hlY2tFbmRwb2ludEVudlVuc2V0IiwidXJsIiwiY2xlYW5VcmwiLCJlIiwicmVwbGljYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _LC_CONTEXT_VARIABLES_KEY: () => (/* binding */ _LC_CONTEXT_VARIABLES_KEY)\n/* harmony export */ });\nconst _LC_CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLDRCQUE0QkMsT0FBT0MsR0FBRyxDQUFDLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL2NvbnN0YW50cy5qcz8xZGE0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZID0gU3ltYm9sLmZvcihcImxjOmNvbnRleHRfdmFyaWFibGVzXCIpO1xuIl0sIm5hbWVzIjpbIl9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkiLCJTeW1ib2wiLCJmb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/fetch.js":
/*!*********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/fetch.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),\n/* harmony export */   _globalFetchImplementationIsNodeFetch: () => (/* binding */ _globalFetchImplementationIsNodeFetch),\n/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args)=>fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"ls:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch functino to use.\n */ const overrideFetchImplementation = (fetch1)=>{\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch1;\n};\nconst _globalFetchImplementationIsNodeFetch = ()=>{\n    const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];\n    if (!fetchImpl) return false;\n    // Check if the implementation has node-fetch specific properties\n    return typeof fetchImpl === \"function\" && \"Headers\" in fetchImpl && \"Request\" in fetchImpl && \"Response\" in fetchImpl;\n};\n/**\n * @internal\n */ const _getFetchImplementation = (debug)=>{\n    return async (...args)=>{\n        if (debug || (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"DEBUG\") === \"true\") {\n            const [url, options] = args;\n            console.log(`→ ${options?.method || \"GET\"} ${url}`);\n        }\n        const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION)(...args);\n        if (debug || (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"DEBUG\") === \"true\") {\n            console.log(`← ${res.status} ${res.statusText} ${res.url}`);\n        }\n        return res;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtFO0FBQ2xFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsMEhBQTBIO0FBQzFILDRFQUE0RTtBQUM1RSxNQUFNQywrQkFBK0IsQ0FBQyxHQUFHQyxPQUFTQyxTQUFTRDtBQUMzRCxNQUFNRSxxQ0FBcUNDLE9BQU9DLEdBQUcsQ0FBQztBQUN0RDs7Ozs7Q0FLQyxHQUNNLE1BQU1DLDhCQUE4QixDQUFDSjtJQUN4Q0ssVUFBVSxDQUFDSixtQ0FBbUMsR0FBR0Q7QUFDckQsRUFBRTtBQUNLLE1BQU1NLHdDQUF3QztJQUNqRCxNQUFNQyxZQUFZRixVQUFVLENBQUNKLG1DQUFtQztJQUNoRSxJQUFJLENBQUNNLFdBQ0QsT0FBTztJQUNYLGlFQUFpRTtJQUNqRSxPQUFRLE9BQU9BLGNBQWMsY0FDekIsYUFBYUEsYUFDYixhQUFhQSxhQUNiLGNBQWNBO0FBQ3RCLEVBQUU7QUFDRjs7Q0FFQyxHQUNNLE1BQU1DLDBCQUEwQixDQUFDQztJQUNwQyxPQUFPLE9BQU8sR0FBR1Y7UUFDYixJQUFJVSxTQUFTWiw4RUFBK0JBLENBQUMsYUFBYSxRQUFRO1lBQzlELE1BQU0sQ0FBQ2EsS0FBS0MsUUFBUSxHQUFHWjtZQUN2QmEsUUFBUUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFRixTQUFTRyxVQUFVLE1BQU0sQ0FBQyxFQUFFSixJQUFJLENBQUM7UUFDdEQ7UUFDQSxNQUFNSyxNQUFNLE1BQU0sQ0FBQ1YsVUFBVSxDQUFDSixtQ0FBbUMsSUFDN0RILDRCQUEyQixLQUFNQztRQUNyQyxJQUFJVSxTQUFTWiw4RUFBK0JBLENBQUMsYUFBYSxRQUFRO1lBQzlEZSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUVFLElBQUlDLE1BQU0sQ0FBQyxDQUFDLEVBQUVELElBQUlFLFVBQVUsQ0FBQyxDQUFDLEVBQUVGLElBQUlMLEdBQUcsQ0FBQyxDQUFDO1FBQzlEO1FBQ0EsT0FBT0s7SUFDWDtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcz83NjJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi4vdXRpbHMvZW52LmpzXCI7XG4vLyBXcmFwIHRoZSBkZWZhdWx0IGZldGNoIGNhbGwgZHVlIHRvIGlzc3VlcyB3aXRoIGlsbGVnYWwgaW52b2NhdGlvbnNcbi8vIGluIHNvbWUgZW52aXJvbm1lbnRzOlxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjk4NzY4NTkvd2h5LWRvZXMtYmluZC1maXgtZmFpbGVkLXRvLWV4ZWN1dGUtZmV0Y2gtb24td2luZG93LWlsbGVnYWwtaW52b2NhdGlvbi1lcnJcbi8vIEB0cy1leHBlY3QtZXJyb3IgQnJvYWQgdHlwaW5nIHRvIHN1cHBvcnQgYSByYW5nZSBvZiBmZXRjaCBpbXBsZW1lbnRhdGlvbnNcbmNvbnN0IERFRkFVTFRfRkVUQ0hfSU1QTEVNRU5UQVRJT04gPSAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG5jb25zdCBMQU5HU01JVEhfRkVUQ0hfSU1QTEVNRU5UQVRJT05fS0VZID0gU3ltYm9sLmZvcihcImxzOmZldGNoX2ltcGxlbWVudGF0aW9uXCIpO1xuLyoqXG4gKiBPdmVycmlkZXMgdGhlIGZldGNoIGltcGxlbWVudGF0aW9uIHVzZWQgZm9yIExhbmdTbWl0aCBjYWxscy5cbiAqIFlvdSBzaG91bGQgdXNlIHRoaXMgaWYgeW91IG5lZWQgdG8gdXNlIGFuIGltcGxlbWVudGF0aW9uIG9mIGZldGNoXG4gKiBvdGhlciB0aGFuIHRoZSBkZWZhdWx0IGdsb2JhbCAoZS5nLiBmb3IgZGVhbGluZyB3aXRoIHByb3hpZXMpLlxuICogQHBhcmFtIGZldGNoIFRoZSBuZXcgZmV0Y2ggZnVuY3Rpbm8gdG8gdXNlLlxuICovXG5leHBvcnQgY29uc3Qgb3ZlcnJpZGVGZXRjaEltcGxlbWVudGF0aW9uID0gKGZldGNoKSA9PiB7XG4gICAgZ2xvYmFsVGhpc1tMQU5HU01JVEhfRkVUQ0hfSU1QTEVNRU5UQVRJT05fS0VZXSA9IGZldGNoO1xufTtcbmV4cG9ydCBjb25zdCBfZ2xvYmFsRmV0Y2hJbXBsZW1lbnRhdGlvbklzTm9kZUZldGNoID0gKCkgPT4ge1xuICAgIGNvbnN0IGZldGNoSW1wbCA9IGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV07XG4gICAgaWYgKCFmZXRjaEltcGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayBpZiB0aGUgaW1wbGVtZW50YXRpb24gaGFzIG5vZGUtZmV0Y2ggc3BlY2lmaWMgcHJvcGVydGllc1xuICAgIHJldHVybiAodHlwZW9mIGZldGNoSW1wbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIFwiSGVhZGVyc1wiIGluIGZldGNoSW1wbCAmJlxuICAgICAgICBcIlJlcXVlc3RcIiBpbiBmZXRjaEltcGwgJiZcbiAgICAgICAgXCJSZXNwb25zZVwiIGluIGZldGNoSW1wbCk7XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uID0gKGRlYnVnKSA9PiB7XG4gICAgcmV0dXJuIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChkZWJ1ZyB8fCBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiREVCVUdcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCBbdXJsLCBvcHRpb25zXSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4oaSICR7b3B0aW9ucz8ubWV0aG9kIHx8IFwiR0VUXCJ9ICR7dXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IChnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldID8/XG4gICAgICAgICAgICBERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OKSguLi5hcmdzKTtcbiAgICAgICAgaWYgKGRlYnVnIHx8IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJERUJVR1wiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDihpAgJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fSAke3Jlcy51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIiwiREVGQVVMVF9GRVRDSF9JTVBMRU1FTlRBVElPTiIsImFyZ3MiLCJmZXRjaCIsIkxBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVkiLCJTeW1ib2wiLCJmb3IiLCJvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24iLCJnbG9iYWxUaGlzIiwiX2dsb2JhbEZldGNoSW1wbGVtZW50YXRpb25Jc05vZGVGZXRjaCIsImZldGNoSW1wbCIsIl9nZXRGZXRjaEltcGxlbWVudGF0aW9uIiwiZGVidWciLCJ1cmwiLCJvcHRpb25zIiwiY29uc29sZSIsImxvZyIsIm1ldGhvZCIsInJlcyIsInN0YXR1cyIsInN0YXR1c1RleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/otel.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/otel.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OTELProviderSingleton: () => (/* binding */ OTELProviderSingleton),\n/* harmony export */   getDefaultOTLPTracerComponents: () => (/* binding */ getDefaultOTLPTracerComponents),\n/* harmony export */   getOTELContext: () => (/* binding */ getOTELContext),\n/* harmony export */   getOTELTrace: () => (/* binding */ getOTELTrace),\n/* harmony export */   setDefaultOTLPTracerComponents: () => (/* binding */ setDefaultOTLPTracerComponents),\n/* harmony export */   setOTELInstances: () => (/* binding */ setOTELInstances)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n// Should not import any OTEL packages to avoid pulling in optional deps.\n\nclass MockTracer {\n    constructor(){\n        Object.defineProperty(this, \"hasWarned\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    startActiveSpan(_name, ...args) {\n        if (!this.hasWarned && (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getOtelEnabled)()) {\n            console.warn(\"You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. \" + 'Please add:\\n```\\nimport { initializeOTEL } from \"langsmith/experimental/otel/setup\";\\ninitializeOTEL();\\n```\\nat the beginning of your code.');\n            this.hasWarned = true;\n        }\n        // Handle different overloads:\n        // startActiveSpan(name, fn)\n        // startActiveSpan(name, options, fn)\n        // startActiveSpan(name, options, context, fn)\n        let fn;\n        if (args.length === 1 && typeof args[0] === \"function\") {\n            fn = args[0];\n        } else if (args.length === 2 && typeof args[1] === \"function\") {\n            fn = args[1];\n        } else if (args.length === 3 && typeof args[2] === \"function\") {\n            fn = args[2];\n        }\n        if (typeof fn === \"function\") {\n            return fn();\n        }\n        return undefined;\n    }\n}\nclass MockOTELTrace {\n    constructor(){\n        Object.defineProperty(this, \"mockTracer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new MockTracer()\n        });\n    }\n    getTracer(_name, _version) {\n        return this.mockTracer;\n    }\n    getActiveSpan() {\n        return undefined;\n    }\n    setSpan(context, _span) {\n        return context;\n    }\n    getSpan(_context) {\n        return undefined;\n    }\n    setSpanContext(context, _spanContext) {\n        return context;\n    }\n    getTracerProvider() {\n        return undefined;\n    }\n    setGlobalTracerProvider(_tracerProvider) {\n        return false;\n    }\n}\nclass MockOTELContext {\n    active() {\n        return {};\n    }\n    with(_context, fn) {\n        return fn();\n    }\n}\nconst OTEL_TRACE_KEY = Symbol.for(\"ls:otel_trace\");\nconst OTEL_CONTEXT_KEY = Symbol.for(\"ls:otel_context\");\nconst OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for(\"ls:otel_get_default_otlp_tracer_provider\");\nconst mockOTELTrace = new MockOTELTrace();\nconst mockOTELContext = new MockOTELContext();\nclass OTELProvider {\n    getTraceInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;\n    }\n    getContextInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;\n    }\n    initializeGlobalInstances(otel) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_TRACE_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_TRACE_KEY] = otel.trace;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_CONTEXT_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_CONTEXT_KEY] = otel.context;\n        }\n    }\n    setDefaultOTLPTracerComponents(components) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;\n    }\n    getDefaultOTLPTracerComponents() {\n        return globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ?? undefined;\n    }\n}\nconst OTELProviderSingleton = new OTELProvider();\n/**\n * Get the current OTEL trace instance.\n * Returns a mock implementation if OTEL is not available.\n */ function getOTELTrace() {\n    return OTELProviderSingleton.getTraceInstance();\n}\n/**\n * Get the current OTEL context instance.\n * Returns a mock implementation if OTEL is not available.\n */ function getOTELContext() {\n    return OTELProviderSingleton.getContextInstance();\n}\n/**\n * Initialize the global OTEL instances.\n * Should be called once when OTEL packages are available.\n */ function setOTELInstances(otel) {\n    OTELProviderSingleton.initializeGlobalInstances(otel);\n}\n/**\n * Set a getter function for the default OTLP tracer provider.\n * This allows lazy initialization of the tracer provider.\n */ function setDefaultOTLPTracerComponents(components) {\n    OTELProviderSingleton.setDefaultOTLPTracerComponents(components);\n}\n/**\n * Get the default OTLP tracer provider instance.\n * Returns undefined if not set.\n */ function getDefaultOTLPTracerComponents() {\n    return OTELProviderSingleton.getDefaultOTLPTracerComponents();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9vdGVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSx5RUFBeUU7QUFDeEI7QUFDakQsTUFBTUM7SUFDRkMsYUFBYztRQUNWQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGFBQWE7WUFDckNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU87UUFDWDtJQUNKO0lBQ0FDLGdCQUFnQkMsS0FBSyxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDQyxTQUFTLElBQUlaLDZEQUFjQSxJQUFJO1lBQ3JDYSxRQUFRQyxJQUFJLENBQUMsaUtBQ1Q7WUFDSixJQUFJLENBQUNGLFNBQVMsR0FBRztRQUNyQjtRQUNBLDhCQUE4QjtRQUM5Qiw0QkFBNEI7UUFDNUIscUNBQXFDO1FBQ3JDLDhDQUE4QztRQUM5QyxJQUFJRztRQUNKLElBQUlKLEtBQUtLLE1BQU0sS0FBSyxLQUFLLE9BQU9MLElBQUksQ0FBQyxFQUFFLEtBQUssWUFBWTtZQUNwREksS0FBS0osSUFBSSxDQUFDLEVBQUU7UUFDaEIsT0FDSyxJQUFJQSxLQUFLSyxNQUFNLEtBQUssS0FBSyxPQUFPTCxJQUFJLENBQUMsRUFBRSxLQUFLLFlBQVk7WUFDekRJLEtBQUtKLElBQUksQ0FBQyxFQUFFO1FBQ2hCLE9BQ0ssSUFBSUEsS0FBS0ssTUFBTSxLQUFLLEtBQUssT0FBT0wsSUFBSSxDQUFDLEVBQUUsS0FBSyxZQUFZO1lBQ3pESSxLQUFLSixJQUFJLENBQUMsRUFBRTtRQUNoQjtRQUNBLElBQUksT0FBT0ksT0FBTyxZQUFZO1lBQzFCLE9BQU9BO1FBQ1g7UUFDQSxPQUFPRTtJQUNYO0FBQ0o7QUFDQSxNQUFNQztJQUNGaEIsYUFBYztRQUNWQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sSUFBSVA7UUFDZjtJQUNKO0lBQ0FrQixVQUFVVCxLQUFLLEVBQUVVLFFBQVEsRUFBRTtRQUN2QixPQUFPLElBQUksQ0FBQ0MsVUFBVTtJQUMxQjtJQUNBQyxnQkFBZ0I7UUFDWixPQUFPTDtJQUNYO0lBQ0FNLFFBQVFDLE9BQU8sRUFBRUMsS0FBSyxFQUFFO1FBQ3BCLE9BQU9EO0lBQ1g7SUFDQUUsUUFBUUMsUUFBUSxFQUFFO1FBQ2QsT0FBT1Y7SUFDWDtJQUNBVyxlQUFlSixPQUFPLEVBQUVLLFlBQVksRUFBRTtRQUNsQyxPQUFPTDtJQUNYO0lBQ0FNLG9CQUFvQjtRQUNoQixPQUFPYjtJQUNYO0lBQ0FjLHdCQUF3QkMsZUFBZSxFQUFFO1FBQ3JDLE9BQU87SUFDWDtBQUNKO0FBQ0EsTUFBTUM7SUFDRkMsU0FBUztRQUNMLE9BQU8sQ0FBQztJQUNaO0lBQ0FDLEtBQUtSLFFBQVEsRUFBRVosRUFBRSxFQUFFO1FBQ2YsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTXFCLGlCQUFpQkMsT0FBT0MsR0FBRyxDQUFDO0FBQ2xDLE1BQU1DLG1CQUFtQkYsT0FBT0MsR0FBRyxDQUFDO0FBQ3BDLE1BQU1FLDRDQUE0Q0gsT0FBT0MsR0FBRyxDQUFDO0FBQzdELE1BQU1HLGdCQUFnQixJQUFJdkI7QUFDMUIsTUFBTXdCLGtCQUFrQixJQUFJVDtBQUM1QixNQUFNVTtJQUNGQyxtQkFBbUI7UUFDZiw4REFBOEQ7UUFDOUQsT0FBT0MsVUFBVSxDQUFDVCxlQUFlLElBQUlLO0lBQ3pDO0lBQ0FLLHFCQUFxQjtRQUNqQiw4REFBOEQ7UUFDOUQsT0FBT0QsVUFBVSxDQUFDTixpQkFBaUIsSUFBSUc7SUFDM0M7SUFDQUssMEJBQTBCQyxJQUFJLEVBQUU7UUFDNUIsOERBQThEO1FBQzlELElBQUlILFVBQVUsQ0FBQ1QsZUFBZSxLQUFLbkIsV0FBVztZQUMxQyw4REFBOEQ7WUFDOUQ0QixVQUFVLENBQUNULGVBQWUsR0FBR1ksS0FBS0MsS0FBSztRQUMzQztRQUNBLDhEQUE4RDtRQUM5RCxJQUFJSixVQUFVLENBQUNOLGlCQUFpQixLQUFLdEIsV0FBVztZQUM1Qyw4REFBOEQ7WUFDOUQ0QixVQUFVLENBQUNOLGlCQUFpQixHQUFHUyxLQUFLeEIsT0FBTztRQUMvQztJQUNKO0lBQ0EwQiwrQkFBK0JDLFVBQVUsRUFBRTtRQUN2Qyw4REFBOEQ7UUFDOUROLFVBQVUsQ0FBQ0wsMENBQTBDLEdBQUdXO0lBQzVEO0lBQ0FDLGlDQUFpQztRQUM3QixPQUFRUCxVQUFVLENBQUNMLDBDQUEwQyxJQUN6RHZCO0lBQ1I7QUFDSjtBQUNPLE1BQU1vQyx3QkFBd0IsSUFBSVYsZUFBZTtBQUN4RDs7O0NBR0MsR0FDTSxTQUFTVztJQUNaLE9BQU9ELHNCQUFzQlQsZ0JBQWdCO0FBQ2pEO0FBQ0E7OztDQUdDLEdBQ00sU0FBU1c7SUFDWixPQUFPRixzQkFBc0JQLGtCQUFrQjtBQUNuRDtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNVLGlCQUFpQlIsSUFBSTtJQUNqQ0ssc0JBQXNCTix5QkFBeUIsQ0FBQ0M7QUFDcEQ7QUFDQTs7O0NBR0MsR0FDTSxTQUFTRSwrQkFBK0JDLFVBQVU7SUFDckRFLHNCQUFzQkgsOEJBQThCLENBQUNDO0FBQ3pEO0FBQ0E7OztDQUdDLEdBQ00sU0FBU0M7SUFDWixPQUFPQyxzQkFBc0JELDhCQUE4QjtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL290ZWwuanM/YmVlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaG91bGQgbm90IGltcG9ydCBhbnkgT1RFTCBwYWNrYWdlcyB0byBhdm9pZCBwdWxsaW5nIGluIG9wdGlvbmFsIGRlcHMuXG5pbXBvcnQgeyBnZXRPdGVsRW5hYmxlZCB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbmNsYXNzIE1vY2tUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYXNXYXJuZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydEFjdGl2ZVNwYW4oX25hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1dhcm5lZCAmJiBnZXRPdGVsRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJZb3UgaGF2ZSBlbmFibGVkIE9URUwgZXhwb3J0IHZpYSB0aGUgYE9URUxfRU5BQkxFRGAgb3IgYExBTkdTTUlUSF9PVEVMX0VOQUJMRURgIGVudmlyb25tZW50IHZhcmlhYmxlLCBidXQgaGF2ZSBub3QgaW5pdGlhbGl6ZWQgdGhlIHJlcXVpcmVkIE9URUwgaW5zdGFuY2VzLiBcIiArXG4gICAgICAgICAgICAgICAgJ1BsZWFzZSBhZGQ6XFxuYGBgXFxuaW1wb3J0IHsgaW5pdGlhbGl6ZU9URUwgfSBmcm9tIFwibGFuZ3NtaXRoL2V4cGVyaW1lbnRhbC9vdGVsL3NldHVwXCI7XFxuaW5pdGlhbGl6ZU9URUwoKTtcXG5gYGBcXG5hdCB0aGUgYmVnaW5uaW5nIG9mIHlvdXIgY29kZS4nKTtcbiAgICAgICAgICAgIHRoaXMuaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IG92ZXJsb2FkczpcbiAgICAgICAgLy8gc3RhcnRBY3RpdmVTcGFuKG5hbWUsIGZuKVxuICAgICAgICAvLyBzdGFydEFjdGl2ZVNwYW4obmFtZSwgb3B0aW9ucywgZm4pXG4gICAgICAgIC8vIHN0YXJ0QWN0aXZlU3BhbihuYW1lLCBvcHRpb25zLCBjb250ZXh0LCBmbilcbiAgICAgICAgbGV0IGZuO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm4gPSBhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyICYmIHR5cGVvZiBhcmdzWzFdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuID0gYXJnc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgYXJnc1syXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBmbiA9IGFyZ3NbMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNsYXNzIE1vY2tPVEVMVHJhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2NrVHJhY2VyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTW9ja1RyYWNlcigpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFjZXIoX25hbWUsIF92ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vY2tUcmFjZXI7XG4gICAgfVxuICAgIGdldEFjdGl2ZVNwYW4oKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldFNwYW4oY29udGV4dCwgX3NwYW4pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGdldFNwYW4oX2NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0U3BhbkNvbnRleHQoY29udGV4dCwgX3NwYW5Db250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBnZXRUcmFjZXJQcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0R2xvYmFsVHJhY2VyUHJvdmlkZXIoX3RyYWNlclByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBNb2NrT1RFTENvbnRleHQge1xuICAgIGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB3aXRoKF9jb250ZXh0LCBmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG59XG5jb25zdCBPVEVMX1RSQUNFX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpvdGVsX3RyYWNlXCIpO1xuY29uc3QgT1RFTF9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpvdGVsX2NvbnRleHRcIik7XG5jb25zdCBPVEVMX0dFVF9ERUZBVUxUX09UTFBfVFJBQ0VSX1BST1ZJREVSX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpvdGVsX2dldF9kZWZhdWx0X290bHBfdHJhY2VyX3Byb3ZpZGVyXCIpO1xuY29uc3QgbW9ja09URUxUcmFjZSA9IG5ldyBNb2NrT1RFTFRyYWNlKCk7XG5jb25zdCBtb2NrT1RFTENvbnRleHQgPSBuZXcgTW9ja09URUxDb250ZXh0KCk7XG5jbGFzcyBPVEVMUHJvdmlkZXIge1xuICAgIGdldFRyYWNlSW5zdGFuY2UoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzW09URUxfVFJBQ0VfS0VZXSA/PyBtb2NrT1RFTFRyYWNlO1xuICAgIH1cbiAgICBnZXRDb250ZXh0SW5zdGFuY2UoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzW09URUxfQ09OVEVYVF9LRVldID8/IG1vY2tPVEVMQ29udGV4dDtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlcyhvdGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlmIChnbG9iYWxUaGlzW09URUxfVFJBQ0VfS0VZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZ2xvYmFsVGhpc1tPVEVMX1RSQUNFX0tFWV0gPSBvdGVsLnRyYWNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlmIChnbG9iYWxUaGlzW09URUxfQ09OVEVYVF9LRVldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBnbG9iYWxUaGlzW09URUxfQ09OVEVYVF9LRVldID0gb3RlbC5jb250ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cyhjb21wb25lbnRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGdsb2JhbFRoaXNbT1RFTF9HRVRfREVGQVVMVF9PVExQX1RSQUNFUl9QUk9WSURFUl9LRVldID0gY29tcG9uZW50cztcbiAgICB9XG4gICAgZ2V0RGVmYXVsdE9UTFBUcmFjZXJDb21wb25lbnRzKCkge1xuICAgICAgICByZXR1cm4gKGdsb2JhbFRoaXNbT1RFTF9HRVRfREVGQVVMVF9PVExQX1RSQUNFUl9QUk9WSURFUl9LRVldID8/XG4gICAgICAgICAgICB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBPVEVMUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgT1RFTFByb3ZpZGVyKCk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBPVEVMIHRyYWNlIGluc3RhbmNlLlxuICogUmV0dXJucyBhIG1vY2sgaW1wbGVtZW50YXRpb24gaWYgT1RFTCBpcyBub3QgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T1RFTFRyYWNlKCkge1xuICAgIHJldHVybiBPVEVMUHJvdmlkZXJTaW5nbGV0b24uZ2V0VHJhY2VJbnN0YW5jZSgpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgT1RFTCBjb250ZXh0IGluc3RhbmNlLlxuICogUmV0dXJucyBhIG1vY2sgaW1wbGVtZW50YXRpb24gaWYgT1RFTCBpcyBub3QgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T1RFTENvbnRleHQoKSB7XG4gICAgcmV0dXJuIE9URUxQcm92aWRlclNpbmdsZXRvbi5nZXRDb250ZXh0SW5zdGFuY2UoKTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZ2xvYmFsIE9URUwgaW5zdGFuY2VzLlxuICogU2hvdWxkIGJlIGNhbGxlZCBvbmNlIHdoZW4gT1RFTCBwYWNrYWdlcyBhcmUgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0T1RFTEluc3RhbmNlcyhvdGVsKSB7XG4gICAgT1RFTFByb3ZpZGVyU2luZ2xldG9uLmluaXRpYWxpemVHbG9iYWxJbnN0YW5jZXMob3RlbCk7XG59XG4vKipcbiAqIFNldCBhIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIGRlZmF1bHQgT1RMUCB0cmFjZXIgcHJvdmlkZXIuXG4gKiBUaGlzIGFsbG93cyBsYXp5IGluaXRpYWxpemF0aW9uIG9mIHRoZSB0cmFjZXIgcHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoY29tcG9uZW50cykge1xuICAgIE9URUxQcm92aWRlclNpbmdsZXRvbi5zZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoY29tcG9uZW50cyk7XG59XG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBPVExQIHRyYWNlciBwcm92aWRlciBpbnN0YW5jZS5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoKSB7XG4gICAgcmV0dXJuIE9URUxQcm92aWRlclNpbmdsZXRvbi5nZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoKTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRPdGVsRW5hYmxlZCIsIk1vY2tUcmFjZXIiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJzdGFydEFjdGl2ZVNwYW4iLCJfbmFtZSIsImFyZ3MiLCJoYXNXYXJuZWQiLCJjb25zb2xlIiwid2FybiIsImZuIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiTW9ja09URUxUcmFjZSIsImdldFRyYWNlciIsIl92ZXJzaW9uIiwibW9ja1RyYWNlciIsImdldEFjdGl2ZVNwYW4iLCJzZXRTcGFuIiwiY29udGV4dCIsIl9zcGFuIiwiZ2V0U3BhbiIsIl9jb250ZXh0Iiwic2V0U3BhbkNvbnRleHQiLCJfc3BhbkNvbnRleHQiLCJnZXRUcmFjZXJQcm92aWRlciIsInNldEdsb2JhbFRyYWNlclByb3ZpZGVyIiwiX3RyYWNlclByb3ZpZGVyIiwiTW9ja09URUxDb250ZXh0IiwiYWN0aXZlIiwid2l0aCIsIk9URUxfVFJBQ0VfS0VZIiwiU3ltYm9sIiwiZm9yIiwiT1RFTF9DT05URVhUX0tFWSIsIk9URUxfR0VUX0RFRkFVTFRfT1RMUF9UUkFDRVJfUFJPVklERVJfS0VZIiwibW9ja09URUxUcmFjZSIsIm1vY2tPVEVMQ29udGV4dCIsIk9URUxQcm92aWRlciIsImdldFRyYWNlSW5zdGFuY2UiLCJnbG9iYWxUaGlzIiwiZ2V0Q29udGV4dEluc3RhbmNlIiwiaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlcyIsIm90ZWwiLCJ0cmFjZSIsInNldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJnZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMiLCJPVEVMUHJvdmlkZXJTaW5nbGV0b24iLCJnZXRPVEVMVHJhY2UiLCJnZXRPVEVMQ29udGV4dCIsInNldE9URUxJbnN0YW5jZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/otel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/traceable.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/traceable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* binding */ ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* binding */ getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* binding */ isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* binding */ withRunTree)\n/* harmony export */ });\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_, callback) {\n        return callback();\n    }\n}\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    initializeGlobalInstance(instance) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\nfunction getCurrentRunTree(permitAbsentRunTree = false) {\n    const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    if (!permitAbsentRunTree && runTree === undefined) {\n        throw new Error(\"Could not get the current run tree.\\n\\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.\");\n    }\n    return runTree;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withRunTree(runTree, fn) {\n    const storage = AsyncLocalStorageProviderSingleton.getInstance();\n    return new Promise((resolve, reject)=>{\n        storage.run(runTree, ()=>void Promise.resolve(fn()).then(resolve).catch(reject));\n    });\n}\nconst ROOT = Symbol.for(\"langsmith:traceable:root\");\nfunction isTraceableFunction(x) {\n    return typeof x === \"function\" && \"langsmith:traceable\" in x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy90cmFjZWFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxNQUFNQTtJQUNGQyxXQUFXO1FBQ1AsT0FBT0M7SUFDWDtJQUNBQyxJQUFJQyxDQUFDLEVBQUVDLFFBQVEsRUFBRTtRQUNiLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLGtCQUFrQkMsT0FBT0MsR0FBRyxDQUFDO0FBQ25DLE1BQU1DLHdCQUF3QixJQUFJVDtBQUNsQyxNQUFNVTtJQUNGQyxjQUFjO1FBQ1YsOERBQThEO1FBQzlELE9BQU9DLFVBQVUsQ0FBQ04sZ0JBQWdCLElBQUlHO0lBQzFDO0lBQ0FJLHlCQUF5QkMsUUFBUSxFQUFFO1FBQy9CLDhEQUE4RDtRQUM5RCxJQUFJRixVQUFVLENBQUNOLGdCQUFnQixLQUFLSixXQUFXO1lBQzNDLDhEQUE4RDtZQUM5RFUsVUFBVSxDQUFDTixnQkFBZ0IsR0FBR1E7UUFDbEM7SUFDSjtBQUNKO0FBQ08sTUFBTUMscUNBQXFDLElBQUlMLDRCQUE0QjtBQUMzRSxTQUFTTSxrQkFBa0JDLHNCQUFzQixLQUFLO0lBQ3pELE1BQU1DLFVBQVVILG1DQUFtQ0osV0FBVyxHQUFHVixRQUFRO0lBQ3pFLElBQUksQ0FBQ2dCLHVCQUF1QkMsWUFBWWhCLFdBQVc7UUFDL0MsTUFBTSxJQUFJaUIsTUFBTTtJQUNwQjtJQUNBLE9BQU9EO0FBQ1g7QUFDQSw4REFBOEQ7QUFDdkQsU0FBU0UsWUFBWUYsT0FBTyxFQUFFRyxFQUFFO0lBQ25DLE1BQU1DLFVBQVVQLG1DQUFtQ0osV0FBVztJQUM5RCxPQUFPLElBQUlZLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDekJILFFBQVFuQixHQUFHLENBQUNlLFNBQVMsSUFBTSxLQUFLSyxRQUFRQyxPQUFPLENBQUNILE1BQU1LLElBQUksQ0FBQ0YsU0FBU0csS0FBSyxDQUFDRjtJQUM5RTtBQUNKO0FBQ08sTUFBTUcsT0FBT3JCLE9BQU9DLEdBQUcsQ0FBQyw0QkFBNEI7QUFDcEQsU0FBU3FCLG9CQUFvQkMsQ0FBQztJQUdqQyxPQUFPLE9BQU9BLE1BQU0sY0FBYyx5QkFBeUJBO0FBQy9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzPzcyMjMiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTW9ja0FzeW5jTG9jYWxTdG9yYWdlIHtcbiAgICBnZXRTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcnVuKF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmNvbnN0IFRSQUNJTkdfQUxTX0tFWSA9IFN5bWJvbC5mb3IoXCJsczp0cmFjaW5nX2FzeW5jX2xvY2FsX3N0b3JhZ2VcIik7XG5jb25zdCBtb2NrQXN5bmNMb2NhbFN0b3JhZ2UgPSBuZXcgTW9ja0FzeW5jTG9jYWxTdG9yYWdlKCk7XG5jbGFzcyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyIHtcbiAgICBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA/PyBtb2NrQXN5bmNMb2NhbFN0b3JhZ2U7XG4gICAgfVxuICAgIGluaXRpYWxpemVHbG9iYWxJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBpZiAoZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIoKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50UnVuVHJlZShwZXJtaXRBYnNlbnRSdW5UcmVlID0gZmFsc2UpIHtcbiAgICBjb25zdCBydW5UcmVlID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpLmdldFN0b3JlKCk7XG4gICAgaWYgKCFwZXJtaXRBYnNlbnRSdW5UcmVlICYmIHJ1blRyZWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IHRoZSBjdXJyZW50IHJ1biB0cmVlLlxcblxcblBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGhpbiBhIHRyYWNlYWJsZSBmdW5jdGlvbiBhbmQgdGhhdCB0cmFjaW5nIGlzIGVuYWJsZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuVHJlZTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gd2l0aFJ1blRyZWUocnVuVHJlZSwgZm4pIHtcbiAgICBjb25zdCBzdG9yYWdlID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHN0b3JhZ2UucnVuKHJ1blRyZWUsICgpID0+IHZvaWQgUHJvbWlzZS5yZXNvbHZlKGZuKCkpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KSk7XG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgUk9PVCA9IFN5bWJvbC5mb3IoXCJsYW5nc21pdGg6dHJhY2VhYmxlOnJvb3RcIik7XG5leHBvcnQgZnVuY3Rpb24gaXNUcmFjZWFibGVGdW5jdGlvbih4XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgJiYgXCJsYW5nc21pdGg6dHJhY2VhYmxlXCIgaW4geDtcbn1cbiJdLCJuYW1lcyI6WyJNb2NrQXN5bmNMb2NhbFN0b3JhZ2UiLCJnZXRTdG9yZSIsInVuZGVmaW5lZCIsInJ1biIsIl8iLCJjYWxsYmFjayIsIlRSQUNJTkdfQUxTX0tFWSIsIlN5bWJvbCIsImZvciIsIm1vY2tBc3luY0xvY2FsU3RvcmFnZSIsIkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIiLCJnZXRJbnN0YW5jZSIsImdsb2JhbFRoaXMiLCJpbml0aWFsaXplR2xvYmFsSW5zdGFuY2UiLCJpbnN0YW5jZSIsIkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24iLCJnZXRDdXJyZW50UnVuVHJlZSIsInBlcm1pdEFic2VudFJ1blRyZWUiLCJydW5UcmVlIiwiRXJyb3IiLCJ3aXRoUnVuVHJlZSIsImZuIiwic3RvcmFnZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsImNhdGNoIiwiUk9PVCIsImlzVHJhY2VhYmxlRnVuY3Rpb24iLCJ4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/traceable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/_uuid.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/_uuid.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertUuid: () => (/* binding */ assertUuid)\n/* harmony export */ });\n// Relaxed UUID validation regex (allows any valid UUID format including nil UUIDs)\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\nfunction assertUuid(str, which) {\n    // Use relaxed regex validation instead of strict uuid.validate()\n    // This allows edge cases like nil UUIDs or test UUIDs that might not pass strict validation\n    if (!UUID_REGEX.test(str)) {\n        const msg = which !== undefined ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;\n        throw new Error(msg);\n    }\n    return str;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG1GQUFtRjtBQUNuRixNQUFNQSxhQUFhO0FBQ1osU0FBU0MsV0FBV0MsR0FBRyxFQUFFQyxLQUFLO0lBQ2pDLGlFQUFpRTtJQUNqRSw0RkFBNEY7SUFDNUYsSUFBSSxDQUFDSCxXQUFXSSxJQUFJLENBQUNGLE1BQU07UUFDdkIsTUFBTUcsTUFBTUYsVUFBVUcsWUFDaEIsQ0FBQyxpQkFBaUIsRUFBRUgsTUFBTSxFQUFFLEVBQUVELElBQUksQ0FBQyxHQUNuQyxDQUFDLGNBQWMsRUFBRUEsSUFBSSxDQUFDO1FBQzVCLE1BQU0sSUFBSUssTUFBTUY7SUFDcEI7SUFDQSxPQUFPSDtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL191dWlkLmpzP2M2YjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmVsYXhlZCBVVUlEIHZhbGlkYXRpb24gcmVnZXggKGFsbG93cyBhbnkgdmFsaWQgVVVJRCBmb3JtYXQgaW5jbHVkaW5nIG5pbCBVVUlEcylcbmNvbnN0IFVVSURfUkVHRVggPSAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvaTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVdWlkKHN0ciwgd2hpY2gpIHtcbiAgICAvLyBVc2UgcmVsYXhlZCByZWdleCB2YWxpZGF0aW9uIGluc3RlYWQgb2Ygc3RyaWN0IHV1aWQudmFsaWRhdGUoKVxuICAgIC8vIFRoaXMgYWxsb3dzIGVkZ2UgY2FzZXMgbGlrZSBuaWwgVVVJRHMgb3IgdGVzdCBVVUlEcyB0aGF0IG1pZ2h0IG5vdCBwYXNzIHN0cmljdCB2YWxpZGF0aW9uXG4gICAgaWYgKCFVVUlEX1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgICAgICBjb25zdCBtc2cgPSB3aGljaCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGBJbnZhbGlkIFVVSUQgZm9yICR7d2hpY2h9OiAke3N0cn1gXG4gICAgICAgICAgICA6IGBJbnZhbGlkIFVVSUQ6ICR7c3RyfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuIl0sIm5hbWVzIjpbIlVVSURfUkVHRVgiLCJhc3NlcnRVdWlkIiwic3RyIiwid2hpY2giLCJ0ZXN0IiwibXNnIiwidW5kZWZpbmVkIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n\n\n\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408\n];\nconst STATUS_IGNORE = [\n    409\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */ class AsyncCaller {\n    constructor(params){\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.debug = params.debug;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency\n            });\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({\n                concurrency: this.maxConcurrency\n            });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const onFailedResponseHook = this.onFailedResponseHook;\n        return this.queue.add(()=>p_retry__WEBPACK_IMPORTED_MODULE_0__(()=>callable(...args).catch((error)=>{\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (error instanceof Error) {\n                        throw error;\n                    } else {\n                        throw new Error(error);\n                    }\n                }), {\n                async onFailedAttempt (error) {\n                    if (error.message.startsWith(\"Cancel\") || error.message.startsWith(\"TimeoutError\") || error.message.startsWith(\"AbortError\")) {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    if (error?.code === \"ECONNABORTED\") {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response = error?.response;\n                    const status = response?.status;\n                    if (status) {\n                        if (STATUS_NO_RETRY.includes(+status)) {\n                            throw error;\n                        } else if (STATUS_IGNORE.includes(+status)) {\n                            return;\n                        }\n                        if (onFailedResponseHook) {\n                            await onFailedResponseHook(response);\n                        }\n                    }\n                },\n                // If needed we can change some of the defaults here,\n                // but they're quite sensible.\n                retries: this.maxRetries,\n                randomize: true\n            }), {\n            throwOnTimeout: true\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject)=>{\n                    options.signal?.addEventListener(\"abort\", ()=>{\n                        reject(new Error(\"AbortError\"));\n                    });\n                })\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(()=>(0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__._getFetchImplementation)(this.debug)(...args).then((res)=>res.ok ? res : Promise.reject(res)));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkI7QUFDRztBQUNpQztBQUNqRSxNQUFNRyxrQkFBa0I7SUFDcEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMsZ0JBQWdCO0lBQ2xCO0NBQ0g7QUFDRDs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxNQUFNQztJQUNUQyxZQUFZQyxNQUFNLENBQUU7UUFDaEJDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCO1lBQzFDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjO1lBQ3RDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxTQUFTO1lBQ2pDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSx3QkFBd0I7WUFDaERDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ0MsY0FBYyxHQUFHUCxPQUFPTyxjQUFjLElBQUlDO1FBQy9DLElBQUksQ0FBQ0MsVUFBVSxHQUFHVCxPQUFPUyxVQUFVLElBQUk7UUFDdkMsSUFBSSxDQUFDQyxLQUFLLEdBQUdWLE9BQU9VLEtBQUs7UUFDekIsSUFBSSxLQUFzQmhCLEVBQUU7WUFDeEIsOERBQThEO1lBQzlELElBQUksQ0FBQ2lCLEtBQUssR0FBRyxJQUFJakIsK0NBQWlCLENBQUM7Z0JBQy9CbUIsYUFBYSxJQUFJLENBQUNOLGNBQWM7WUFDcEM7UUFDSixPQUNLO1lBQ0QsOERBQThEO1lBQzlELElBQUksQ0FBQ0ksS0FBSyxHQUFHLElBQUlqQixvQ0FBU0EsQ0FBQztnQkFBRW1CLGFBQWEsSUFBSSxDQUFDTixjQUFjO1lBQUM7UUFDbEU7UUFDQSxJQUFJLENBQUNPLG9CQUFvQixHQUFHZCxRQUFRYztJQUN4QztJQUNBLDhEQUE4RDtJQUM5REMsS0FBS0MsUUFBUSxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUNwQixNQUFNSCx1QkFBdUIsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdEQsT0FBTyxJQUFJLENBQUNILEtBQUssQ0FBQ08sR0FBRyxDQUFDLElBQU16QixvQ0FBTUEsQ0FBQyxJQUFNdUIsWUFBWUMsTUFBTUUsS0FBSyxDQUFDLENBQUNDO29CQUM5RCx1REFBdUQ7b0JBQ3ZELElBQUlBLGlCQUFpQkMsT0FBTzt3QkFDeEIsTUFBTUQ7b0JBQ1YsT0FDSzt3QkFDRCxNQUFNLElBQUlDLE1BQU1EO29CQUNwQjtnQkFDSixJQUFJO2dCQUNBLE1BQU1FLGlCQUFnQkYsS0FBSztvQkFDdkIsSUFBSUEsTUFBTUcsT0FBTyxDQUFDQyxVQUFVLENBQUMsYUFDekJKLE1BQU1HLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDLG1CQUN6QkosTUFBTUcsT0FBTyxDQUFDQyxVQUFVLENBQUMsZUFBZTt3QkFDeEMsTUFBTUo7b0JBQ1Y7b0JBQ0EsOERBQThEO29CQUM5RCxJQUFJQSxPQUFPSyxTQUFTLGdCQUFnQjt3QkFDaEMsTUFBTUw7b0JBQ1Y7b0JBQ0EsOERBQThEO29CQUM5RCxNQUFNTSxXQUFXTixPQUFPTTtvQkFDeEIsTUFBTUMsU0FBU0QsVUFBVUM7b0JBQ3pCLElBQUlBLFFBQVE7d0JBQ1IsSUFBSS9CLGdCQUFnQmdDLFFBQVEsQ0FBQyxDQUFDRCxTQUFTOzRCQUNuQyxNQUFNUDt3QkFDVixPQUNLLElBQUl2QixjQUFjK0IsUUFBUSxDQUFDLENBQUNELFNBQVM7NEJBQ3RDO3dCQUNKO3dCQUNBLElBQUliLHNCQUFzQjs0QkFDdEIsTUFBTUEscUJBQXFCWTt3QkFDL0I7b0JBQ0o7Z0JBQ0o7Z0JBQ0EscURBQXFEO2dCQUNyRCw4QkFBOEI7Z0JBQzlCRyxTQUFTLElBQUksQ0FBQ3BCLFVBQVU7Z0JBQ3hCcUIsV0FBVztZQUNmLElBQUk7WUFBRUMsZ0JBQWdCO1FBQUs7SUFDL0I7SUFDQSw4REFBOEQ7SUFDOURDLGdCQUFnQkMsT0FBTyxFQUFFakIsUUFBUSxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUN4QyxtREFBbUQ7UUFDbkQsd0VBQXdFO1FBQ3hFLElBQUlnQixRQUFRQyxNQUFNLEVBQUU7WUFDaEIsT0FBT0MsUUFBUUMsSUFBSSxDQUFDO2dCQUNoQixJQUFJLENBQUNyQixJQUFJLENBQUNDLGFBQWFDO2dCQUN2QixJQUFJa0IsUUFBUSxDQUFDRSxHQUFHQztvQkFDWkwsUUFBUUMsTUFBTSxFQUFFSyxpQkFBaUIsU0FBUzt3QkFDdENELE9BQU8sSUFBSWpCLE1BQU07b0JBQ3JCO2dCQUNKO2FBQ0g7UUFDTDtRQUNBLE9BQU8sSUFBSSxDQUFDTixJQUFJLENBQUNDLGFBQWFDO0lBQ2xDO0lBQ0F1QixNQUFNLEdBQUd2QixJQUFJLEVBQUU7UUFDWCxPQUFPLElBQUksQ0FBQ0YsSUFBSSxDQUFDLElBQU1wQiw2RUFBdUJBLENBQUMsSUFBSSxDQUFDZSxLQUFLLEtBQUtPLE1BQU13QixJQUFJLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsRUFBRSxHQUFHRCxNQUFNUCxRQUFRRyxNQUFNLENBQUNJO0lBQ3BIO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzP2E4ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBSZXRyeSBmcm9tIFwicC1yZXRyeVwiO1xuaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xuaW1wb3J0IHsgX2dldEZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCwgLy8gQmFkIFJlcXVlc3RcbiAgICA0MDEsIC8vIFVuYXV0aG9yaXplZFxuICAgIDQwMywgLy8gRm9yYmlkZGVuXG4gICAgNDA0LCAvLyBOb3QgRm91bmRcbiAgICA0MDUsIC8vIE1ldGhvZCBOb3QgQWxsb3dlZFxuICAgIDQwNiwgLy8gTm90IEFjY2VwdGFibGVcbiAgICA0MDcsIC8vIFByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXG4gICAgNDA4LCAvLyBSZXF1ZXN0IFRpbWVvdXRcbl07XG5jb25zdCBTVEFUVVNfSUdOT1JFID0gW1xuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFzeW5jIGNhbGxzIHdpdGggY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtYWtpbmcgY2FsbHMgdG8gYW55IGtpbmQgb2YgXCJleHBlbnNpdmVcIiBleHRlcm5hbCByZXNvdXJjZSxcbiAqIGJlIGl0IGJlY2F1c2UgaXQncyByYXRlLWxpbWl0ZWQsIHN1YmplY3QgdG8gbmV0d29yayBpc3N1ZXMsIGV0Yy5cbiAqXG4gKiBDb25jdXJyZW50IGNhbGxzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHNcbiAqIHRvIGBJbmZpbml0eWAuIFRoaXMgbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBhbGwgY2FsbHMgd2lsbCBiZSBtYWRlIGluIHBhcmFsbGVsLlxuICpcbiAqIFJldHJpZXMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhSZXRyaWVzYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIDYuIFRoaXNcbiAqIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgZWFjaCBjYWxsIHdpbGwgYmUgcmV0cmllZCB1cCB0byA2IHRpbWVzLCB3aXRoIGFuXG4gKiBleHBvbmVudGlhbCBiYWNrb2ZmIGJldHdlZW4gZWFjaCBhdHRlbXB0LlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNDYWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhSZXRyaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkUmVzcG9uc2VIb29rXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwYXJhbXMubWF4Q29uY3VycmVuY3kgPz8gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IHBhcmFtcy5tYXhSZXRyaWVzID8/IDY7XG4gICAgICAgIHRoaXMuZGVidWcgPSBwYXJhbXMuZGVidWc7XG4gICAgICAgIGlmIChcImRlZmF1bHRcIiBpbiBQUXVldWVNb2QpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZU1vZC5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlTW9kKHsgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3kgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vayA9IHBhcmFtcz8ub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbChjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBvbkZhaWxlZFJlc3BvbnNlSG9vayA9IHRoaXMub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGFzeW5jIG9uRmFpbGVkQXR0ZW1wdChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiVGltZW91dEVycm9yXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyb3I/LnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlPy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoU1RBVFVTX05PX1JFVFJZLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTVEFUVVNfSUdOT1JFLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRmFpbGVkUmVzcG9uc2VIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBvbkZhaWxlZFJlc3BvbnNlSG9vayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkIHdlIGNhbiBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVmYXVsdHMgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGV5J3JlIHF1aXRlIHNlbnNpYmxlLlxuICAgICAgICAgICAgcmV0cmllczogdGhpcy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KSwgeyB0aHJvd09uVGltZW91dDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsV2l0aE9wdGlvbnMob3B0aW9ucywgY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gTm90ZSB0aGlzIGRvZXNuJ3QgY2FuY2VsIHRoZSB1bmRlcmx5aW5nIHJlcXVlc3QsXG4gICAgICAgIC8vIHdoZW4gYXZhaWxhYmxlIHByZWZlciB0byB1c2UgdGhlIHNpZ25hbCBvcHRpb24gb2YgdGhlIHVuZGVybHlpbmcgY2FsbFxuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyksXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZmV0Y2goLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCgpID0+IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpKC4uLmFyZ3MpLnRoZW4oKHJlcykgPT4gcmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJwUmV0cnkiLCJQUXVldWVNb2QiLCJfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiIsIlNUQVRVU19OT19SRVRSWSIsIlNUQVRVU19JR05PUkUiLCJBc3luY0NhbGxlciIsImNvbnN0cnVjdG9yIiwicGFyYW1zIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIm1heENvbmN1cnJlbmN5IiwiSW5maW5pdHkiLCJtYXhSZXRyaWVzIiwiZGVidWciLCJxdWV1ZSIsImRlZmF1bHQiLCJjb25jdXJyZW5jeSIsIm9uRmFpbGVkUmVzcG9uc2VIb29rIiwiY2FsbCIsImNhbGxhYmxlIiwiYXJncyIsImFkZCIsImNhdGNoIiwiZXJyb3IiLCJFcnJvciIsIm9uRmFpbGVkQXR0ZW1wdCIsIm1lc3NhZ2UiLCJzdGFydHNXaXRoIiwiY29kZSIsInJlc3BvbnNlIiwic3RhdHVzIiwiaW5jbHVkZXMiLCJyZXRyaWVzIiwicmFuZG9taXplIiwidGhyb3dPblRpbWVvdXQiLCJjYWxsV2l0aE9wdGlvbnMiLCJvcHRpb25zIiwic2lnbmFsIiwiUHJvbWlzZSIsInJhY2UiLCJfIiwicmVqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImZldGNoIiwidGhlbiIsInJlcyIsIm9rIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getEnvironmentVariables: () => (/* binding */ getEnvironmentVariables),\n/* harmony export */   getLangChainEnvVars: () => (/* binding */ getLangChainEnvVars),\n/* harmony export */   getLangChainEnvVarsMetadata: () => (/* binding */ getLangChainEnvVarsMetadata),\n/* harmony export */   getLangSmithEnvironmentVariable: () => (/* binding */ getLangSmithEnvironmentVariable),\n/* harmony export */   getOtelEnabled: () => (/* binding */ getOtelEnabled),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = ()=> false && 0;\nconst isWebWorker = ()=>typeof globalThis === \"object\" && globalThis.constructor && globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = ()=> false || typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"jsdom\");\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = ()=>typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = ()=>typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\" && !isDeno();\nconst getEnv = ()=>{\n    if (globalEnv) {\n        return globalEnv;\n    }\n    if (isBrowser()) {\n        globalEnv = \"browser\";\n    } else if (isNode()) {\n        globalEnv = \"node\";\n    } else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    } else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    } else if (isDeno()) {\n        globalEnv = \"deno\";\n    } else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nfunction getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangChain-specific environment variables from the current runtime environment.\n * Sensitive keys (containing the word \"key\", \"token\", or \"secret\") have their values redacted for security.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific environment variables.\n */ function getLangChainEnvVars() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\") {\n            envVars[key] = value;\n        }\n    }\n    for(const key in envVars){\n        if ((key.toLowerCase().includes(\"key\") || key.toLowerCase().includes(\"secret\") || key.toLowerCase().includes(\"token\")) && typeof envVars[key] === \"string\") {\n            const value = envVars[key];\n            envVars[key] = value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the LangChain-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific metadata environment variables.\n */ function getLangChainEnvVarsMetadata() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\",\n        \"LANGSMITH_API_KEY\",\n        \"LANGSMITH_ENDPOINT\",\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGSMITH_PROJECT\",\n        \"LANGSMITH_SESSION\"\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if ((key.startsWith(\"LANGCHAIN_\") || key.startsWith(\"LANGSMITH_\")) && typeof value === \"string\" && !excluded.includes(key) && !key.toLowerCase().includes(\"key\") && !key.toLowerCase().includes(\"secret\") && !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            } else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the environment variables from the current runtime environment.\n *\n * This function is designed to operate in a variety of JS environments,\n * including Node.js, Deno, browsers, etc.\n *\n * @returns {Record<string, string> | undefined}\n *  - A record of environment variables if available.\n *  - `undefined` if the environment does not support or allows access to environment variables.\n */ function getEnvironmentVariables() {\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            return Object.entries(process.env).reduce((acc, [key, value])=>{\n                acc[key] = String(value);\n                return acc;\n            }, {});\n        }\n        // For browsers and other environments, we may not have direct access to env variables\n        // Return undefined or any other fallback as required.\n        return undefined;\n    } catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n        return undefined;\n    }\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\" ? process.env?.[name] : undefined;\n    } catch (e) {\n        return undefined;\n    }\n}\nfunction getLangSmithEnvironmentVariable(name) {\n    return getEnvironmentVariable(`LANGSMITH_${name}`) || getEnvironmentVariable(`LANGCHAIN_${name}`);\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */ function getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\"\n    ];\n    const shas = {};\n    for (const env of common_release_envs){\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\nfunction getOtelEnabled() {\n    return getEnvironmentVariable(\"OTEL_ENABLED\") === \"true\" || getLangSmithEnvironmentVariable(\"OTEL_ENABLED\") === \"true\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2REFBNkQ7QUFDbkI7QUFDMUMsSUFBSUM7QUFDRyxNQUFNQyxZQUFZLElBQU0sTUFBNkIsSUFBSSxDQUFzQyxDQUFDO0FBQ2hHLE1BQU1HLGNBQWMsSUFBTSxPQUFPQyxlQUFlLFlBQ25EQSxXQUFXQyxXQUFXLElBQ3RCRCxXQUFXQyxXQUFXLENBQUNDLElBQUksS0FBSyw2QkFBNkI7QUFDMUQsTUFBTUMsVUFBVSxJQUFNLE1BQTBELElBQ2xGLE9BQU9DLGNBQWMsZUFBZUEsVUFBVUMsU0FBUyxDQUFDQyxRQUFRLENBQUMsU0FBVTtBQUNoRix5REFBeUQ7QUFDekQsNkJBQTZCO0FBQ3RCLE1BQU1DLFNBQVMsSUFBTSxPQUFPQyxTQUFTLFlBQVk7QUFDeEQsZ0RBQWdEO0FBQ3pDLE1BQU1DLFNBQVMsSUFBTSxPQUFPQyxZQUFZLGVBQzNDLE9BQU9BLFFBQVFDLFFBQVEsS0FBSyxlQUM1QixPQUFPRCxRQUFRQyxRQUFRLENBQUNDLElBQUksS0FBSyxlQUNqQyxDQUFDTCxTQUFTO0FBQ1AsTUFBTU0sU0FBUztJQUNsQixJQUFJbEIsV0FBVztRQUNYLE9BQU9BO0lBQ1g7SUFDQSxJQUFJQyxhQUFhO1FBQ2JELFlBQVk7SUFDaEIsT0FDSyxJQUFJYyxVQUFVO1FBQ2ZkLFlBQVk7SUFDaEIsT0FDSyxJQUFJSSxlQUFlO1FBQ3BCSixZQUFZO0lBQ2hCLE9BQ0ssSUFBSVEsV0FBVztRQUNoQlIsWUFBWTtJQUNoQixPQUNLLElBQUlZLFVBQVU7UUFDZlosWUFBWTtJQUNoQixPQUNLO1FBQ0RBLFlBQVk7SUFDaEI7SUFDQSxPQUFPQTtBQUNYLEVBQUU7QUFDRixJQUFJbUI7QUFDRyxTQUFTQztJQUNaLElBQUlELHVCQUF1QkUsV0FBVztRQUNsQyxNQUFNQyxNQUFNSjtRQUNaLE1BQU1LLGFBQWFDO1FBQ25CTCxxQkFBcUI7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QUFDSjtBQUNPLFNBQVM0QixnQ0FBZ0MxQyxJQUFJO0lBQ2hELE9BQVF5Qyx1QkFBdUIsQ0FBQyxVQUFVLEVBQUV6QyxLQUFLLENBQUMsS0FDOUN5Qyx1QkFBdUIsQ0FBQyxVQUFVLEVBQUV6QyxLQUFLLENBQUM7QUFDbEQ7QUFDTyxTQUFTMkMsdUJBQXVCM0MsSUFBSSxFQUFFMkIsS0FBSztJQUM5QyxJQUFJLE9BQU9uQixZQUFZLGFBQWE7UUFDaEMsMENBQTBDO1FBQzFDQSxRQUFRTyxHQUFHLENBQUNmLEtBQUssR0FBRzJCO0lBQ3hCO0FBQ0o7QUFDQSxJQUFJaUI7QUFDSjs7OztDQUlDLEdBQ00sU0FBUzNCO0lBQ1osSUFBSTJCLHFCQUFxQjlCLFdBQVc7UUFDaEMsT0FBTzhCO0lBQ1g7SUFDQSxNQUFNQyxzQkFBc0I7UUFDeEI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU1DLE9BQU8sQ0FBQztJQUNkLEtBQUssTUFBTS9CLE9BQU84QixvQkFBcUI7UUFDbkMsTUFBTUUsU0FBU04sdUJBQXVCMUI7UUFDdEMsSUFBSWdDLFdBQVdqQyxXQUFXO1lBQ3RCZ0MsSUFBSSxDQUFDL0IsSUFBSSxHQUFHZ0M7UUFDaEI7SUFDSjtJQUNBSCxtQkFBbUJFO0lBQ25CLE9BQU9BO0FBQ1g7QUFDTyxTQUFTRTtJQUNaLE9BQVFQLHVCQUF1QixvQkFBb0IsVUFDL0NDLGdDQUFnQyxvQkFBb0I7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzP2E3NDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5saW5lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGV4ZGluZXNoL2Jyb3dzZXItb3Itbm9kZVxuaW1wb3J0IHsgX192ZXJzaW9uX18gfSBmcm9tIFwiLi4vaW5kZXguanNcIjtcbmxldCBnbG9iYWxFbnY7XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyID0gKCkgPT4gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkRlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXCI7XG5leHBvcnQgY29uc3QgaXNKc0RvbSA9ICgpID0+ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYW1lID09PSBcIm5vZGVqc1wiKSB8fFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJqc2RvbVwiKSk7XG4vLyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIHByb3ZpZGVzIGEgYERlbm9gIGdsb2JhbCBvYmplY3Rcbi8vIHdpdGhvdXQgYHZlcnNpb25gIHByb3BlcnR5XG5leHBvcnQgY29uc3QgaXNEZW5vID0gKCkgPT4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCI7XG4vLyBNYXJrIG5vdC1hcy1ub2RlIGlmIGluIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb25cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAoKSA9PiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICFpc0Rlbm8oKTtcbmV4cG9ydCBjb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbEVudikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsRW52O1xuICAgIH1cbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJicm93c2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwibm9kZVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwid2Vid29ya2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSnNEb20oKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImpzZG9tXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVubygpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwiZGVub1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJvdGhlclwiO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsRW52O1xufTtcbmxldCBydW50aW1lRW52aXJvbm1lbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIGlmIChydW50aW1lRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnYgPSBnZXRFbnYoKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUVudiA9IGdldFNoYXMoKTtcbiAgICAgICAgcnVudGltZUVudmlyb25tZW50ID0ge1xuICAgICAgICAgICAgbGlicmFyeTogXCJsYW5nc21pdGhcIixcbiAgICAgICAgICAgIHJ1bnRpbWU6IGVudixcbiAgICAgICAgICAgIHNkazogXCJsYW5nc21pdGgtanNcIixcbiAgICAgICAgICAgIHNka192ZXJzaW9uOiBfX3ZlcnNpb25fXyxcbiAgICAgICAgICAgIC4uLnJlbGVhc2VFbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgTGFuZ0NoYWluLXNwZWNpZmljIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBTZW5zaXRpdmUga2V5cyAoY29udGFpbmluZyB0aGUgd29yZCBcImtleVwiLCBcInRva2VuXCIsIG9yIFwic2VjcmV0XCIpIGhhdmUgdGhlaXIgdmFsdWVzIHJlZGFjdGVkIGZvciBzZWN1cml0eS5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqICAtIEEgcmVjb3JkIG9mIExhbmdDaGFpbi1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nQ2hhaW5FbnZWYXJzKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhbGxFbnZWYXJzKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJMQU5HQ0hBSU5fXCIpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZW52VmFycykge1xuICAgICAgICBpZiAoKGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpIHx8XG4gICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNlY3JldFwiKSB8fFxuICAgICAgICAgICAga2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlblwiKSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlbnZWYXJzW2tleV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW52VmFyc1trZXldO1xuICAgICAgICAgICAgZW52VmFyc1trZXldID1cbiAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCAyKSArIFwiKlwiLnJlcGVhdCh2YWx1ZS5sZW5ndGggLSA0KSArIHZhbHVlLnNsaWNlKC0yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgbWV0YWRhdGEgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluLXNwZWNpZmljIG1ldGFkYXRhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBhbGxFbnZWYXJzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB8fCB7fTtcbiAgICBjb25zdCBlbnZWYXJzID0ge307XG4gICAgY29uc3QgZXhjbHVkZWQgPSBbXG4gICAgICAgIFwiTEFOR0NIQUlOX0FQSV9LRVlcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9QUk9KRUNUXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1NFU1NJT05cIixcbiAgICAgICAgXCJMQU5HU01JVEhfQVBJX0tFWVwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9FTkRQT0lOVFwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX1BST0pFQ1RcIixcbiAgICAgICAgXCJMQU5HU01JVEhfU0VTU0lPTlwiLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRW52VmFycykpIHtcbiAgICAgICAgaWYgKChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgfHwga2V5LnN0YXJ0c1dpdGgoXCJMQU5HU01JVEhfXCIpKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhZXhjbHVkZWQuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkxBTkdDSEFJTl9SRVZJU0lPTl9JRFwiKSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1tcInJldmlzaW9uX2lkXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gb3BlcmF0ZSBpbiBhIHZhcmlldHkgb2YgSlMgZW52aXJvbm1lbnRzLFxuICogaW5jbHVkaW5nIE5vZGUuanMsIERlbm8sIGJyb3dzZXJzLCBldGMuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWR9XG4gKiAgLSBBIHJlY29yZCBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaWYgYXZhaWxhYmxlLlxuICogIC0gYHVuZGVmaW5lZGAgaWYgdGhlIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgb3IgYWxsb3dzIGFjY2VzcyB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBicm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzLCB3ZSBtYXkgbm90IGhhdmUgZGlyZWN0IGFjY2VzcyB0byBlbnYgdmFyaWFibGVzXG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgb3IgYW55IG90aGVyIGZhbGxiYWNrIGFzIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDYXRjaCBhbnkgZXJyb3JzIHRoYXQgbWlnaHQgb2NjdXIgd2hpbGUgdHJ5aW5nIHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9od2NoYXNlMTcvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIHJldHVybiAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShgTEFOR1NNSVRIXyR7bmFtZX1gKSB8fFxuICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGBMQU5HQ0hBSU5fJHtuYW1lfWApKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICBwcm9jZXNzLmVudltuYW1lXSA9IHZhbHVlO1xuICAgIH1cbn1cbmxldCBjYWNoZWRDb21taXRTSEFzO1xuLyoqXG4gKiBHZXQgdGhlIEdpdCBjb21taXQgU0hBIGZyb20gY29tbW9uIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogdXNlZCBieSBkaWZmZXJlbnQgQ0kvQ0QgcGxhdGZvcm1zLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIEdpdCBjb21taXQgU0hBIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFzKCkge1xuICAgIGlmIChjYWNoZWRDb21taXRTSEFzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZENvbW1pdFNIQXM7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbl9yZWxlYXNlX2VudnMgPSBbXG4gICAgICAgIFwiVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiTkVYVF9QVUJMSUNfVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ09NTUlUX1JFRlwiLFxuICAgICAgICBcIlJFTkRFUl9HSVRfQ09NTUlUXCIsXG4gICAgICAgIFwiQ0lfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIkNJUkNMRV9TSEExXCIsXG4gICAgICAgIFwiQ0ZfUEFHRVNfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIlJFQUNUX0FQUF9HSVRfU0hBXCIsXG4gICAgICAgIFwiU09VUkNFX1ZFUlNJT05cIixcbiAgICAgICAgXCJHSVRIVUJfU0hBXCIsXG4gICAgICAgIFwiVFJBVklTX0NPTU1JVFwiLFxuICAgICAgICBcIkdJVF9DT01NSVRcIixcbiAgICAgICAgXCJCVUlMRF9WQ1NfTlVNQkVSXCIsXG4gICAgICAgIFwiYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JldmlzaW9uXCIsXG4gICAgICAgIFwiQnVpbGQuU291cmNlVmVyc2lvblwiLFxuICAgICAgICBcIkJJVEJVQ0tFVF9DT01NSVRcIixcbiAgICAgICAgXCJEUk9ORV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiU0VNQVBIT1JFX0dJVF9TSEFcIixcbiAgICAgICAgXCJCVUlMREtJVEVfQ09NTUlUXCIsXG4gICAgXTtcbiAgICBjb25zdCBzaGFzID0ge307XG4gICAgZm9yIChjb25zdCBlbnYgb2YgY29tbW9uX3JlbGVhc2VfZW52cykge1xuICAgICAgICBjb25zdCBlbnZWYXIgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGVudik7XG4gICAgICAgIGlmIChlbnZWYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2hhc1tlbnZdID0gZW52VmFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlZENvbW1pdFNIQXMgPSBzaGFzO1xuICAgIHJldHVybiBzaGFzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE90ZWxFbmFibGVkKCkge1xuICAgIHJldHVybiAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIk9URUxfRU5BQkxFRFwiKSA9PT0gXCJ0cnVlXCIgfHxcbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIk9URUxfRU5BQkxFRFwiKSA9PT0gXCJ0cnVlXCIpO1xufVxuIl0sIm5hbWVzIjpbIl9fdmVyc2lvbl9fIiwiZ2xvYmFsRW52IiwiaXNCcm93c2VyIiwid2luZG93IiwiZG9jdW1lbnQiLCJpc1dlYldvcmtlciIsImdsb2JhbFRoaXMiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJpc0pzRG9tIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5jbHVkZXMiLCJpc0Rlbm8iLCJEZW5vIiwiaXNOb2RlIiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsImdldEVudiIsInJ1bnRpbWVFbnZpcm9ubWVudCIsImdldFJ1bnRpbWVFbnZpcm9ubWVudCIsInVuZGVmaW5lZCIsImVudiIsInJlbGVhc2VFbnYiLCJnZXRTaGFzIiwibGlicmFyeSIsInJ1bnRpbWUiLCJzZGsiLCJzZGtfdmVyc2lvbiIsImdldExhbmdDaGFpbkVudlZhcnMiLCJhbGxFbnZWYXJzIiwiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMiLCJlbnZWYXJzIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwic3RhcnRzV2l0aCIsInRvTG93ZXJDYXNlIiwic2xpY2UiLCJyZXBlYXQiLCJsZW5ndGgiLCJnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEiLCJleGNsdWRlZCIsInJlZHVjZSIsImFjYyIsIlN0cmluZyIsImUiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsInNldEVudmlyb25tZW50VmFyaWFibGUiLCJjYWNoZWRDb21taXRTSEFzIiwiY29tbW9uX3JlbGVhc2VfZW52cyIsInNoYXMiLCJlbnZWYXIiLCJnZXRPdGVsRW5hYmxlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/error.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictingEndpointsError: () => (/* binding */ ConflictingEndpointsError),\n/* harmony export */   LangSmithConflictError: () => (/* binding */ LangSmithConflictError),\n/* harmony export */   isConflictingEndpointsError: () => (/* binding */ isConflictingEndpointsError),\n/* harmony export */   printErrorStackTrace: () => (/* binding */ printErrorStackTrace),\n/* harmony export */   raiseForStatus: () => (/* binding */ raiseForStatus)\n/* harmony export */ });\nfunction getErrorStackTrace(e) {\n    if (typeof e !== \"object\" || e == null) return undefined;\n    if (!(\"stack\" in e) || typeof e.stack !== \"string\") return undefined;\n    let stack = e.stack;\n    const prevLine = `${e}`;\n    if (stack.startsWith(prevLine)) {\n        stack = stack.slice(prevLine.length);\n    }\n    if (stack.startsWith(\"\\n\")) {\n        stack = stack.slice(1);\n    }\n    return stack;\n}\nfunction printErrorStackTrace(e) {\n    const stack = getErrorStackTrace(e);\n    if (stack == null) return;\n    console.error(stack);\n}\n/**\n * LangSmithConflictError\n *\n * Represents an error that occurs when there's a conflict during an operation,\n * typically corresponding to HTTP 409 status code responses.\n *\n * This error is thrown when an attempt to create or modify a resource conflicts\n * with the current state of the resource on the server. Common scenarios include:\n * - Attempting to create a resource that already exists\n * - Trying to update a resource that has been modified by another process\n * - Violating a uniqueness constraint in the data\n *\n * @extends Error\n *\n * @example\n * try {\n *   await createProject(\"existingProject\");\n * } catch (error) {\n *   if (error instanceof ConflictError) {\n *     console.log(\"A conflict occurred:\", error.message);\n *     // Handle the conflict, e.g., by suggesting a different project name\n *   } else {\n *     // Handle other types of errors\n *   }\n * }\n *\n * @property {string} name - Always set to 'ConflictError' for easy identification\n * @property {string} message - Detailed error message including server response\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\n */ class LangSmithConflictError extends Error {\n    constructor(message){\n        super(message);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"LangSmithConflictError\";\n        this.status = 409;\n    }\n}\n/**\n * Throws an appropriate error based on the response status and body.\n *\n * @param response - The fetch Response object\n * @param context - Additional context to include in the error message (e.g., operation being performed)\n * @throws {LangSmithConflictError} When the response status is 409\n * @throws {Error} For all other non-ok responses\n */ async function raiseForStatus(response, context, consume) {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    let errorBody;\n    if (response.ok) {\n        if (consume) {\n            errorBody = await response.text();\n        }\n        return;\n    }\n    errorBody = await response.text();\n    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;\n    if (response.status === 409) {\n        throw new LangSmithConflictError(fullMessage);\n    }\n    const err = new Error(fullMessage);\n    err.status = response.status;\n    throw err;\n}\nconst ERR_CONFLICTING_ENDPOINTS = \"ERR_CONFLICTING_ENDPOINTS\";\nclass ConflictingEndpointsError extends Error {\n    constructor(){\n        super(\"You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT \" + \"and LANGSMITH_RUNS_ENDPOINTS.\");\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: ERR_CONFLICTING_ENDPOINTS\n        });\n        this.name = \"ConflictingEndpointsError\"; // helpful in logs\n    }\n}\nfunction isConflictingEndpointsError(err) {\n    return typeof err === \"object\" && err !== null && err.code === ERR_CONFLICTING_ENDPOINTS;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxTQUFTQSxtQkFBbUJDLENBQUM7SUFDekIsSUFBSSxPQUFPQSxNQUFNLFlBQVlBLEtBQUssTUFDOUIsT0FBT0M7SUFDWCxJQUFJLENBQUUsWUFBV0QsQ0FBQUEsS0FBTSxPQUFPQSxFQUFFRSxLQUFLLEtBQUssVUFDdEMsT0FBT0Q7SUFDWCxJQUFJQyxRQUFRRixFQUFFRSxLQUFLO0lBQ25CLE1BQU1DLFdBQVcsQ0FBQyxFQUFFSCxFQUFFLENBQUM7SUFDdkIsSUFBSUUsTUFBTUUsVUFBVSxDQUFDRCxXQUFXO1FBQzVCRCxRQUFRQSxNQUFNRyxLQUFLLENBQUNGLFNBQVNHLE1BQU07SUFDdkM7SUFDQSxJQUFJSixNQUFNRSxVQUFVLENBQUMsT0FBTztRQUN4QkYsUUFBUUEsTUFBTUcsS0FBSyxDQUFDO0lBQ3hCO0lBQ0EsT0FBT0g7QUFDWDtBQUNPLFNBQVNLLHFCQUFxQlAsQ0FBQztJQUNsQyxNQUFNRSxRQUFRSCxtQkFBbUJDO0lBQ2pDLElBQUlFLFNBQVMsTUFDVDtJQUNKTSxRQUFRQyxLQUFLLENBQUNQO0FBQ2xCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThCQyxHQUNNLE1BQU1RLCtCQUErQkM7SUFDeENDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ05DLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBVTtZQUNsQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRztJQUNsQjtBQUNKO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNNLGVBQWVDLGVBQWVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBQzNELHNEQUFzRDtJQUN0RCxxREFBcUQ7SUFDckQsSUFBSUM7SUFDSixJQUFJSCxTQUFTSSxFQUFFLEVBQUU7UUFDYixJQUFJRixTQUFTO1lBQ1RDLFlBQVksTUFBTUgsU0FBU0ssSUFBSTtRQUNuQztRQUNBO0lBQ0o7SUFDQUYsWUFBWSxNQUFNSCxTQUFTSyxJQUFJO0lBQy9CLE1BQU1DLGNBQWMsQ0FBQyxVQUFVLEVBQUVMLFFBQVEsbUJBQW1CLEVBQUVELFNBQVNGLE1BQU0sQ0FBQyxHQUFHLEVBQUVFLFNBQVNPLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRUosVUFBVSxDQUFDO0lBQ3ZJLElBQUlILFNBQVNGLE1BQU0sS0FBSyxLQUFLO1FBQ3pCLE1BQU0sSUFBSVgsdUJBQXVCbUI7SUFDckM7SUFDQSxNQUFNRSxNQUFNLElBQUlwQixNQUFNa0I7SUFDdEJFLElBQUlWLE1BQU0sR0FBR0UsU0FBU0YsTUFBTTtJQUM1QixNQUFNVTtBQUNWO0FBQ0EsTUFBTUMsNEJBQTRCO0FBQzNCLE1BQU1DLGtDQUFrQ3RCO0lBQzNDQyxhQUFjO1FBQ1YsS0FBSyxDQUFDLHFFQUNGO1FBQ0pFLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBT2E7UUFDWDtRQUNBLElBQUksQ0FBQ1osSUFBSSxHQUFHLDZCQUE2QixrQkFBa0I7SUFDL0Q7QUFDSjtBQUNPLFNBQVNjLDRCQUE0QkgsR0FBRztJQUMzQyxPQUFRLE9BQU9BLFFBQVEsWUFDbkJBLFFBQVEsUUFDUkEsSUFBSUksSUFBSSxLQUFLSDtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9lcnJvci5qcz82Nzg2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldEVycm9yU3RhY2tUcmFjZShlKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9PSBcIm9iamVjdFwiIHx8IGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoIShcInN0YWNrXCIgaW4gZSkgfHwgdHlwZW9mIGUuc3RhY2sgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IHN0YWNrID0gZS5zdGFjaztcbiAgICBjb25zdCBwcmV2TGluZSA9IGAke2V9YDtcbiAgICBpZiAoc3RhY2suc3RhcnRzV2l0aChwcmV2TGluZSkpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShwcmV2TGluZS5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoc3RhY2suc3RhcnRzV2l0aChcIlxcblwiKSkge1xuICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRFcnJvclN0YWNrVHJhY2UoZSkge1xuICAgIGNvbnN0IHN0YWNrID0gZ2V0RXJyb3JTdGFja1RyYWNlKGUpO1xuICAgIGlmIChzdGFjayA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc29sZS5lcnJvcihzdGFjayk7XG59XG4vKipcbiAqIExhbmdTbWl0aENvbmZsaWN0RXJyb3JcbiAqXG4gKiBSZXByZXNlbnRzIGFuIGVycm9yIHRoYXQgb2NjdXJzIHdoZW4gdGhlcmUncyBhIGNvbmZsaWN0IGR1cmluZyBhbiBvcGVyYXRpb24sXG4gKiB0eXBpY2FsbHkgY29ycmVzcG9uZGluZyB0byBIVFRQIDQwOSBzdGF0dXMgY29kZSByZXNwb25zZXMuXG4gKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiBhbiBhdHRlbXB0IHRvIGNyZWF0ZSBvciBtb2RpZnkgYSByZXNvdXJjZSBjb25mbGljdHNcbiAqIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHJlc291cmNlIG9uIHRoZSBzZXJ2ZXIuIENvbW1vbiBzY2VuYXJpb3MgaW5jbHVkZTpcbiAqIC0gQXR0ZW1wdGluZyB0byBjcmVhdGUgYSByZXNvdXJjZSB0aGF0IGFscmVhZHkgZXhpc3RzXG4gKiAtIFRyeWluZyB0byB1cGRhdGUgYSByZXNvdXJjZSB0aGF0IGhhcyBiZWVuIG1vZGlmaWVkIGJ5IGFub3RoZXIgcHJvY2Vzc1xuICogLSBWaW9sYXRpbmcgYSB1bmlxdWVuZXNzIGNvbnN0cmFpbnQgaW4gdGhlIGRhdGFcbiAqXG4gKiBAZXh0ZW5kcyBFcnJvclxuICpcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICBhd2FpdCBjcmVhdGVQcm9qZWN0KFwiZXhpc3RpbmdQcm9qZWN0XCIpO1xuICogfSBjYXRjaCAoZXJyb3IpIHtcbiAqICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29uZmxpY3RFcnJvcikge1xuICogICAgIGNvbnNvbGUubG9nKFwiQSBjb25mbGljdCBvY2N1cnJlZDpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgICAgLy8gSGFuZGxlIHRoZSBjb25mbGljdCwgZS5nLiwgYnkgc3VnZ2VzdGluZyBhIGRpZmZlcmVudCBwcm9qZWN0IG5hbWVcbiAqICAgfSBlbHNlIHtcbiAqICAgICAvLyBIYW5kbGUgb3RoZXIgdHlwZXMgb2YgZXJyb3JzXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIEFsd2F5cyBzZXQgdG8gJ0NvbmZsaWN0RXJyb3InIGZvciBlYXN5IGlkZW50aWZpY2F0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtIERldGFpbGVkIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHNlcnZlciByZXNwb25zZVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDA5XG4gKi9cbmV4cG9ydCBjbGFzcyBMYW5nU21pdGhDb25mbGljdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkxhbmdTbWl0aENvbmZsaWN0RXJyb3JcIjtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSA0MDk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3MgYW4gYXBwcm9wcmlhdGUgZXJyb3IgYmFzZWQgb24gdGhlIHJlc3BvbnNlIHN0YXR1cyBhbmQgYm9keS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgZmV0Y2ggUmVzcG9uc2Ugb2JqZWN0XG4gKiBAcGFyYW0gY29udGV4dCAtIEFkZGl0aW9uYWwgY29udGV4dCB0byBpbmNsdWRlIGluIHRoZSBlcnJvciBtZXNzYWdlIChlLmcuLCBvcGVyYXRpb24gYmVpbmcgcGVyZm9ybWVkKVxuICogQHRocm93cyB7TGFuZ1NtaXRoQ29uZmxpY3RFcnJvcn0gV2hlbiB0aGUgcmVzcG9uc2Ugc3RhdHVzIGlzIDQwOVxuICogQHRocm93cyB7RXJyb3J9IEZvciBhbGwgb3RoZXIgbm9uLW9rIHJlc3BvbnNlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGNvbnRleHQsIGNvbnN1bWUpIHtcbiAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgIGxldCBlcnJvckJvZHk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGlmIChjb25zdW1lKSB7XG4gICAgICAgICAgICBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgRmFpbGVkIHRvICR7Y29udGV4dH0uIFJlY2VpdmVkIHN0YXR1cyBbJHtyZXNwb25zZS5zdGF0dXN9XTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fS4gU2VydmVyIHJlc3BvbnNlOiAke2Vycm9yQm9keX1gO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOSkge1xuICAgICAgICB0aHJvdyBuZXcgTGFuZ1NtaXRoQ29uZmxpY3RFcnJvcihmdWxsTWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihmdWxsTWVzc2FnZSk7XG4gICAgZXJyLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICB0aHJvdyBlcnI7XG59XG5jb25zdCBFUlJfQ09ORkxJQ1RJTkdfRU5EUE9JTlRTID0gXCJFUlJfQ09ORkxJQ1RJTkdfRU5EUE9JTlRTXCI7XG5leHBvcnQgY2xhc3MgQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJZb3UgY2Fubm90IHByb3ZpZGUgYm90aCBMQU5HU01JVEhfRU5EUE9JTlQgLyBMQU5HQ0hBSU5fRU5EUE9JTlQgXCIgK1xuICAgICAgICAgICAgXCJhbmQgTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTLlwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogRVJSX0NPTkZMSUNUSU5HX0VORFBPSU5UU1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDb25mbGljdGluZ0VuZHBvaW50c0Vycm9yXCI7IC8vIGhlbHBmdWwgaW4gbG9nc1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgZXJyID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVyciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnIuY29kZSA9PT0gRVJSX0NPTkZMSUNUSU5HX0VORFBPSU5UUyk7XG59XG4iXSwibmFtZXMiOlsiZ2V0RXJyb3JTdGFja1RyYWNlIiwiZSIsInVuZGVmaW5lZCIsInN0YWNrIiwicHJldkxpbmUiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJsZW5ndGgiLCJwcmludEVycm9yU3RhY2tUcmFjZSIsImNvbnNvbGUiLCJlcnJvciIsIkxhbmdTbWl0aENvbmZsaWN0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJuYW1lIiwic3RhdHVzIiwicmFpc2VGb3JTdGF0dXMiLCJyZXNwb25zZSIsImNvbnRleHQiLCJjb25zdW1lIiwiZXJyb3JCb2R5Iiwib2siLCJ0ZXh0IiwiZnVsbE1lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiZXJyIiwiRVJSX0NPTkZMSUNUSU5HX0VORFBPSU5UUyIsIkNvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IiLCJpc0NvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IiLCJjb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* eslint-disable */ // @ts-nocheck\n\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = {\n    result: \"[Circular]\"\n};\nvar arr = [];\nvar replacerStack = [];\nconst encoder = new TextEncoder();\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\nfunction encodeString(str) {\n    return encoder.encode(str);\n}\n// Shared function to handle well-known types\nfunction serializeWellKnownTypes(val) {\n    if (val && typeof val === \"object\" && val !== null) {\n        if (val instanceof Map) {\n            return Object.fromEntries(val);\n        } else if (val instanceof Set) {\n            return Array.from(val);\n        } else if (val instanceof Date) {\n            return val.toISOString();\n        } else if (val instanceof RegExp) {\n            return val.toString();\n        } else if (val instanceof Error) {\n            return {\n                name: val.name,\n                message: val.message\n            };\n        }\n    } else if (typeof val === \"bigint\") {\n        return val.toString();\n    }\n    return val;\n}\n// Default replacer function to handle well-known types\nfunction createDefaultReplacer(userReplacer) {\n    return function(key, val) {\n        // Apply user replacer first if provided\n        if (userReplacer) {\n            const userResult = userReplacer.call(this, key, val);\n            // If user replacer returned undefined, fall back to our serialization\n            if (userResult !== undefined) {\n                return userResult;\n            }\n        }\n        // Fall back to our well-known type handling\n        return serializeWellKnownTypes(val);\n    };\n}\n// Regular stringify\nfunction serialize(obj, errorContext, replacer, spacer, options) {\n    try {\n        const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);\n        return encodeString(str);\n    } catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n            return encodeString(\"[Unserializable]\");\n        }\n        (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"SUPPRESS_CIRCULAR_JSON_WARNINGS\") !== \"true\" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        let res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            } else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        } catch (_) {\n            return encodeString(\"[unable to serialize, circular reference is too complex to analyze]\");\n        } finally{\n            while(arr.length !== 0){\n                const part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                } else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return encodeString(res);\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, {\n                value: replace\n            });\n            arr.push([\n                parent,\n                k,\n                val,\n                propertyDescriptor\n            ]);\n        } else {\n            replacerStack.push([\n                val,\n                k,\n                replace\n            ]);\n        }\n    } else {\n        parent[k] = replace;\n        arr.push([\n            parent,\n            k,\n            val\n        ]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            var keys = Object.keys(val);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        } else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        // Ensure that we restore the object as it was.\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        } catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([\n                    parent,\n                    k,\n                    val\n                ]);\n                parent[k] = tmp;\n            } else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n        return v;\n    };\n    return function(key, val) {\n        if (replacerStack.length > 0) {\n            for(var i = 0; i < replacerStack.length; i++){\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGtCQUFrQixHQUNsQixjQUFjO0FBQ3VEO0FBQ3JFLElBQUlDLHFCQUFxQjtBQUN6QixJQUFJQyx3QkFBd0I7SUFBRUMsUUFBUTtBQUFhO0FBQ25ELElBQUlDLE1BQU0sRUFBRTtBQUNaLElBQUlDLGdCQUFnQixFQUFFO0FBQ3RCLE1BQU1DLFVBQVUsSUFBSUM7QUFDcEIsU0FBU0M7SUFDTCxPQUFPO1FBQ0hDLFlBQVlDLE9BQU9DLGdCQUFnQjtRQUNuQ0MsWUFBWUYsT0FBT0MsZ0JBQWdCO0lBQ3ZDO0FBQ0o7QUFDQSxTQUFTRSxhQUFhQyxHQUFHO0lBQ3JCLE9BQU9SLFFBQVFTLE1BQU0sQ0FBQ0Q7QUFDMUI7QUFDQSw2Q0FBNkM7QUFDN0MsU0FBU0Usd0JBQXdCQyxHQUFHO0lBQ2hDLElBQUlBLE9BQU8sT0FBT0EsUUFBUSxZQUFZQSxRQUFRLE1BQU07UUFDaEQsSUFBSUEsZUFBZUMsS0FBSztZQUNwQixPQUFPQyxPQUFPQyxXQUFXLENBQUNIO1FBQzlCLE9BQ0ssSUFBSUEsZUFBZUksS0FBSztZQUN6QixPQUFPQyxNQUFNQyxJQUFJLENBQUNOO1FBQ3RCLE9BQ0ssSUFBSUEsZUFBZU8sTUFBTTtZQUMxQixPQUFPUCxJQUFJUSxXQUFXO1FBQzFCLE9BQ0ssSUFBSVIsZUFBZVMsUUFBUTtZQUM1QixPQUFPVCxJQUFJVSxRQUFRO1FBQ3ZCLE9BQ0ssSUFBSVYsZUFBZVcsT0FBTztZQUMzQixPQUFPO2dCQUNIQyxNQUFNWixJQUFJWSxJQUFJO2dCQUNkQyxTQUFTYixJQUFJYSxPQUFPO1lBQ3hCO1FBQ0o7SUFDSixPQUNLLElBQUksT0FBT2IsUUFBUSxVQUFVO1FBQzlCLE9BQU9BLElBQUlVLFFBQVE7SUFDdkI7SUFDQSxPQUFPVjtBQUNYO0FBQ0EsdURBQXVEO0FBQ3ZELFNBQVNjLHNCQUFzQkMs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RTtvQkFDYmpELGNBQWM2RSxNQUFNLENBQUNaLEdBQUc7b0JBQ3hCO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLE9BQU85QixTQUFTTCxJQUFJLENBQUMsSUFBSSxFQUFFRixLQUFLaEI7SUFDcEM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzPzgxZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2Vudi5qc1wiO1xudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9IFwiWy4uLl1cIjtcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSB7IHJlc3VsdDogXCJbQ2lyY3VsYXJdXCIgfTtcbnZhciBhcnIgPSBbXTtcbnZhciByZXBsYWNlclN0YWNrID0gW107XG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgZWRnZXNMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyKTtcbn1cbi8vIFNoYXJlZCBmdW5jdGlvbiB0byBoYW5kbGUgd2VsbC1rbm93biB0eXBlc1xuZnVuY3Rpb24gc2VyaWFsaXplV2VsbEtub3duVHlwZXModmFsKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB2YWwubmFtZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vLyBEZWZhdWx0IHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB3ZWxsLWtub3duIHR5cGVzXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0UmVwbGFjZXIodXNlclJlcGxhY2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICAvLyBBcHBseSB1c2VyIHJlcGxhY2VyIGZpcnN0IGlmIHByb3ZpZGVkXG4gICAgICAgIGlmICh1c2VyUmVwbGFjZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJSZXN1bHQgPSB1c2VyUmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbCk7XG4gICAgICAgICAgICAvLyBJZiB1c2VyIHJlcGxhY2VyIHJldHVybmVkIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG91ciBzZXJpYWxpemF0aW9uXG4gICAgICAgICAgICBpZiAodXNlclJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG91ciB3ZWxsLWtub3duIHR5cGUgaGFuZGxpbmdcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVdlbGxLbm93blR5cGVzKHZhbCk7XG4gICAgfTtcbn1cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKG9iaiwgZXJyb3JDb250ZXh0LCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCBjcmVhdGVEZWZhdWx0UmVwbGFjZXIocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBtb3JlIGNvbXBsZXggc3RyaW5naWZ5IGlmIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgICBpZiAoIWUubWVzc2FnZT8uaW5jbHVkZXMoXCJDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OXCIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtXQVJOSU5HXTogTGFuZ1NtaXRoIHJlY2VpdmVkIHVuc2VyaWFsaXphYmxlIHZhbHVlLiR7ZXJyb3JDb250ZXh0ID8gYFxcbkNvbnRleHQ6ICR7ZXJyb3JDb250ZXh0fWAgOiBcIlwifWApO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVN0cmluZyhcIltVbnNlcmlhbGl6YWJsZV1cIik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlNVUFBSRVNTX0NJUkNVTEFSX0pTT05fV0FSTklOR1NcIikgIT09XG4gICAgICAgICAgICBcInRydWVcIiAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbV0FSTklOR106IExhbmdTbWl0aCByZWNlaXZlZCBjaXJjdWxhciBKU09OLiBUaGlzIHdpbGwgZGVjcmVhc2UgdHJhY2VyIHBlcmZvcm1hbmNlLiAke2Vycm9yQ29udGV4dCA/IGBcXG5Db250ZXh0OiAke2Vycm9yQ29udGV4dH1gIDogXCJcIn1gKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcocmVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRSZXBsYWNlKHJlcGxhY2UsIHZhbCwgaywgcGFyZW50KSB7XG4gICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKTtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7IHZhbHVlOiByZXBsYWNlIH0pO1xuICAgICAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudFtrXSA9IHJlcGxhY2U7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgd2VsbC1rbm93biB0eXBlcyBiZWZvcmUgT2JqZWN0LmtleXMgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YWwgPSBzZXJpYWxpemVXZWxsS25vd25UeXBlcyh2YWwpO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBkZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbn1cbi8vIFN0YWJsZS1zdHJpbmdpZnlcbmZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICAgIH1cbiAgICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosIFwiXCIsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpIHx8IG9iajtcbiAgICB2YXIgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc3RvcmUgdGhlIG9iamVjdCBhcyBpdCB3YXMuXG4gICAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICAgIGRlcHRoICs9IDE7XG4gICAgdmFyIGk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWwpO1xuICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgd2VsbC1rbm93biB0eXBlcyBiZWZvcmUgT2JqZWN0LmtleXMgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YWwgPSBzZXJpYWxpemVXZWxsS25vd25UeXBlcyh2YWwpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG9iamVjdCBpbiB0aGUgcmVxdWlyZWQgd2F5XG4gICAgICAgICAgICB2YXIgdG1wID0ge307XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRba10gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbn1cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICAgIHJlcGxhY2VyID1cbiAgICAgICAgdHlwZW9mIHJlcGxhY2VyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IHJlcGxhY2VyXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0WzFdID09PSBrZXkgJiYgcGFydFswXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICAgIH07XG59XG4iXSwibmFtZXMiOlsiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsIkxJTUlUX1JFUExBQ0VfTk9ERSIsIkNJUkNVTEFSX1JFUExBQ0VfTk9ERSIsInJlc3VsdCIsImFyciIsInJlcGxhY2VyU3RhY2siLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJkZWZhdWx0T3B0aW9ucyIsImRlcHRoTGltaXQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZWRnZXNMaW1pdCIsImVuY29kZVN0cmluZyIsInN0ciIsImVuY29kZSIsInNlcmlhbGl6ZVdlbGxLbm93blR5cGVzIiwidmFsIiwiTWFwIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJTZXQiLCJBcnJheSIsImZyb20iLCJEYXRlIiwidG9JU09TdHJpbmciLCJSZWdFeHAiLCJ0b1N0cmluZyIsIkVycm9yIiwibmFtZSIsIm1lc3NhZ2UiLCJjcmVhdGVEZWZhdWx0UmVwbGFjZXIiLCJ1c2VyUmVwbGFjZXIiLCJrZXkiLCJ1c2VyUmVzdWx0IiwiY2FsbCIsInVuZGVmaW5lZCIsInNlcmlhbGl6ZSIsIm9iaiIsImVycm9yQ29udGV4dCIsInJlcGxhY2VyIiwic3BhY2VyIiwib3B0aW9ucyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImRlY2lyYyIsInJlcyIsImxlbmd0aCIsInJlcGxhY2VHZXR0ZXJWYWx1ZXMiLCJfIiwicGFydCIsInBvcCIsImRlZmluZVByb3BlcnR5Iiwic2V0UmVwbGFjZSIsInJlcGxhY2UiLCJrIiwicGFyZW50IiwicHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJwdXNoIiwiZWRnZUluZGV4Iiwic3RhY2siLCJkZXB0aCIsImkiLCJpc0FycmF5Iiwia2V5cyIsImNvbXBhcmVGdW5jdGlvbiIsImEiLCJiIiwiZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSIsInRtcCIsImRldGVybWluaXN0aWNEZWNpcmMiLCJ0b0pTT04iLCJzb3J0IiwidiIsInNwbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmessage) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: {\n            content: message.content\n        }\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = {\n            ...message.additional_kwargs\n        };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQkFDaEIsOERBQThEO0FBQzlEQyxPQUFPO0lBQ0gsT0FBTyxPQUFPQSxTQUFTQyxhQUFhO0FBQ3hDO0FBQ08sU0FBU0MsaUNBQWlDRixPQUFPO0lBQ3BELE1BQU1HLFlBQVk7UUFDZEMsTUFBTUosUUFBUUMsUUFBUTtRQUN0QkksTUFBTTtZQUFFQyxTQUFTTixRQUFRTSxPQUFPO1FBQUM7SUFDckM7SUFDQSxrREFBa0Q7SUFDbEQsSUFBSU4sU0FBU08scUJBQ1RDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUU8saUJBQWlCLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ25EUCxVQUFVRSxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1lBQUUsR0FBR1AsUUFBUU8saUJBQWlCO1FBQUM7SUFDdEU7SUFDQSxPQUFPSjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL21lc3NhZ2VzLmpzPzQ3M2EiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzTGFuZ0NoYWluTWVzc2FnZShcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBjb252ZXJ0ZWQgPSB7XG4gICAgICAgIHR5cGU6IG1lc3NhZ2UuX2dldFR5cGUoKSxcbiAgICAgICAgZGF0YTogeyBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfSxcbiAgICB9O1xuICAgIC8vIENoZWNrIGZvciBwcmVzZW5jZSBvZiBrZXlzIGluIGFkZGl0aW9uYWxfa3dhcmdzXG4gICAgaWYgKG1lc3NhZ2U/LmFkZGl0aW9uYWxfa3dhcmdzICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29udmVydGVkLmRhdGEuYWRkaXRpb25hbF9rd2FyZ3MgPSB7IC4uLm1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbiJdLCJuYW1lcyI6WyJpc0xhbmdDaGFpbk1lc3NhZ2UiLCJtZXNzYWdlIiwiX2dldFR5cGUiLCJjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSIsImNvbnZlcnRlZCIsInR5cGUiLCJkYXRhIiwiY29udGVudCIsImFkZGl0aW9uYWxfa3dhcmdzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/project.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/project.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultProjectName: () => (/* binding */ getDefaultProjectName)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n\nconst getDefaultProjectName = ()=>{\n    return (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"PROJECT\") ?? (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n    \"default\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRjtBQUM3RSxNQUFNRSx3QkFBd0I7SUFDakMsT0FBUUQsd0VBQStCQSxDQUFDLGNBQ3BDRCwrREFBc0JBLENBQUMsd0JBQXdCLGtCQUFrQjtJQUNqRTtBQUNSLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvamVjdC5qcz81NzMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUsIH0gZnJvbSBcIi4vZW52LmpzXCI7XG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdFByb2plY3ROYW1lID0gKCkgPT4ge1xuICAgIHJldHVybiAoZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlBST0pFQ1RcIikgPz9cbiAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9TRVNTSU9OXCIpID8/IC8vIFRPRE86IERlcHJlY2F0ZVxuICAgICAgICBcImRlZmF1bHRcIik7XG59O1xuIl0sIm5hbWVzIjpbImdldEVudmlyb25tZW50VmFyaWFibGUiLCJnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0RGVmYXVsdFByb2plY3ROYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/project.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/prompts.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/prompts.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionGreaterOrEqual: () => (/* binding */ isVersionGreaterOrEqual),\n/* harmony export */   parsePromptIdentifier: () => (/* binding */ parsePromptIdentifier)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\n\nfunction isVersionGreaterOrEqual(current_version, target_version) {\n    const current = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(current_version);\n    const target = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(target_version);\n    if (!current || !target) {\n        throw new Error(\"Invalid version format.\");\n    }\n    return current.compare(target) >= 0;\n}\nfunction parsePromptIdentifier(identifier) {\n    if (!identifier || identifier.split(\"/\").length > 2 || identifier.startsWith(\"/\") || identifier.endsWith(\"/\") || identifier.split(\":\").length > 2) {\n        throw new Error(`Invalid identifier format: ${identifier}`);\n    }\n    const [ownerNamePart, commitPart] = identifier.split(\":\");\n    const commit = commitPart || \"latest\";\n    if (ownerNamePart.includes(\"/\")) {\n        const [owner, name] = ownerNamePart.split(\"/\", 2);\n        if (!owner || !name) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\n            owner,\n            name,\n            commit\n        ];\n    } else {\n        if (!ownerNamePart) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\n            \"-\",\n            ownerNamePart,\n            commit\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDeEMsU0FBU0Usd0JBQXdCQyxlQUFlLEVBQUVDLGNBQWM7SUFDbkUsTUFBTUMsVUFBVUosNkNBQVlBLENBQUNFO0lBQzdCLE1BQU1HLFNBQVNMLDZDQUFZQSxDQUFDRztJQUM1QixJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsUUFBUTtRQUNyQixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxPQUFPRixRQUFRRyxPQUFPLENBQUNGLFdBQVc7QUFDdEM7QUFDTyxTQUFTRyxzQkFBc0JDLFVBQVU7SUFDNUMsSUFBSSxDQUFDQSxjQUNEQSxXQUFXQyxLQUFLLENBQUMsS0FBS0MsTUFBTSxHQUFHLEtBQy9CRixXQUFXRyxVQUFVLENBQUMsUUFDdEJILFdBQVdJLFFBQVEsQ0FBQyxRQUNwQkosV0FBV0MsS0FBSyxDQUFDLEtBQUtDLE1BQU0sR0FBRyxHQUFHO1FBQ2xDLE1BQU0sSUFBSUwsTUFBTSxDQUFDLDJCQUEyQixFQUFFRyxXQUFXLENBQUM7SUFDOUQ7SUFDQSxNQUFNLENBQUNLLGVBQWVDLFdBQVcsR0FBR04sV0FBV0MsS0FBSyxDQUFDO0lBQ3JELE1BQU1NLFNBQVNELGNBQWM7SUFDN0IsSUFBSUQsY0FBY0csUUFBUSxDQUFDLE1BQU07UUFDN0IsTUFBTSxDQUFDQyxPQUFPQyxLQUFLLEdBQUdMLGNBQWNKLEtBQUssQ0FBQyxLQUFLO1FBQy9DLElBQUksQ0FBQ1EsU0FBUyxDQUFDQyxNQUFNO1lBQ2pCLE1BQU0sSUFBSWIsTUFBTSxDQUFDLDJCQUEyQixFQUFFRyxXQUFXLENBQUM7UUFDOUQ7UUFDQSxPQUFPO1lBQUNTO1lBQU9DO1lBQU1IO1NBQU87SUFDaEMsT0FDSztRQUNELElBQUksQ0FBQ0YsZUFBZTtZQUNoQixNQUFNLElBQUlSLE1BQU0sQ0FBQywyQkFBMkIsRUFBRUcsV0FBVyxDQUFDO1FBQzlEO1FBQ0EsT0FBTztZQUFDO1lBQUtLO1lBQWVFO1NBQU87SUFDdkM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9tcHRzLmpzPzc5YjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VWZXJzaW9uIH0gZnJvbSBcInNlbXZlclwiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsKGN1cnJlbnRfdmVyc2lvbiwgdGFyZ2V0X3ZlcnNpb24pIHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGFyc2VWZXJzaW9uKGN1cnJlbnRfdmVyc2lvbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VWZXJzaW9uKHRhcmdldF92ZXJzaW9uKTtcbiAgICBpZiAoIWN1cnJlbnQgfHwgIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZlcnNpb24gZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQuY29tcGFyZSh0YXJnZXQpID49IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9tcHRJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoIWlkZW50aWZpZXIgfHxcbiAgICAgICAgaWRlbnRpZmllci5zcGxpdChcIi9cIikubGVuZ3RoID4gMiB8fFxuICAgICAgICBpZGVudGlmaWVyLnN0YXJ0c1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuZW5kc1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlkZW50aWZpZXIgZm9ybWF0OiAke2lkZW50aWZpZXJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IFtvd25lck5hbWVQYXJ0LCBjb21taXRQYXJ0XSA9IGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGNvbW1pdCA9IGNvbW1pdFBhcnQgfHwgXCJsYXRlc3RcIjtcbiAgICBpZiAob3duZXJOYW1lUGFydC5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBuYW1lXSA9IG93bmVyTmFtZVBhcnQuc3BsaXQoXCIvXCIsIDIpO1xuICAgICAgICBpZiAoIW93bmVyIHx8ICFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW293bmVyLCBuYW1lLCBjb21taXRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFvd25lck5hbWVQYXJ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1wiLVwiLCBvd25lck5hbWVQYXJ0LCBjb21taXRdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJwYXJzZSIsInBhcnNlVmVyc2lvbiIsImlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsIiwiY3VycmVudF92ZXJzaW9uIiwidGFyZ2V0X3ZlcnNpb24iLCJjdXJyZW50IiwidGFyZ2V0IiwiRXJyb3IiLCJjb21wYXJlIiwicGFyc2VQcm9tcHRJZGVudGlmaWVyIiwiaWRlbnRpZmllciIsInNwbGl0IiwibGVuZ3RoIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwib3duZXJOYW1lUGFydCIsImNvbW1pdFBhcnQiLCJjb21taXQiLCJpbmNsdWRlcyIsIm93bmVyIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/prompts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/warn.js":
/*!***************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/warn.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce)\n/* harmony export */ });\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsaUJBQWlCLENBQUM7QUFDakIsU0FBU0MsU0FBU0MsT0FBTztJQUM1QixJQUFJLENBQUNGLGNBQWMsQ0FBQ0UsUUFBUSxFQUFFO1FBQzFCQyxRQUFRQyxJQUFJLENBQUNGO1FBQ2JGLGNBQWMsQ0FBQ0UsUUFBUSxHQUFHO0lBQzlCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcz8wMmQwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHdhcm5lZE1lc3NhZ2VzID0ge307XG5leHBvcnQgZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICAgIGlmICghd2FybmVkTWVzc2FnZXNbbWVzc2FnZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSA9IHRydWU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIndhcm5lZE1lc3NhZ2VzIiwid2Fybk9uY2UiLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/warn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__),\n/* harmony export */   getDefaultProjectName: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultProjectName),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvaW5kZXguanM/MTgxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Rpc3QvaW5kZXguanMnIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/run_trees.js":
/*!*********************************************!*\
  !*** ./node_modules/langsmith/run_trees.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL3J1bl90cmVlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvcnVuX3RyZWVzLmpzPzA1MmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9kaXN0L3J1bl90cmVlcy5qcyciXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/singletons/traceable.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/singletons/traceable.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.withRunTree)\n/* harmony export */ });\n/* harmony import */ var _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/singletons/traceable.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/traceable.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvc2luZ2xldG9ucy90cmFjZWFibGUuanM/MjZmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuLi9kaXN0L3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzJyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/singletons/traceable.js\n");

/***/ })

};
;